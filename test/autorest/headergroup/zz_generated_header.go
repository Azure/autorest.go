// +build go1.13

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package headergroup

import (
	"context"
	"encoding/base64"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"strconv"
	"time"
)

// HeaderOperations contains the methods for the Header group.
type HeaderOperations interface {
	// CustomRequestID - Send x-ms-client-request-id = 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0 in the header of the request
	CustomRequestID(ctx context.Context, options *HeaderCustomRequestIDOptions) (*http.Response, error)
	// ParamBool - Send a post request with header values "scenario": "true", "value": true or "scenario": "false", "value": false
	ParamBool(ctx context.Context, scenario string, value bool, options *HeaderParamBoolOptions) (*http.Response, error)
	// ParamByte - Send a post request with header values "scenario": "valid", "value": "啊齄丂狛狜隣郎隣兀﨩"
	ParamByte(ctx context.Context, scenario string, value []byte, options *HeaderParamByteOptions) (*http.Response, error)
	// ParamDate - Send a post request with header values "scenario": "valid", "value": "2010-01-01" or "scenario": "min", "value": "0001-01-01"
	ParamDate(ctx context.Context, scenario string, value time.Time, options *HeaderParamDateOptions) (*http.Response, error)
	// ParamDatetime - Send a post request with header values "scenario": "valid", "value": "2010-01-01T12:34:56Z" or "scenario": "min", "value": "0001-01-01T00:00:00Z"
	ParamDatetime(ctx context.Context, scenario string, value time.Time, options *HeaderParamDatetimeOptions) (*http.Response, error)
	// ParamDatetimeRFC1123 - Send a post request with header values "scenario": "valid", "value": "Wed, 01 Jan 2010 12:34:56 GMT" or "scenario": "min", "value":
	// "Mon, 01 Jan 0001 00:00:00 GMT"
	ParamDatetimeRFC1123(ctx context.Context, scenario string, options *HeaderParamDatetimeRFC1123Options) (*http.Response, error)
	// ParamDouble - Send a post request with header values "scenario": "positive", "value": 7e120 or "scenario": "negative", "value": -3.0
	ParamDouble(ctx context.Context, scenario string, value float64, options *HeaderParamDoubleOptions) (*http.Response, error)
	// ParamDuration - Send a post request with header values "scenario": "valid", "value": "P123DT22H14M12.011S"
	ParamDuration(ctx context.Context, scenario string, value string, options *HeaderParamDurationOptions) (*http.Response, error)
	// ParamEnum - Send a post request with header values "scenario": "valid", "value": "GREY" or "scenario": "null", "value": null
	ParamEnum(ctx context.Context, scenario string, options *HeaderParamEnumOptions) (*http.Response, error)
	// ParamExistingKey - Send a post request with header value "User-Agent": "overwrite"
	ParamExistingKey(ctx context.Context, userAgent string, options *HeaderParamExistingKeyOptions) (*http.Response, error)
	// ParamFloat - Send a post request with header values "scenario": "positive", "value": 0.07 or "scenario": "negative", "value": -3.0
	ParamFloat(ctx context.Context, scenario string, value float32, options *HeaderParamFloatOptions) (*http.Response, error)
	// ParamInteger - Send a post request with header values "scenario": "positive", "value": 1 or "scenario": "negative", "value": -2
	ParamInteger(ctx context.Context, scenario string, value int32, options *HeaderParamIntegerOptions) (*http.Response, error)
	// ParamLong - Send a post request with header values "scenario": "positive", "value": 105 or "scenario": "negative", "value": -2
	ParamLong(ctx context.Context, scenario string, value int64, options *HeaderParamLongOptions) (*http.Response, error)
	// ParamProtectedKey - Send a post request with header value "Content-Type": "text/html"
	ParamProtectedKey(ctx context.Context, contentType string, options *HeaderParamProtectedKeyOptions) (*http.Response, error)
	// ParamString - Send a post request with header values "scenario": "valid", "value": "The quick brown fox jumps over the lazy dog" or "scenario": "null",
	// "value": null or "scenario": "empty", "value": ""
	ParamString(ctx context.Context, scenario string, options *HeaderParamStringOptions) (*http.Response, error)
	// ResponseBool - Get a response with header value "value": true or false
	ResponseBool(ctx context.Context, scenario string, options *HeaderResponseBoolOptions) (*HeaderResponseBoolResponse, error)
	// ResponseByte - Get a response with header values "啊齄丂狛狜隣郎隣兀﨩"
	ResponseByte(ctx context.Context, scenario string, options *HeaderResponseByteOptions) (*HeaderResponseByteResponse, error)
	// ResponseDate - Get a response with header values "2010-01-01" or "0001-01-01"
	ResponseDate(ctx context.Context, scenario string, options *HeaderResponseDateOptions) (*HeaderResponseDateResponse, error)
	// ResponseDatetime - Get a response with header values "2010-01-01T12:34:56Z" or "0001-01-01T00:00:00Z"
	ResponseDatetime(ctx context.Context, scenario string, options *HeaderResponseDatetimeOptions) (*HeaderResponseDatetimeResponse, error)
	// ResponseDatetimeRFC1123 - Get a response with header values "Wed, 01 Jan 2010 12:34:56 GMT" or "Mon, 01 Jan 0001 00:00:00 GMT"
	ResponseDatetimeRFC1123(ctx context.Context, scenario string, options *HeaderResponseDatetimeRFC1123Options) (*HeaderResponseDatetimeRFC1123Response, error)
	// ResponseDouble - Get a response with header value "value": 7e120 or -3.0
	ResponseDouble(ctx context.Context, scenario string, options *HeaderResponseDoubleOptions) (*HeaderResponseDoubleResponse, error)
	// ResponseDuration - Get a response with header values "P123DT22H14M12.011S"
	ResponseDuration(ctx context.Context, scenario string, options *HeaderResponseDurationOptions) (*HeaderResponseDurationResponse, error)
	// ResponseEnum - Get a response with header values "GREY" or null
	ResponseEnum(ctx context.Context, scenario string, options *HeaderResponseEnumOptions) (*HeaderResponseEnumResponse, error)
	// ResponseExistingKey - Get a response with header value "User-Agent": "overwrite"
	ResponseExistingKey(ctx context.Context, options *HeaderResponseExistingKeyOptions) (*HeaderResponseExistingKeyResponse, error)
	// ResponseFloat - Get a response with header value "value": 0.07 or -3.0
	ResponseFloat(ctx context.Context, scenario string, options *HeaderResponseFloatOptions) (*HeaderResponseFloatResponse, error)
	// ResponseInteger - Get a response with header value "value": 1 or -2
	ResponseInteger(ctx context.Context, scenario string, options *HeaderResponseIntegerOptions) (*HeaderResponseIntegerResponse, error)
	// ResponseLong - Get a response with header value "value": 105 or -2
	ResponseLong(ctx context.Context, scenario string, options *HeaderResponseLongOptions) (*HeaderResponseLongResponse, error)
	// ResponseProtectedKey - Get a response with header value "Content-Type": "text/html"
	ResponseProtectedKey(ctx context.Context, options *HeaderResponseProtectedKeyOptions) (*HeaderResponseProtectedKeyResponse, error)
	// ResponseString - Get a response with header values "The quick brown fox jumps over the lazy dog" or null or ""
	ResponseString(ctx context.Context, scenario string, options *HeaderResponseStringOptions) (*HeaderResponseStringResponse, error)
}

// HeaderClient implements the HeaderOperations interface.
// Don't use this type directly, use NewHeaderClient() instead.
type HeaderClient struct {
	con *Connection
}

// NewHeaderClient creates a new instance of HeaderClient with the specified values.
func NewHeaderClient(con *Connection) HeaderOperations {
	return &HeaderClient{con: con}
}

// Pipeline returns the pipeline associated with this client.
func (client *HeaderClient) Pipeline() azcore.Pipeline {
	return client.con.Pipeline()
}

// CustomRequestID - Send x-ms-client-request-id = 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0 in the header of the request
func (client *HeaderClient) CustomRequestID(ctx context.Context, options *HeaderCustomRequestIDOptions) (*http.Response, error) {
	req, err := client.CustomRequestIDCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.CustomRequestIDHandleError(resp)
	}
	return resp.Response, nil
}

// CustomRequestIDCreateRequest creates the CustomRequestID request.
func (client *HeaderClient) CustomRequestIDCreateRequest(ctx context.Context, options *HeaderCustomRequestIDOptions) (*azcore.Request, error) {
	urlPath := "/header/custom/x-ms-client-request-id/9C4D50EE-2D56-4CD3-8152-34347DC9F2B0"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// CustomRequestIDHandleError handles the CustomRequestID error response.
func (client *HeaderClient) CustomRequestIDHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// ParamBool - Send a post request with header values "scenario": "true", "value": true or "scenario": "false", "value": false
func (client *HeaderClient) ParamBool(ctx context.Context, scenario string, value bool, options *HeaderParamBoolOptions) (*http.Response, error) {
	req, err := client.ParamBoolCreateRequest(ctx, scenario, value, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ParamBoolHandleError(resp)
	}
	return resp.Response, nil
}

// ParamBoolCreateRequest creates the ParamBool request.
func (client *HeaderClient) ParamBoolCreateRequest(ctx context.Context, scenario string, value bool, options *HeaderParamBoolOptions) (*azcore.Request, error) {
	urlPath := "/header/param/prim/bool"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("scenario", scenario)
	req.Header.Set("value", strconv.FormatBool(value))
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ParamBoolHandleError handles the ParamBool error response.
func (client *HeaderClient) ParamBoolHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// ParamByte - Send a post request with header values "scenario": "valid", "value": "啊齄丂狛狜隣郎隣兀﨩"
func (client *HeaderClient) ParamByte(ctx context.Context, scenario string, value []byte, options *HeaderParamByteOptions) (*http.Response, error) {
	req, err := client.ParamByteCreateRequest(ctx, scenario, value, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ParamByteHandleError(resp)
	}
	return resp.Response, nil
}

// ParamByteCreateRequest creates the ParamByte request.
func (client *HeaderClient) ParamByteCreateRequest(ctx context.Context, scenario string, value []byte, options *HeaderParamByteOptions) (*azcore.Request, error) {
	urlPath := "/header/param/prim/byte"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("scenario", scenario)
	req.Header.Set("value", base64.StdEncoding.EncodeToString(value))
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ParamByteHandleError handles the ParamByte error response.
func (client *HeaderClient) ParamByteHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// ParamDate - Send a post request with header values "scenario": "valid", "value": "2010-01-01" or "scenario": "min", "value": "0001-01-01"
func (client *HeaderClient) ParamDate(ctx context.Context, scenario string, value time.Time, options *HeaderParamDateOptions) (*http.Response, error) {
	req, err := client.ParamDateCreateRequest(ctx, scenario, value, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ParamDateHandleError(resp)
	}
	return resp.Response, nil
}

// ParamDateCreateRequest creates the ParamDate request.
func (client *HeaderClient) ParamDateCreateRequest(ctx context.Context, scenario string, value time.Time, options *HeaderParamDateOptions) (*azcore.Request, error) {
	urlPath := "/header/param/prim/date"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("scenario", scenario)
	req.Header.Set("value", value.Format("2006-01-02"))
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ParamDateHandleError handles the ParamDate error response.
func (client *HeaderClient) ParamDateHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// ParamDatetime - Send a post request with header values "scenario": "valid", "value": "2010-01-01T12:34:56Z" or "scenario": "min", "value": "0001-01-01T00:00:00Z"
func (client *HeaderClient) ParamDatetime(ctx context.Context, scenario string, value time.Time, options *HeaderParamDatetimeOptions) (*http.Response, error) {
	req, err := client.ParamDatetimeCreateRequest(ctx, scenario, value, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ParamDatetimeHandleError(resp)
	}
	return resp.Response, nil
}

// ParamDatetimeCreateRequest creates the ParamDatetime request.
func (client *HeaderClient) ParamDatetimeCreateRequest(ctx context.Context, scenario string, value time.Time, options *HeaderParamDatetimeOptions) (*azcore.Request, error) {
	urlPath := "/header/param/prim/datetime"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("scenario", scenario)
	req.Header.Set("value", value.Format(time.RFC3339Nano))
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ParamDatetimeHandleError handles the ParamDatetime error response.
func (client *HeaderClient) ParamDatetimeHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// ParamDatetimeRFC1123 - Send a post request with header values "scenario": "valid", "value": "Wed, 01 Jan 2010 12:34:56 GMT" or "scenario": "min", "value":
// "Mon, 01 Jan 0001 00:00:00 GMT"
func (client *HeaderClient) ParamDatetimeRFC1123(ctx context.Context, scenario string, options *HeaderParamDatetimeRFC1123Options) (*http.Response, error) {
	req, err := client.ParamDatetimeRFC1123CreateRequest(ctx, scenario, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ParamDatetimeRFC1123HandleError(resp)
	}
	return resp.Response, nil
}

// ParamDatetimeRFC1123CreateRequest creates the ParamDatetimeRFC1123 request.
func (client *HeaderClient) ParamDatetimeRFC1123CreateRequest(ctx context.Context, scenario string, options *HeaderParamDatetimeRFC1123Options) (*azcore.Request, error) {
	urlPath := "/header/param/prim/datetimerfc1123"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("scenario", scenario)
	if options != nil && options.Value != nil {
		req.Header.Set("value", options.Value.Format(time.RFC1123))
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ParamDatetimeRFC1123HandleError handles the ParamDatetimeRFC1123 error response.
func (client *HeaderClient) ParamDatetimeRFC1123HandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// ParamDouble - Send a post request with header values "scenario": "positive", "value": 7e120 or "scenario": "negative", "value": -3.0
func (client *HeaderClient) ParamDouble(ctx context.Context, scenario string, value float64, options *HeaderParamDoubleOptions) (*http.Response, error) {
	req, err := client.ParamDoubleCreateRequest(ctx, scenario, value, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ParamDoubleHandleError(resp)
	}
	return resp.Response, nil
}

// ParamDoubleCreateRequest creates the ParamDouble request.
func (client *HeaderClient) ParamDoubleCreateRequest(ctx context.Context, scenario string, value float64, options *HeaderParamDoubleOptions) (*azcore.Request, error) {
	urlPath := "/header/param/prim/double"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("scenario", scenario)
	req.Header.Set("value", strconv.FormatFloat(value, 'f', -1, 64))
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ParamDoubleHandleError handles the ParamDouble error response.
func (client *HeaderClient) ParamDoubleHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// ParamDuration - Send a post request with header values "scenario": "valid", "value": "P123DT22H14M12.011S"
func (client *HeaderClient) ParamDuration(ctx context.Context, scenario string, value string, options *HeaderParamDurationOptions) (*http.Response, error) {
	req, err := client.ParamDurationCreateRequest(ctx, scenario, value, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ParamDurationHandleError(resp)
	}
	return resp.Response, nil
}

// ParamDurationCreateRequest creates the ParamDuration request.
func (client *HeaderClient) ParamDurationCreateRequest(ctx context.Context, scenario string, value string, options *HeaderParamDurationOptions) (*azcore.Request, error) {
	urlPath := "/header/param/prim/duration"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("scenario", scenario)
	req.Header.Set("value", value)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ParamDurationHandleError handles the ParamDuration error response.
func (client *HeaderClient) ParamDurationHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// ParamEnum - Send a post request with header values "scenario": "valid", "value": "GREY" or "scenario": "null", "value": null
func (client *HeaderClient) ParamEnum(ctx context.Context, scenario string, options *HeaderParamEnumOptions) (*http.Response, error) {
	req, err := client.ParamEnumCreateRequest(ctx, scenario, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ParamEnumHandleError(resp)
	}
	return resp.Response, nil
}

// ParamEnumCreateRequest creates the ParamEnum request.
func (client *HeaderClient) ParamEnumCreateRequest(ctx context.Context, scenario string, options *HeaderParamEnumOptions) (*azcore.Request, error) {
	urlPath := "/header/param/prim/enum"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("scenario", scenario)
	if options != nil && options.Value != nil {
		req.Header.Set("value", string(*options.Value))
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ParamEnumHandleError handles the ParamEnum error response.
func (client *HeaderClient) ParamEnumHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// ParamExistingKey - Send a post request with header value "User-Agent": "overwrite"
func (client *HeaderClient) ParamExistingKey(ctx context.Context, userAgent string, options *HeaderParamExistingKeyOptions) (*http.Response, error) {
	req, err := client.ParamExistingKeyCreateRequest(ctx, userAgent, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ParamExistingKeyHandleError(resp)
	}
	return resp.Response, nil
}

// ParamExistingKeyCreateRequest creates the ParamExistingKey request.
func (client *HeaderClient) ParamExistingKeyCreateRequest(ctx context.Context, userAgent string, options *HeaderParamExistingKeyOptions) (*azcore.Request, error) {
	urlPath := "/header/param/existingkey"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("User-Agent", userAgent)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ParamExistingKeyHandleError handles the ParamExistingKey error response.
func (client *HeaderClient) ParamExistingKeyHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// ParamFloat - Send a post request with header values "scenario": "positive", "value": 0.07 or "scenario": "negative", "value": -3.0
func (client *HeaderClient) ParamFloat(ctx context.Context, scenario string, value float32, options *HeaderParamFloatOptions) (*http.Response, error) {
	req, err := client.ParamFloatCreateRequest(ctx, scenario, value, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ParamFloatHandleError(resp)
	}
	return resp.Response, nil
}

// ParamFloatCreateRequest creates the ParamFloat request.
func (client *HeaderClient) ParamFloatCreateRequest(ctx context.Context, scenario string, value float32, options *HeaderParamFloatOptions) (*azcore.Request, error) {
	urlPath := "/header/param/prim/float"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("scenario", scenario)
	req.Header.Set("value", strconv.FormatFloat(float64(value), 'f', -1, 32))
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ParamFloatHandleError handles the ParamFloat error response.
func (client *HeaderClient) ParamFloatHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// ParamInteger - Send a post request with header values "scenario": "positive", "value": 1 or "scenario": "negative", "value": -2
func (client *HeaderClient) ParamInteger(ctx context.Context, scenario string, value int32, options *HeaderParamIntegerOptions) (*http.Response, error) {
	req, err := client.ParamIntegerCreateRequest(ctx, scenario, value, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ParamIntegerHandleError(resp)
	}
	return resp.Response, nil
}

// ParamIntegerCreateRequest creates the ParamInteger request.
func (client *HeaderClient) ParamIntegerCreateRequest(ctx context.Context, scenario string, value int32, options *HeaderParamIntegerOptions) (*azcore.Request, error) {
	urlPath := "/header/param/prim/integer"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("scenario", scenario)
	req.Header.Set("value", strconv.FormatInt(int64(value), 10))
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ParamIntegerHandleError handles the ParamInteger error response.
func (client *HeaderClient) ParamIntegerHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// ParamLong - Send a post request with header values "scenario": "positive", "value": 105 or "scenario": "negative", "value": -2
func (client *HeaderClient) ParamLong(ctx context.Context, scenario string, value int64, options *HeaderParamLongOptions) (*http.Response, error) {
	req, err := client.ParamLongCreateRequest(ctx, scenario, value, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ParamLongHandleError(resp)
	}
	return resp.Response, nil
}

// ParamLongCreateRequest creates the ParamLong request.
func (client *HeaderClient) ParamLongCreateRequest(ctx context.Context, scenario string, value int64, options *HeaderParamLongOptions) (*azcore.Request, error) {
	urlPath := "/header/param/prim/long"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("scenario", scenario)
	req.Header.Set("value", strconv.FormatInt(value, 10))
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ParamLongHandleError handles the ParamLong error response.
func (client *HeaderClient) ParamLongHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// ParamProtectedKey - Send a post request with header value "Content-Type": "text/html"
func (client *HeaderClient) ParamProtectedKey(ctx context.Context, contentType string, options *HeaderParamProtectedKeyOptions) (*http.Response, error) {
	req, err := client.ParamProtectedKeyCreateRequest(ctx, contentType, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ParamProtectedKeyHandleError(resp)
	}
	return resp.Response, nil
}

// ParamProtectedKeyCreateRequest creates the ParamProtectedKey request.
func (client *HeaderClient) ParamProtectedKeyCreateRequest(ctx context.Context, contentType string, options *HeaderParamProtectedKeyOptions) (*azcore.Request, error) {
	urlPath := "/header/param/protectedkey"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", contentType)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ParamProtectedKeyHandleError handles the ParamProtectedKey error response.
func (client *HeaderClient) ParamProtectedKeyHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// ParamString - Send a post request with header values "scenario": "valid", "value": "The quick brown fox jumps over the lazy dog" or "scenario": "null",
// "value": null or "scenario": "empty", "value": ""
func (client *HeaderClient) ParamString(ctx context.Context, scenario string, options *HeaderParamStringOptions) (*http.Response, error) {
	req, err := client.ParamStringCreateRequest(ctx, scenario, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ParamStringHandleError(resp)
	}
	return resp.Response, nil
}

// ParamStringCreateRequest creates the ParamString request.
func (client *HeaderClient) ParamStringCreateRequest(ctx context.Context, scenario string, options *HeaderParamStringOptions) (*azcore.Request, error) {
	urlPath := "/header/param/prim/string"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("scenario", scenario)
	if options != nil && options.Value != nil {
		req.Header.Set("value", *options.Value)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ParamStringHandleError handles the ParamString error response.
func (client *HeaderClient) ParamStringHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// ResponseBool - Get a response with header value "value": true or false
func (client *HeaderClient) ResponseBool(ctx context.Context, scenario string, options *HeaderResponseBoolOptions) (*HeaderResponseBoolResponse, error) {
	req, err := client.ResponseBoolCreateRequest(ctx, scenario, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ResponseBoolHandleError(resp)
	}
	result, err := client.ResponseBoolHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResponseBoolCreateRequest creates the ResponseBool request.
func (client *HeaderClient) ResponseBoolCreateRequest(ctx context.Context, scenario string, options *HeaderResponseBoolOptions) (*azcore.Request, error) {
	urlPath := "/header/response/prim/bool"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("scenario", scenario)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ResponseBoolHandleResponse handles the ResponseBool response.
func (client *HeaderClient) ResponseBoolHandleResponse(resp *azcore.Response) (*HeaderResponseBoolResponse, error) {
	result := HeaderResponseBoolResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("value"); val != "" {
		value, err := strconv.ParseBool(val)
		if err != nil {
			return nil, err
		}
		result.Value = &value
	}
	return &result, nil
}

// ResponseBoolHandleError handles the ResponseBool error response.
func (client *HeaderClient) ResponseBoolHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// ResponseByte - Get a response with header values "啊齄丂狛狜隣郎隣兀﨩"
func (client *HeaderClient) ResponseByte(ctx context.Context, scenario string, options *HeaderResponseByteOptions) (*HeaderResponseByteResponse, error) {
	req, err := client.ResponseByteCreateRequest(ctx, scenario, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ResponseByteHandleError(resp)
	}
	result, err := client.ResponseByteHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResponseByteCreateRequest creates the ResponseByte request.
func (client *HeaderClient) ResponseByteCreateRequest(ctx context.Context, scenario string, options *HeaderResponseByteOptions) (*azcore.Request, error) {
	urlPath := "/header/response/prim/byte"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("scenario", scenario)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ResponseByteHandleResponse handles the ResponseByte response.
func (client *HeaderClient) ResponseByteHandleResponse(resp *azcore.Response) (*HeaderResponseByteResponse, error) {
	result := HeaderResponseByteResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("value"); val != "" {
		value, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return nil, err
		}
		result.Value = &value
	}
	return &result, nil
}

// ResponseByteHandleError handles the ResponseByte error response.
func (client *HeaderClient) ResponseByteHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// ResponseDate - Get a response with header values "2010-01-01" or "0001-01-01"
func (client *HeaderClient) ResponseDate(ctx context.Context, scenario string, options *HeaderResponseDateOptions) (*HeaderResponseDateResponse, error) {
	req, err := client.ResponseDateCreateRequest(ctx, scenario, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ResponseDateHandleError(resp)
	}
	result, err := client.ResponseDateHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResponseDateCreateRequest creates the ResponseDate request.
func (client *HeaderClient) ResponseDateCreateRequest(ctx context.Context, scenario string, options *HeaderResponseDateOptions) (*azcore.Request, error) {
	urlPath := "/header/response/prim/date"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("scenario", scenario)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ResponseDateHandleResponse handles the ResponseDate response.
func (client *HeaderClient) ResponseDateHandleResponse(resp *azcore.Response) (*HeaderResponseDateResponse, error) {
	result := HeaderResponseDateResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("value"); val != "" {
		value, err := time.Parse("2006-01-02", val)
		if err != nil {
			return nil, err
		}
		result.Value = &value
	}
	return &result, nil
}

// ResponseDateHandleError handles the ResponseDate error response.
func (client *HeaderClient) ResponseDateHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// ResponseDatetime - Get a response with header values "2010-01-01T12:34:56Z" or "0001-01-01T00:00:00Z"
func (client *HeaderClient) ResponseDatetime(ctx context.Context, scenario string, options *HeaderResponseDatetimeOptions) (*HeaderResponseDatetimeResponse, error) {
	req, err := client.ResponseDatetimeCreateRequest(ctx, scenario, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ResponseDatetimeHandleError(resp)
	}
	result, err := client.ResponseDatetimeHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResponseDatetimeCreateRequest creates the ResponseDatetime request.
func (client *HeaderClient) ResponseDatetimeCreateRequest(ctx context.Context, scenario string, options *HeaderResponseDatetimeOptions) (*azcore.Request, error) {
	urlPath := "/header/response/prim/datetime"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("scenario", scenario)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ResponseDatetimeHandleResponse handles the ResponseDatetime response.
func (client *HeaderClient) ResponseDatetimeHandleResponse(resp *azcore.Response) (*HeaderResponseDatetimeResponse, error) {
	result := HeaderResponseDatetimeResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("value"); val != "" {
		value, err := time.Parse(time.RFC3339Nano, val)
		if err != nil {
			return nil, err
		}
		result.Value = &value
	}
	return &result, nil
}

// ResponseDatetimeHandleError handles the ResponseDatetime error response.
func (client *HeaderClient) ResponseDatetimeHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// ResponseDatetimeRFC1123 - Get a response with header values "Wed, 01 Jan 2010 12:34:56 GMT" or "Mon, 01 Jan 0001 00:00:00 GMT"
func (client *HeaderClient) ResponseDatetimeRFC1123(ctx context.Context, scenario string, options *HeaderResponseDatetimeRFC1123Options) (*HeaderResponseDatetimeRFC1123Response, error) {
	req, err := client.ResponseDatetimeRFC1123CreateRequest(ctx, scenario, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ResponseDatetimeRFC1123HandleError(resp)
	}
	result, err := client.ResponseDatetimeRFC1123HandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResponseDatetimeRFC1123CreateRequest creates the ResponseDatetimeRFC1123 request.
func (client *HeaderClient) ResponseDatetimeRFC1123CreateRequest(ctx context.Context, scenario string, options *HeaderResponseDatetimeRFC1123Options) (*azcore.Request, error) {
	urlPath := "/header/response/prim/datetimerfc1123"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("scenario", scenario)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ResponseDatetimeRFC1123HandleResponse handles the ResponseDatetimeRFC1123 response.
func (client *HeaderClient) ResponseDatetimeRFC1123HandleResponse(resp *azcore.Response) (*HeaderResponseDatetimeRFC1123Response, error) {
	result := HeaderResponseDatetimeRFC1123Response{RawResponse: resp.Response}
	if val := resp.Header.Get("value"); val != "" {
		value, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.Value = &value
	}
	return &result, nil
}

// ResponseDatetimeRFC1123HandleError handles the ResponseDatetimeRFC1123 error response.
func (client *HeaderClient) ResponseDatetimeRFC1123HandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// ResponseDouble - Get a response with header value "value": 7e120 or -3.0
func (client *HeaderClient) ResponseDouble(ctx context.Context, scenario string, options *HeaderResponseDoubleOptions) (*HeaderResponseDoubleResponse, error) {
	req, err := client.ResponseDoubleCreateRequest(ctx, scenario, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ResponseDoubleHandleError(resp)
	}
	result, err := client.ResponseDoubleHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResponseDoubleCreateRequest creates the ResponseDouble request.
func (client *HeaderClient) ResponseDoubleCreateRequest(ctx context.Context, scenario string, options *HeaderResponseDoubleOptions) (*azcore.Request, error) {
	urlPath := "/header/response/prim/double"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("scenario", scenario)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ResponseDoubleHandleResponse handles the ResponseDouble response.
func (client *HeaderClient) ResponseDoubleHandleResponse(resp *azcore.Response) (*HeaderResponseDoubleResponse, error) {
	result := HeaderResponseDoubleResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("value"); val != "" {
		value, err := strconv.ParseFloat(val, 64)
		if err != nil {
			return nil, err
		}
		result.Value = &value
	}
	return &result, nil
}

// ResponseDoubleHandleError handles the ResponseDouble error response.
func (client *HeaderClient) ResponseDoubleHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// ResponseDuration - Get a response with header values "P123DT22H14M12.011S"
func (client *HeaderClient) ResponseDuration(ctx context.Context, scenario string, options *HeaderResponseDurationOptions) (*HeaderResponseDurationResponse, error) {
	req, err := client.ResponseDurationCreateRequest(ctx, scenario, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ResponseDurationHandleError(resp)
	}
	result, err := client.ResponseDurationHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResponseDurationCreateRequest creates the ResponseDuration request.
func (client *HeaderClient) ResponseDurationCreateRequest(ctx context.Context, scenario string, options *HeaderResponseDurationOptions) (*azcore.Request, error) {
	urlPath := "/header/response/prim/duration"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("scenario", scenario)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ResponseDurationHandleResponse handles the ResponseDuration response.
func (client *HeaderClient) ResponseDurationHandleResponse(resp *azcore.Response) (*HeaderResponseDurationResponse, error) {
	result := HeaderResponseDurationResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("value"); val != "" {
		result.Value = &val
	}
	return &result, nil
}

// ResponseDurationHandleError handles the ResponseDuration error response.
func (client *HeaderClient) ResponseDurationHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// ResponseEnum - Get a response with header values "GREY" or null
func (client *HeaderClient) ResponseEnum(ctx context.Context, scenario string, options *HeaderResponseEnumOptions) (*HeaderResponseEnumResponse, error) {
	req, err := client.ResponseEnumCreateRequest(ctx, scenario, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ResponseEnumHandleError(resp)
	}
	result, err := client.ResponseEnumHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResponseEnumCreateRequest creates the ResponseEnum request.
func (client *HeaderClient) ResponseEnumCreateRequest(ctx context.Context, scenario string, options *HeaderResponseEnumOptions) (*azcore.Request, error) {
	urlPath := "/header/response/prim/enum"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("scenario", scenario)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ResponseEnumHandleResponse handles the ResponseEnum response.
func (client *HeaderClient) ResponseEnumHandleResponse(resp *azcore.Response) (*HeaderResponseEnumResponse, error) {
	result := HeaderResponseEnumResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("value"); val != "" {
		result.Value = (*GreyscaleColors)(&val)
	}
	return &result, nil
}

// ResponseEnumHandleError handles the ResponseEnum error response.
func (client *HeaderClient) ResponseEnumHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// ResponseExistingKey - Get a response with header value "User-Agent": "overwrite"
func (client *HeaderClient) ResponseExistingKey(ctx context.Context, options *HeaderResponseExistingKeyOptions) (*HeaderResponseExistingKeyResponse, error) {
	req, err := client.ResponseExistingKeyCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ResponseExistingKeyHandleError(resp)
	}
	result, err := client.ResponseExistingKeyHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResponseExistingKeyCreateRequest creates the ResponseExistingKey request.
func (client *HeaderClient) ResponseExistingKeyCreateRequest(ctx context.Context, options *HeaderResponseExistingKeyOptions) (*azcore.Request, error) {
	urlPath := "/header/response/existingkey"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ResponseExistingKeyHandleResponse handles the ResponseExistingKey response.
func (client *HeaderClient) ResponseExistingKeyHandleResponse(resp *azcore.Response) (*HeaderResponseExistingKeyResponse, error) {
	result := HeaderResponseExistingKeyResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("User-Agent"); val != "" {
		result.UserAgent = &val
	}
	return &result, nil
}

// ResponseExistingKeyHandleError handles the ResponseExistingKey error response.
func (client *HeaderClient) ResponseExistingKeyHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// ResponseFloat - Get a response with header value "value": 0.07 or -3.0
func (client *HeaderClient) ResponseFloat(ctx context.Context, scenario string, options *HeaderResponseFloatOptions) (*HeaderResponseFloatResponse, error) {
	req, err := client.ResponseFloatCreateRequest(ctx, scenario, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ResponseFloatHandleError(resp)
	}
	result, err := client.ResponseFloatHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResponseFloatCreateRequest creates the ResponseFloat request.
func (client *HeaderClient) ResponseFloatCreateRequest(ctx context.Context, scenario string, options *HeaderResponseFloatOptions) (*azcore.Request, error) {
	urlPath := "/header/response/prim/float"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("scenario", scenario)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ResponseFloatHandleResponse handles the ResponseFloat response.
func (client *HeaderClient) ResponseFloatHandleResponse(resp *azcore.Response) (*HeaderResponseFloatResponse, error) {
	result := HeaderResponseFloatResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("value"); val != "" {
		value32, err := strconv.ParseFloat(val, 32)
		value := float32(value32)
		if err != nil {
			return nil, err
		}
		result.Value = &value
	}
	return &result, nil
}

// ResponseFloatHandleError handles the ResponseFloat error response.
func (client *HeaderClient) ResponseFloatHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// ResponseInteger - Get a response with header value "value": 1 or -2
func (client *HeaderClient) ResponseInteger(ctx context.Context, scenario string, options *HeaderResponseIntegerOptions) (*HeaderResponseIntegerResponse, error) {
	req, err := client.ResponseIntegerCreateRequest(ctx, scenario, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ResponseIntegerHandleError(resp)
	}
	result, err := client.ResponseIntegerHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResponseIntegerCreateRequest creates the ResponseInteger request.
func (client *HeaderClient) ResponseIntegerCreateRequest(ctx context.Context, scenario string, options *HeaderResponseIntegerOptions) (*azcore.Request, error) {
	urlPath := "/header/response/prim/integer"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("scenario", scenario)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ResponseIntegerHandleResponse handles the ResponseInteger response.
func (client *HeaderClient) ResponseIntegerHandleResponse(resp *azcore.Response) (*HeaderResponseIntegerResponse, error) {
	result := HeaderResponseIntegerResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("value"); val != "" {
		value32, err := strconv.ParseInt(val, 10, 32)
		value := int32(value32)
		if err != nil {
			return nil, err
		}
		result.Value = &value
	}
	return &result, nil
}

// ResponseIntegerHandleError handles the ResponseInteger error response.
func (client *HeaderClient) ResponseIntegerHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// ResponseLong - Get a response with header value "value": 105 or -2
func (client *HeaderClient) ResponseLong(ctx context.Context, scenario string, options *HeaderResponseLongOptions) (*HeaderResponseLongResponse, error) {
	req, err := client.ResponseLongCreateRequest(ctx, scenario, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ResponseLongHandleError(resp)
	}
	result, err := client.ResponseLongHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResponseLongCreateRequest creates the ResponseLong request.
func (client *HeaderClient) ResponseLongCreateRequest(ctx context.Context, scenario string, options *HeaderResponseLongOptions) (*azcore.Request, error) {
	urlPath := "/header/response/prim/long"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("scenario", scenario)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ResponseLongHandleResponse handles the ResponseLong response.
func (client *HeaderClient) ResponseLongHandleResponse(resp *azcore.Response) (*HeaderResponseLongResponse, error) {
	result := HeaderResponseLongResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("value"); val != "" {
		value, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return nil, err
		}
		result.Value = &value
	}
	return &result, nil
}

// ResponseLongHandleError handles the ResponseLong error response.
func (client *HeaderClient) ResponseLongHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// ResponseProtectedKey - Get a response with header value "Content-Type": "text/html"
func (client *HeaderClient) ResponseProtectedKey(ctx context.Context, options *HeaderResponseProtectedKeyOptions) (*HeaderResponseProtectedKeyResponse, error) {
	req, err := client.ResponseProtectedKeyCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ResponseProtectedKeyHandleError(resp)
	}
	result, err := client.ResponseProtectedKeyHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResponseProtectedKeyCreateRequest creates the ResponseProtectedKey request.
func (client *HeaderClient) ResponseProtectedKeyCreateRequest(ctx context.Context, options *HeaderResponseProtectedKeyOptions) (*azcore.Request, error) {
	urlPath := "/header/response/protectedkey"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ResponseProtectedKeyHandleResponse handles the ResponseProtectedKey response.
func (client *HeaderClient) ResponseProtectedKeyHandleResponse(resp *azcore.Response) (*HeaderResponseProtectedKeyResponse, error) {
	result := HeaderResponseProtectedKeyResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("Content-Type"); val != "" {
		result.ContentType = &val
	}
	return &result, nil
}

// ResponseProtectedKeyHandleError handles the ResponseProtectedKey error response.
func (client *HeaderClient) ResponseProtectedKeyHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// ResponseString - Get a response with header values "The quick brown fox jumps over the lazy dog" or null or ""
func (client *HeaderClient) ResponseString(ctx context.Context, scenario string, options *HeaderResponseStringOptions) (*HeaderResponseStringResponse, error) {
	req, err := client.ResponseStringCreateRequest(ctx, scenario, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ResponseStringHandleError(resp)
	}
	result, err := client.ResponseStringHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResponseStringCreateRequest creates the ResponseString request.
func (client *HeaderClient) ResponseStringCreateRequest(ctx context.Context, scenario string, options *HeaderResponseStringOptions) (*azcore.Request, error) {
	urlPath := "/header/response/prim/string"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("scenario", scenario)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ResponseStringHandleResponse handles the ResponseString response.
func (client *HeaderClient) ResponseStringHandleResponse(resp *azcore.Response) (*HeaderResponseStringResponse, error) {
	result := HeaderResponseStringResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("value"); val != "" {
		result.Value = &val
	}
	return &result, nil
}

// ResponseStringHandleError handles the ResponseString error response.
func (client *HeaderClient) ResponseStringHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}
