// +build go1.13

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package lrogroup

import (
	"context"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/armcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"time"
)

// LROsClient contains the methods for the LROs group.
// Don't use this type directly, use NewLROsClient() instead.
type LROsClient struct {
	con *Connection
}

// NewLROsClient creates a new instance of LROsClient with the specified values.
func NewLROsClient(con *Connection) *LROsClient {
	return &LROsClient{con: con}
}

// BeginDelete202NoRetry204 - Long running delete request, service returns a 202 to the initial request. Polls return this value until the last poll returns
// a ‘200’ with ProvisioningState=’Succeeded’
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) BeginDelete202NoRetry204(ctx context.Context, options *LROsBeginDelete202NoRetry204Options) (ProductPollerResponse, error) {
	resp, err := client.delete202NoRetry204(ctx, options)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	result := ProductPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LROsClient.Delete202NoRetry204", "", resp, client.delete202NoRetry204HandleError)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	poller := &productPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeDelete202NoRetry204 creates a new ProductPoller from the specified resume token.
// token - The value must come from a previous call to ProductPoller.ResumeToken().
func (client *LROsClient) ResumeDelete202NoRetry204(ctx context.Context, token string) (ProductPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("LROsClient.Delete202NoRetry204", token, client.delete202NoRetry204HandleError)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	poller := &productPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	result := ProductPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// Delete202NoRetry204 - Long running delete request, service returns a 202 to the initial request. Polls return this value until the last poll returns
// a ‘200’ with ProvisioningState=’Succeeded’
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) delete202NoRetry204(ctx context.Context, options *LROsBeginDelete202NoRetry204Options) (*azcore.Response, error) {
	req, err := client.delete202NoRetry204CreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.delete202NoRetry204HandleError(resp)
	}
	return resp, nil
}

// delete202NoRetry204CreateRequest creates the Delete202NoRetry204 request.
func (client *LROsClient) delete202NoRetry204CreateRequest(ctx context.Context, options *LROsBeginDelete202NoRetry204Options) (*azcore.Request, error) {
	urlPath := "/lro/delete/202/noretry/204"
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// delete202NoRetry204HandleResponse handles the Delete202NoRetry204 response.
func (client *LROsClient) delete202NoRetry204HandleResponse(resp *azcore.Response) (ProductResponse, error) {
	var val *Product
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProductResponse{}, err
	}
	return ProductResponse{RawResponse: resp.Response, Product: val}, nil
}

// delete202NoRetry204HandleError handles the Delete202NoRetry204 error response.
func (client *LROsClient) delete202NoRetry204HandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginDelete202Retry200 - Long running delete request, service returns a 202 to the initial request. Polls return this value until the last poll returns
// a ‘200’ with ProvisioningState=’Succeeded’
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) BeginDelete202Retry200(ctx context.Context, options *LROsBeginDelete202Retry200Options) (ProductPollerResponse, error) {
	resp, err := client.delete202Retry200(ctx, options)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	result := ProductPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LROsClient.Delete202Retry200", "", resp, client.delete202Retry200HandleError)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	poller := &productPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeDelete202Retry200 creates a new ProductPoller from the specified resume token.
// token - The value must come from a previous call to ProductPoller.ResumeToken().
func (client *LROsClient) ResumeDelete202Retry200(ctx context.Context, token string) (ProductPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("LROsClient.Delete202Retry200", token, client.delete202Retry200HandleError)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	poller := &productPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	result := ProductPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// Delete202Retry200 - Long running delete request, service returns a 202 to the initial request. Polls return this value until the last poll returns a
// ‘200’ with ProvisioningState=’Succeeded’
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) delete202Retry200(ctx context.Context, options *LROsBeginDelete202Retry200Options) (*azcore.Response, error) {
	req, err := client.delete202Retry200CreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.delete202Retry200HandleError(resp)
	}
	return resp, nil
}

// delete202Retry200CreateRequest creates the Delete202Retry200 request.
func (client *LROsClient) delete202Retry200CreateRequest(ctx context.Context, options *LROsBeginDelete202Retry200Options) (*azcore.Request, error) {
	urlPath := "/lro/delete/202/retry/200"
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// delete202Retry200HandleResponse handles the Delete202Retry200 response.
func (client *LROsClient) delete202Retry200HandleResponse(resp *azcore.Response) (ProductResponse, error) {
	var val *Product
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProductResponse{}, err
	}
	return ProductResponse{RawResponse: resp.Response, Product: val}, nil
}

// delete202Retry200HandleError handles the Delete202Retry200 error response.
func (client *LROsClient) delete202Retry200HandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginDelete204Succeeded - Long running delete succeeds and returns right away
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) BeginDelete204Succeeded(ctx context.Context, options *LROsBeginDelete204SucceededOptions) (HTTPPollerResponse, error) {
	resp, err := client.delete204Succeeded(ctx, options)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	result := HTTPPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LROsClient.Delete204Succeeded", "", resp, client.delete204SucceededHandleError)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	poller := &httpPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeDelete204Succeeded creates a new HTTPPoller from the specified resume token.
// token - The value must come from a previous call to HTTPPoller.ResumeToken().
func (client *LROsClient) ResumeDelete204Succeeded(ctx context.Context, token string) (HTTPPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("LROsClient.Delete204Succeeded", token, client.delete204SucceededHandleError)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	poller := &httpPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	result := HTTPPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// Delete204Succeeded - Long running delete succeeds and returns right away
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) delete204Succeeded(ctx context.Context, options *LROsBeginDelete204SucceededOptions) (*azcore.Response, error) {
	req, err := client.delete204SucceededCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusNoContent) {
		return nil, client.delete204SucceededHandleError(resp)
	}
	return resp, nil
}

// delete204SucceededCreateRequest creates the Delete204Succeeded request.
func (client *LROsClient) delete204SucceededCreateRequest(ctx context.Context, options *LROsBeginDelete204SucceededOptions) (*azcore.Request, error) {
	urlPath := "/lro/delete/204/succeeded"
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// delete204SucceededHandleError handles the Delete204Succeeded error response.
func (client *LROsClient) delete204SucceededHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginDeleteAsyncNoHeaderInRetry - Long running delete request, service returns an Azure-AsyncOperation header in the initial request. Subsequent calls
// to operation status do not contain Azure-AsyncOperation header.
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) BeginDeleteAsyncNoHeaderInRetry(ctx context.Context, options *LROsBeginDeleteAsyncNoHeaderInRetryOptions) (HTTPPollerResponse, error) {
	resp, err := client.deleteAsyncNoHeaderInRetry(ctx, options)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	result := HTTPPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LROsClient.DeleteAsyncNoHeaderInRetry", "", resp, client.deleteAsyncNoHeaderInRetryHandleError)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	poller := &httpPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeDeleteAsyncNoHeaderInRetry creates a new HTTPPoller from the specified resume token.
// token - The value must come from a previous call to HTTPPoller.ResumeToken().
func (client *LROsClient) ResumeDeleteAsyncNoHeaderInRetry(ctx context.Context, token string) (HTTPPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("LROsClient.DeleteAsyncNoHeaderInRetry", token, client.deleteAsyncNoHeaderInRetryHandleError)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	poller := &httpPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	result := HTTPPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// DeleteAsyncNoHeaderInRetry - Long running delete request, service returns an Azure-AsyncOperation header in the initial request. Subsequent calls to
// operation status do not contain Azure-AsyncOperation header.
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) deleteAsyncNoHeaderInRetry(ctx context.Context, options *LROsBeginDeleteAsyncNoHeaderInRetryOptions) (*azcore.Response, error) {
	req, err := client.deleteAsyncNoHeaderInRetryCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted, http.StatusNoContent) {
		return nil, client.deleteAsyncNoHeaderInRetryHandleError(resp)
	}
	return resp, nil
}

// deleteAsyncNoHeaderInRetryCreateRequest creates the DeleteAsyncNoHeaderInRetry request.
func (client *LROsClient) deleteAsyncNoHeaderInRetryCreateRequest(ctx context.Context, options *LROsBeginDeleteAsyncNoHeaderInRetryOptions) (*azcore.Request, error) {
	urlPath := "/lro/deleteasync/noheader/202/204"
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteAsyncNoHeaderInRetryHandleError handles the DeleteAsyncNoHeaderInRetry error response.
func (client *LROsClient) deleteAsyncNoHeaderInRetryHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginDeleteAsyncNoRetrySucceeded - Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation
// header for operation status
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) BeginDeleteAsyncNoRetrySucceeded(ctx context.Context, options *LROsBeginDeleteAsyncNoRetrySucceededOptions) (HTTPPollerResponse, error) {
	resp, err := client.deleteAsyncNoRetrySucceeded(ctx, options)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	result := HTTPPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LROsClient.DeleteAsyncNoRetrySucceeded", "", resp, client.deleteAsyncNoRetrySucceededHandleError)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	poller := &httpPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeDeleteAsyncNoRetrySucceeded creates a new HTTPPoller from the specified resume token.
// token - The value must come from a previous call to HTTPPoller.ResumeToken().
func (client *LROsClient) ResumeDeleteAsyncNoRetrySucceeded(ctx context.Context, token string) (HTTPPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("LROsClient.DeleteAsyncNoRetrySucceeded", token, client.deleteAsyncNoRetrySucceededHandleError)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	poller := &httpPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	result := HTTPPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// DeleteAsyncNoRetrySucceeded - Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation
// header for operation status
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) deleteAsyncNoRetrySucceeded(ctx context.Context, options *LROsBeginDeleteAsyncNoRetrySucceededOptions) (*azcore.Response, error) {
	req, err := client.deleteAsyncNoRetrySucceededCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, client.deleteAsyncNoRetrySucceededHandleError(resp)
	}
	return resp, nil
}

// deleteAsyncNoRetrySucceededCreateRequest creates the DeleteAsyncNoRetrySucceeded request.
func (client *LROsClient) deleteAsyncNoRetrySucceededCreateRequest(ctx context.Context, options *LROsBeginDeleteAsyncNoRetrySucceededOptions) (*azcore.Request, error) {
	urlPath := "/lro/deleteasync/noretry/succeeded"
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteAsyncNoRetrySucceededHandleError handles the DeleteAsyncNoRetrySucceeded error response.
func (client *LROsClient) deleteAsyncNoRetrySucceededHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginDeleteAsyncRetryFailed - Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation
// header for operation status
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) BeginDeleteAsyncRetryFailed(ctx context.Context, options *LROsBeginDeleteAsyncRetryFailedOptions) (HTTPPollerResponse, error) {
	resp, err := client.deleteAsyncRetryFailed(ctx, options)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	result := HTTPPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LROsClient.DeleteAsyncRetryFailed", "", resp, client.deleteAsyncRetryFailedHandleError)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	poller := &httpPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeDeleteAsyncRetryFailed creates a new HTTPPoller from the specified resume token.
// token - The value must come from a previous call to HTTPPoller.ResumeToken().
func (client *LROsClient) ResumeDeleteAsyncRetryFailed(ctx context.Context, token string) (HTTPPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("LROsClient.DeleteAsyncRetryFailed", token, client.deleteAsyncRetryFailedHandleError)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	poller := &httpPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	result := HTTPPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// DeleteAsyncRetryFailed - Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation
// header for operation status
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) deleteAsyncRetryFailed(ctx context.Context, options *LROsBeginDeleteAsyncRetryFailedOptions) (*azcore.Response, error) {
	req, err := client.deleteAsyncRetryFailedCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, client.deleteAsyncRetryFailedHandleError(resp)
	}
	return resp, nil
}

// deleteAsyncRetryFailedCreateRequest creates the DeleteAsyncRetryFailed request.
func (client *LROsClient) deleteAsyncRetryFailedCreateRequest(ctx context.Context, options *LROsBeginDeleteAsyncRetryFailedOptions) (*azcore.Request, error) {
	urlPath := "/lro/deleteasync/retry/failed"
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteAsyncRetryFailedHandleError handles the DeleteAsyncRetryFailed error response.
func (client *LROsClient) deleteAsyncRetryFailedHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginDeleteAsyncRetrySucceeded - Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation
// header for operation status
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) BeginDeleteAsyncRetrySucceeded(ctx context.Context, options *LROsBeginDeleteAsyncRetrySucceededOptions) (HTTPPollerResponse, error) {
	resp, err := client.deleteAsyncRetrySucceeded(ctx, options)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	result := HTTPPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LROsClient.DeleteAsyncRetrySucceeded", "", resp, client.deleteAsyncRetrySucceededHandleError)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	poller := &httpPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeDeleteAsyncRetrySucceeded creates a new HTTPPoller from the specified resume token.
// token - The value must come from a previous call to HTTPPoller.ResumeToken().
func (client *LROsClient) ResumeDeleteAsyncRetrySucceeded(ctx context.Context, token string) (HTTPPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("LROsClient.DeleteAsyncRetrySucceeded", token, client.deleteAsyncRetrySucceededHandleError)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	poller := &httpPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	result := HTTPPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// DeleteAsyncRetrySucceeded - Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation
// header for operation status
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) deleteAsyncRetrySucceeded(ctx context.Context, options *LROsBeginDeleteAsyncRetrySucceededOptions) (*azcore.Response, error) {
	req, err := client.deleteAsyncRetrySucceededCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, client.deleteAsyncRetrySucceededHandleError(resp)
	}
	return resp, nil
}

// deleteAsyncRetrySucceededCreateRequest creates the DeleteAsyncRetrySucceeded request.
func (client *LROsClient) deleteAsyncRetrySucceededCreateRequest(ctx context.Context, options *LROsBeginDeleteAsyncRetrySucceededOptions) (*azcore.Request, error) {
	urlPath := "/lro/deleteasync/retry/succeeded"
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteAsyncRetrySucceededHandleError handles the DeleteAsyncRetrySucceeded error response.
func (client *LROsClient) deleteAsyncRetrySucceededHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginDeleteAsyncRetrycanceled - Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation
// header for operation status
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) BeginDeleteAsyncRetrycanceled(ctx context.Context, options *LROsBeginDeleteAsyncRetrycanceledOptions) (HTTPPollerResponse, error) {
	resp, err := client.deleteAsyncRetrycanceled(ctx, options)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	result := HTTPPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LROsClient.DeleteAsyncRetrycanceled", "", resp, client.deleteAsyncRetrycanceledHandleError)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	poller := &httpPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeDeleteAsyncRetrycanceled creates a new HTTPPoller from the specified resume token.
// token - The value must come from a previous call to HTTPPoller.ResumeToken().
func (client *LROsClient) ResumeDeleteAsyncRetrycanceled(ctx context.Context, token string) (HTTPPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("LROsClient.DeleteAsyncRetrycanceled", token, client.deleteAsyncRetrycanceledHandleError)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	poller := &httpPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	result := HTTPPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// DeleteAsyncRetrycanceled - Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation
// header for operation status
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) deleteAsyncRetrycanceled(ctx context.Context, options *LROsBeginDeleteAsyncRetrycanceledOptions) (*azcore.Response, error) {
	req, err := client.deleteAsyncRetrycanceledCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, client.deleteAsyncRetrycanceledHandleError(resp)
	}
	return resp, nil
}

// deleteAsyncRetrycanceledCreateRequest creates the DeleteAsyncRetrycanceled request.
func (client *LROsClient) deleteAsyncRetrycanceledCreateRequest(ctx context.Context, options *LROsBeginDeleteAsyncRetrycanceledOptions) (*azcore.Request, error) {
	urlPath := "/lro/deleteasync/retry/canceled"
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteAsyncRetrycanceledHandleError handles the DeleteAsyncRetrycanceled error response.
func (client *LROsClient) deleteAsyncRetrycanceledHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginDeleteNoHeaderInRetry - Long running delete request, service returns a location header in the initial request. Subsequent calls to operation status
// do not contain location header.
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) BeginDeleteNoHeaderInRetry(ctx context.Context, options *LROsBeginDeleteNoHeaderInRetryOptions) (HTTPPollerResponse, error) {
	resp, err := client.deleteNoHeaderInRetry(ctx, options)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	result := HTTPPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LROsClient.DeleteNoHeaderInRetry", "", resp, client.deleteNoHeaderInRetryHandleError)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	poller := &httpPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeDeleteNoHeaderInRetry creates a new HTTPPoller from the specified resume token.
// token - The value must come from a previous call to HTTPPoller.ResumeToken().
func (client *LROsClient) ResumeDeleteNoHeaderInRetry(ctx context.Context, token string) (HTTPPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("LROsClient.DeleteNoHeaderInRetry", token, client.deleteNoHeaderInRetryHandleError)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	poller := &httpPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	result := HTTPPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// DeleteNoHeaderInRetry - Long running delete request, service returns a location header in the initial request. Subsequent calls to operation status do
// not contain location header.
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) deleteNoHeaderInRetry(ctx context.Context, options *LROsBeginDeleteNoHeaderInRetryOptions) (*azcore.Response, error) {
	req, err := client.deleteNoHeaderInRetryCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted, http.StatusNoContent) {
		return nil, client.deleteNoHeaderInRetryHandleError(resp)
	}
	return resp, nil
}

// deleteNoHeaderInRetryCreateRequest creates the DeleteNoHeaderInRetry request.
func (client *LROsClient) deleteNoHeaderInRetryCreateRequest(ctx context.Context, options *LROsBeginDeleteNoHeaderInRetryOptions) (*azcore.Request, error) {
	urlPath := "/lro/delete/noheader"
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteNoHeaderInRetryHandleError handles the DeleteNoHeaderInRetry error response.
func (client *LROsClient) deleteNoHeaderInRetryHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginDeleteProvisioning202Accepted200Succeeded - Long running delete request, service returns a 202 to the initial request, with an entity that contains
// ProvisioningState=’Accepted’. Polls return this value until the last poll returns a ‘200’ with
// ProvisioningState=’Succeeded’
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) BeginDeleteProvisioning202Accepted200Succeeded(ctx context.Context, options *LROsBeginDeleteProvisioning202Accepted200SucceededOptions) (ProductPollerResponse, error) {
	resp, err := client.deleteProvisioning202Accepted200Succeeded(ctx, options)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	result := ProductPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LROsClient.DeleteProvisioning202Accepted200Succeeded", "", resp, client.deleteProvisioning202Accepted200SucceededHandleError)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	poller := &productPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeDeleteProvisioning202Accepted200Succeeded creates a new ProductPoller from the specified resume token.
// token - The value must come from a previous call to ProductPoller.ResumeToken().
func (client *LROsClient) ResumeDeleteProvisioning202Accepted200Succeeded(ctx context.Context, token string) (ProductPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("LROsClient.DeleteProvisioning202Accepted200Succeeded", token, client.deleteProvisioning202Accepted200SucceededHandleError)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	poller := &productPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	result := ProductPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// DeleteProvisioning202Accepted200Succeeded - Long running delete request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Accepted’.
// Polls return this value until the last poll returns a ‘200’ with
// ProvisioningState=’Succeeded’
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) deleteProvisioning202Accepted200Succeeded(ctx context.Context, options *LROsBeginDeleteProvisioning202Accepted200SucceededOptions) (*azcore.Response, error) {
	req, err := client.deleteProvisioning202Accepted200SucceededCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.deleteProvisioning202Accepted200SucceededHandleError(resp)
	}
	return resp, nil
}

// deleteProvisioning202Accepted200SucceededCreateRequest creates the DeleteProvisioning202Accepted200Succeeded request.
func (client *LROsClient) deleteProvisioning202Accepted200SucceededCreateRequest(ctx context.Context, options *LROsBeginDeleteProvisioning202Accepted200SucceededOptions) (*azcore.Request, error) {
	urlPath := "/lro/delete/provisioning/202/accepted/200/succeeded"
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteProvisioning202Accepted200SucceededHandleResponse handles the DeleteProvisioning202Accepted200Succeeded response.
func (client *LROsClient) deleteProvisioning202Accepted200SucceededHandleResponse(resp *azcore.Response) (ProductResponse, error) {
	var val *Product
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProductResponse{}, err
	}
	return ProductResponse{RawResponse: resp.Response, Product: val}, nil
}

// deleteProvisioning202Accepted200SucceededHandleError handles the DeleteProvisioning202Accepted200Succeeded error response.
func (client *LROsClient) deleteProvisioning202Accepted200SucceededHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginDeleteProvisioning202DeletingFailed200 - Long running delete request, service returns a 202 to the initial request, with an entity that contains
// ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’ with
// ProvisioningState=’Failed’
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) BeginDeleteProvisioning202DeletingFailed200(ctx context.Context, options *LROsBeginDeleteProvisioning202DeletingFailed200Options) (ProductPollerResponse, error) {
	resp, err := client.deleteProvisioning202DeletingFailed200(ctx, options)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	result := ProductPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LROsClient.DeleteProvisioning202DeletingFailed200", "", resp, client.deleteProvisioning202DeletingFailed200HandleError)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	poller := &productPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeDeleteProvisioning202DeletingFailed200 creates a new ProductPoller from the specified resume token.
// token - The value must come from a previous call to ProductPoller.ResumeToken().
func (client *LROsClient) ResumeDeleteProvisioning202DeletingFailed200(ctx context.Context, token string) (ProductPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("LROsClient.DeleteProvisioning202DeletingFailed200", token, client.deleteProvisioning202DeletingFailed200HandleError)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	poller := &productPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	result := ProductPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// DeleteProvisioning202DeletingFailed200 - Long running delete request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’.
// Polls return this value until the last poll returns a ‘200’ with
// ProvisioningState=’Failed’
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) deleteProvisioning202DeletingFailed200(ctx context.Context, options *LROsBeginDeleteProvisioning202DeletingFailed200Options) (*azcore.Response, error) {
	req, err := client.deleteProvisioning202DeletingFailed200CreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.deleteProvisioning202DeletingFailed200HandleError(resp)
	}
	return resp, nil
}

// deleteProvisioning202DeletingFailed200CreateRequest creates the DeleteProvisioning202DeletingFailed200 request.
func (client *LROsClient) deleteProvisioning202DeletingFailed200CreateRequest(ctx context.Context, options *LROsBeginDeleteProvisioning202DeletingFailed200Options) (*azcore.Request, error) {
	urlPath := "/lro/delete/provisioning/202/deleting/200/failed"
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteProvisioning202DeletingFailed200HandleResponse handles the DeleteProvisioning202DeletingFailed200 response.
func (client *LROsClient) deleteProvisioning202DeletingFailed200HandleResponse(resp *azcore.Response) (ProductResponse, error) {
	var val *Product
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProductResponse{}, err
	}
	return ProductResponse{RawResponse: resp.Response, Product: val}, nil
}

// deleteProvisioning202DeletingFailed200HandleError handles the DeleteProvisioning202DeletingFailed200 error response.
func (client *LROsClient) deleteProvisioning202DeletingFailed200HandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginDeleteProvisioning202Deletingcanceled200 - Long running delete request, service returns a 202 to the initial request, with an entity that contains
// ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’ with
// ProvisioningState=’Canceled’
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) BeginDeleteProvisioning202Deletingcanceled200(ctx context.Context, options *LROsBeginDeleteProvisioning202Deletingcanceled200Options) (ProductPollerResponse, error) {
	resp, err := client.deleteProvisioning202Deletingcanceled200(ctx, options)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	result := ProductPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LROsClient.DeleteProvisioning202Deletingcanceled200", "", resp, client.deleteProvisioning202Deletingcanceled200HandleError)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	poller := &productPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeDeleteProvisioning202Deletingcanceled200 creates a new ProductPoller from the specified resume token.
// token - The value must come from a previous call to ProductPoller.ResumeToken().
func (client *LROsClient) ResumeDeleteProvisioning202Deletingcanceled200(ctx context.Context, token string) (ProductPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("LROsClient.DeleteProvisioning202Deletingcanceled200", token, client.deleteProvisioning202Deletingcanceled200HandleError)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	poller := &productPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	result := ProductPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// DeleteProvisioning202Deletingcanceled200 - Long running delete request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’.
// Polls return this value until the last poll returns a ‘200’ with
// ProvisioningState=’Canceled’
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) deleteProvisioning202Deletingcanceled200(ctx context.Context, options *LROsBeginDeleteProvisioning202Deletingcanceled200Options) (*azcore.Response, error) {
	req, err := client.deleteProvisioning202Deletingcanceled200CreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.deleteProvisioning202Deletingcanceled200HandleError(resp)
	}
	return resp, nil
}

// deleteProvisioning202Deletingcanceled200CreateRequest creates the DeleteProvisioning202Deletingcanceled200 request.
func (client *LROsClient) deleteProvisioning202Deletingcanceled200CreateRequest(ctx context.Context, options *LROsBeginDeleteProvisioning202Deletingcanceled200Options) (*azcore.Request, error) {
	urlPath := "/lro/delete/provisioning/202/deleting/200/canceled"
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteProvisioning202Deletingcanceled200HandleResponse handles the DeleteProvisioning202Deletingcanceled200 response.
func (client *LROsClient) deleteProvisioning202Deletingcanceled200HandleResponse(resp *azcore.Response) (ProductResponse, error) {
	var val *Product
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProductResponse{}, err
	}
	return ProductResponse{RawResponse: resp.Response, Product: val}, nil
}

// deleteProvisioning202Deletingcanceled200HandleError handles the DeleteProvisioning202Deletingcanceled200 error response.
func (client *LROsClient) deleteProvisioning202Deletingcanceled200HandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginPost200WithPayload - Long running post request, service returns a 202 to the initial request, with 'Location' header. Poll returns a 200 with a
// response body after success.
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) BeginPost200WithPayload(ctx context.Context, options *LROsBeginPost200WithPayloadOptions) (SKUPollerResponse, error) {
	resp, err := client.post200WithPayload(ctx, options)
	if err != nil {
		return SKUPollerResponse{}, err
	}
	result := SKUPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LROsClient.Post200WithPayload", "", resp, client.post200WithPayloadHandleError)
	if err != nil {
		return SKUPollerResponse{}, err
	}
	poller := &skuPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (SKUResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumePost200WithPayload creates a new SKUPoller from the specified resume token.
// token - The value must come from a previous call to SKUPoller.ResumeToken().
func (client *LROsClient) ResumePost200WithPayload(ctx context.Context, token string) (SKUPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("LROsClient.Post200WithPayload", token, client.post200WithPayloadHandleError)
	if err != nil {
		return SKUPollerResponse{}, err
	}
	poller := &skuPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return SKUPollerResponse{}, err
	}
	result := SKUPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (SKUResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// Post200WithPayload - Long running post request, service returns a 202 to the initial request, with 'Location' header. Poll returns a 200 with a response
// body after success.
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) post200WithPayload(ctx context.Context, options *LROsBeginPost200WithPayloadOptions) (*azcore.Response, error) {
	req, err := client.post200WithPayloadCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.post200WithPayloadHandleError(resp)
	}
	return resp, nil
}

// post200WithPayloadCreateRequest creates the Post200WithPayload request.
func (client *LROsClient) post200WithPayloadCreateRequest(ctx context.Context, options *LROsBeginPost200WithPayloadOptions) (*azcore.Request, error) {
	urlPath := "/lro/post/payload/200"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// post200WithPayloadHandleResponse handles the Post200WithPayload response.
func (client *LROsClient) post200WithPayloadHandleResponse(resp *azcore.Response) (SKUResponse, error) {
	var val *SKU
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SKUResponse{}, err
	}
	return SKUResponse{RawResponse: resp.Response, SKU: val}, nil
}

// post200WithPayloadHandleError handles the Post200WithPayload error response.
func (client *LROsClient) post200WithPayloadHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginPost202List - Long running put request, service returns a 202 with empty body to first request, returns a 200 with body [{ 'id': '100', 'name':
// 'foo' }].
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) BeginPost202List(ctx context.Context, options *LROsBeginPost202ListOptions) (ProductArrayPollerResponse, error) {
	resp, err := client.post202List(ctx, options)
	if err != nil {
		return ProductArrayPollerResponse{}, err
	}
	result := ProductArrayPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LROsClient.Post202List", "", resp, client.post202ListHandleError)
	if err != nil {
		return ProductArrayPollerResponse{}, err
	}
	poller := &productArrayPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ProductArrayResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumePost202List creates a new ProductArrayPoller from the specified resume token.
// token - The value must come from a previous call to ProductArrayPoller.ResumeToken().
func (client *LROsClient) ResumePost202List(ctx context.Context, token string) (ProductArrayPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("LROsClient.Post202List", token, client.post202ListHandleError)
	if err != nil {
		return ProductArrayPollerResponse{}, err
	}
	poller := &productArrayPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return ProductArrayPollerResponse{}, err
	}
	result := ProductArrayPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ProductArrayResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// Post202List - Long running put request, service returns a 202 with empty body to first request, returns a 200 with body [{ 'id': '100', 'name': 'foo'
// }].
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) post202List(ctx context.Context, options *LROsBeginPost202ListOptions) (*azcore.Response, error) {
	req, err := client.post202ListCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.post202ListHandleError(resp)
	}
	return resp, nil
}

// post202ListCreateRequest creates the Post202List request.
func (client *LROsClient) post202ListCreateRequest(ctx context.Context, options *LROsBeginPost202ListOptions) (*azcore.Request, error) {
	urlPath := "/lro/list"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// post202ListHandleResponse handles the Post202List response.
func (client *LROsClient) post202ListHandleResponse(resp *azcore.Response) (ProductArrayResponse, error) {
	var val []*Product
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProductArrayResponse{}, err
	}
	return ProductArrayResponse{RawResponse: resp.Response, ProductArray: val}, nil
}

// post202ListHandleError handles the Post202List error response.
func (client *LROsClient) post202ListHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginPost202NoRetry204 - Long running post request, service returns a 202 to the initial request, with 'Location' header, 204 with noresponse body after
// success
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) BeginPost202NoRetry204(ctx context.Context, options *LROsBeginPost202NoRetry204Options) (ProductPollerResponse, error) {
	resp, err := client.post202NoRetry204(ctx, options)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	result := ProductPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LROsClient.Post202NoRetry204", "", resp, client.post202NoRetry204HandleError)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	poller := &productPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumePost202NoRetry204 creates a new ProductPoller from the specified resume token.
// token - The value must come from a previous call to ProductPoller.ResumeToken().
func (client *LROsClient) ResumePost202NoRetry204(ctx context.Context, token string) (ProductPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("LROsClient.Post202NoRetry204", token, client.post202NoRetry204HandleError)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	poller := &productPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	result := ProductPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// Post202NoRetry204 - Long running post request, service returns a 202 to the initial request, with 'Location' header, 204 with noresponse body after success
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) post202NoRetry204(ctx context.Context, options *LROsBeginPost202NoRetry204Options) (*azcore.Response, error) {
	req, err := client.post202NoRetry204CreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, client.post202NoRetry204HandleError(resp)
	}
	return resp, nil
}

// post202NoRetry204CreateRequest creates the Post202NoRetry204 request.
func (client *LROsClient) post202NoRetry204CreateRequest(ctx context.Context, options *LROsBeginPost202NoRetry204Options) (*azcore.Request, error) {
	urlPath := "/lro/post/202/noretry/204"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// post202NoRetry204HandleResponse handles the Post202NoRetry204 response.
func (client *LROsClient) post202NoRetry204HandleResponse(resp *azcore.Response) (ProductResponse, error) {
	var val *Product
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProductResponse{}, err
	}
	return ProductResponse{RawResponse: resp.Response, Product: val}, nil
}

// post202NoRetry204HandleError handles the Post202NoRetry204 error response.
func (client *LROsClient) post202NoRetry204HandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginPost202Retry200 - Long running post request, service returns a 202 to the initial request, with 'Location' and 'Retry-After' headers, Polls return
// a 200 with a response body after success
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) BeginPost202Retry200(ctx context.Context, options *LROsBeginPost202Retry200Options) (HTTPPollerResponse, error) {
	resp, err := client.post202Retry200(ctx, options)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	result := HTTPPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LROsClient.Post202Retry200", "", resp, client.post202Retry200HandleError)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	poller := &httpPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumePost202Retry200 creates a new HTTPPoller from the specified resume token.
// token - The value must come from a previous call to HTTPPoller.ResumeToken().
func (client *LROsClient) ResumePost202Retry200(ctx context.Context, token string) (HTTPPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("LROsClient.Post202Retry200", token, client.post202Retry200HandleError)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	poller := &httpPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	result := HTTPPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// Post202Retry200 - Long running post request, service returns a 202 to the initial request, with 'Location' and 'Retry-After' headers, Polls return a
// 200 with a response body after success
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) post202Retry200(ctx context.Context, options *LROsBeginPost202Retry200Options) (*azcore.Response, error) {
	req, err := client.post202Retry200CreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, client.post202Retry200HandleError(resp)
	}
	return resp, nil
}

// post202Retry200CreateRequest creates the Post202Retry200 request.
func (client *LROsClient) post202Retry200CreateRequest(ctx context.Context, options *LROsBeginPost202Retry200Options) (*azcore.Request, error) {
	urlPath := "/lro/post/202/retry/200"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// post202Retry200HandleError handles the Post202Retry200 error response.
func (client *LROsClient) post202Retry200HandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginPostAsyncNoRetrySucceeded - Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’.
// Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) BeginPostAsyncNoRetrySucceeded(ctx context.Context, options *LROsBeginPostAsyncNoRetrySucceededOptions) (ProductPollerResponse, error) {
	resp, err := client.postAsyncNoRetrySucceeded(ctx, options)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	result := ProductPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LROsClient.PostAsyncNoRetrySucceeded", "", resp, client.postAsyncNoRetrySucceededHandleError)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	poller := &productPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumePostAsyncNoRetrySucceeded creates a new ProductPoller from the specified resume token.
// token - The value must come from a previous call to ProductPoller.ResumeToken().
func (client *LROsClient) ResumePostAsyncNoRetrySucceeded(ctx context.Context, token string) (ProductPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("LROsClient.PostAsyncNoRetrySucceeded", token, client.postAsyncNoRetrySucceededHandleError)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	poller := &productPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	result := ProductPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// PostAsyncNoRetrySucceeded - Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’.
// Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) postAsyncNoRetrySucceeded(ctx context.Context, options *LROsBeginPostAsyncNoRetrySucceededOptions) (*azcore.Response, error) {
	req, err := client.postAsyncNoRetrySucceededCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.postAsyncNoRetrySucceededHandleError(resp)
	}
	return resp, nil
}

// postAsyncNoRetrySucceededCreateRequest creates the PostAsyncNoRetrySucceeded request.
func (client *LROsClient) postAsyncNoRetrySucceededCreateRequest(ctx context.Context, options *LROsBeginPostAsyncNoRetrySucceededOptions) (*azcore.Request, error) {
	urlPath := "/lro/postasync/noretry/succeeded"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// postAsyncNoRetrySucceededHandleResponse handles the PostAsyncNoRetrySucceeded response.
func (client *LROsClient) postAsyncNoRetrySucceededHandleResponse(resp *azcore.Response) (ProductResponse, error) {
	var val *Product
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProductResponse{}, err
	}
	return ProductResponse{RawResponse: resp.Response, Product: val}, nil
}

// postAsyncNoRetrySucceededHandleError handles the PostAsyncNoRetrySucceeded error response.
func (client *LROsClient) postAsyncNoRetrySucceededHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginPostAsyncRetryFailed - Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’.
// Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) BeginPostAsyncRetryFailed(ctx context.Context, options *LROsBeginPostAsyncRetryFailedOptions) (HTTPPollerResponse, error) {
	resp, err := client.postAsyncRetryFailed(ctx, options)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	result := HTTPPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LROsClient.PostAsyncRetryFailed", "", resp, client.postAsyncRetryFailedHandleError)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	poller := &httpPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumePostAsyncRetryFailed creates a new HTTPPoller from the specified resume token.
// token - The value must come from a previous call to HTTPPoller.ResumeToken().
func (client *LROsClient) ResumePostAsyncRetryFailed(ctx context.Context, token string) (HTTPPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("LROsClient.PostAsyncRetryFailed", token, client.postAsyncRetryFailedHandleError)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	poller := &httpPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	result := HTTPPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// PostAsyncRetryFailed - Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’.
// Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) postAsyncRetryFailed(ctx context.Context, options *LROsBeginPostAsyncRetryFailedOptions) (*azcore.Response, error) {
	req, err := client.postAsyncRetryFailedCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, client.postAsyncRetryFailedHandleError(resp)
	}
	return resp, nil
}

// postAsyncRetryFailedCreateRequest creates the PostAsyncRetryFailed request.
func (client *LROsClient) postAsyncRetryFailedCreateRequest(ctx context.Context, options *LROsBeginPostAsyncRetryFailedOptions) (*azcore.Request, error) {
	urlPath := "/lro/postasync/retry/failed"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// postAsyncRetryFailedHandleError handles the PostAsyncRetryFailed error response.
func (client *LROsClient) postAsyncRetryFailedHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginPostAsyncRetrySucceeded - Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’.
// Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) BeginPostAsyncRetrySucceeded(ctx context.Context, options *LROsBeginPostAsyncRetrySucceededOptions) (ProductPollerResponse, error) {
	resp, err := client.postAsyncRetrySucceeded(ctx, options)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	result := ProductPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LROsClient.PostAsyncRetrySucceeded", "", resp, client.postAsyncRetrySucceededHandleError)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	poller := &productPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumePostAsyncRetrySucceeded creates a new ProductPoller from the specified resume token.
// token - The value must come from a previous call to ProductPoller.ResumeToken().
func (client *LROsClient) ResumePostAsyncRetrySucceeded(ctx context.Context, token string) (ProductPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("LROsClient.PostAsyncRetrySucceeded", token, client.postAsyncRetrySucceededHandleError)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	poller := &productPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	result := ProductPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// PostAsyncRetrySucceeded - Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’.
// Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) postAsyncRetrySucceeded(ctx context.Context, options *LROsBeginPostAsyncRetrySucceededOptions) (*azcore.Response, error) {
	req, err := client.postAsyncRetrySucceededCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.postAsyncRetrySucceededHandleError(resp)
	}
	return resp, nil
}

// postAsyncRetrySucceededCreateRequest creates the PostAsyncRetrySucceeded request.
func (client *LROsClient) postAsyncRetrySucceededCreateRequest(ctx context.Context, options *LROsBeginPostAsyncRetrySucceededOptions) (*azcore.Request, error) {
	urlPath := "/lro/postasync/retry/succeeded"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// postAsyncRetrySucceededHandleResponse handles the PostAsyncRetrySucceeded response.
func (client *LROsClient) postAsyncRetrySucceededHandleResponse(resp *azcore.Response) (ProductResponse, error) {
	var val *Product
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProductResponse{}, err
	}
	return ProductResponse{RawResponse: resp.Response, Product: val}, nil
}

// postAsyncRetrySucceededHandleError handles the PostAsyncRetrySucceeded error response.
func (client *LROsClient) postAsyncRetrySucceededHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginPostAsyncRetrycanceled - Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’.
// Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) BeginPostAsyncRetrycanceled(ctx context.Context, options *LROsBeginPostAsyncRetrycanceledOptions) (HTTPPollerResponse, error) {
	resp, err := client.postAsyncRetrycanceled(ctx, options)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	result := HTTPPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LROsClient.PostAsyncRetrycanceled", "", resp, client.postAsyncRetrycanceledHandleError)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	poller := &httpPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumePostAsyncRetrycanceled creates a new HTTPPoller from the specified resume token.
// token - The value must come from a previous call to HTTPPoller.ResumeToken().
func (client *LROsClient) ResumePostAsyncRetrycanceled(ctx context.Context, token string) (HTTPPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("LROsClient.PostAsyncRetrycanceled", token, client.postAsyncRetrycanceledHandleError)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	poller := &httpPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	result := HTTPPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// PostAsyncRetrycanceled - Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’.
// Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) postAsyncRetrycanceled(ctx context.Context, options *LROsBeginPostAsyncRetrycanceledOptions) (*azcore.Response, error) {
	req, err := client.postAsyncRetrycanceledCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, client.postAsyncRetrycanceledHandleError(resp)
	}
	return resp, nil
}

// postAsyncRetrycanceledCreateRequest creates the PostAsyncRetrycanceled request.
func (client *LROsClient) postAsyncRetrycanceledCreateRequest(ctx context.Context, options *LROsBeginPostAsyncRetrycanceledOptions) (*azcore.Request, error) {
	urlPath := "/lro/postasync/retry/canceled"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// postAsyncRetrycanceledHandleError handles the PostAsyncRetrycanceled error response.
func (client *LROsClient) postAsyncRetrycanceledHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginPostDoubleHeadersFinalAzureHeaderGet - Long running post request, service returns a 202 to the initial request with both Location and Azure-Async
// header. Poll Azure-Async and it's success. Should NOT poll Location to get the final object
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) BeginPostDoubleHeadersFinalAzureHeaderGet(ctx context.Context, options *LROsBeginPostDoubleHeadersFinalAzureHeaderGetOptions) (ProductPollerResponse, error) {
	resp, err := client.postDoubleHeadersFinalAzureHeaderGet(ctx, options)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	result := ProductPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LROsClient.PostDoubleHeadersFinalAzureHeaderGet", "azure-async-operation", resp, client.postDoubleHeadersFinalAzureHeaderGetHandleError)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	poller := &productPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumePostDoubleHeadersFinalAzureHeaderGet creates a new ProductPoller from the specified resume token.
// token - The value must come from a previous call to ProductPoller.ResumeToken().
func (client *LROsClient) ResumePostDoubleHeadersFinalAzureHeaderGet(ctx context.Context, token string) (ProductPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("LROsClient.PostDoubleHeadersFinalAzureHeaderGet", token, client.postDoubleHeadersFinalAzureHeaderGetHandleError)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	poller := &productPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	result := ProductPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// PostDoubleHeadersFinalAzureHeaderGet - Long running post request, service returns a 202 to the initial request with both Location and Azure-Async header.
// Poll Azure-Async and it's success. Should NOT poll Location to get the final object
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) postDoubleHeadersFinalAzureHeaderGet(ctx context.Context, options *LROsBeginPostDoubleHeadersFinalAzureHeaderGetOptions) (*azcore.Response, error) {
	req, err := client.postDoubleHeadersFinalAzureHeaderGetCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, client.postDoubleHeadersFinalAzureHeaderGetHandleError(resp)
	}
	return resp, nil
}

// postDoubleHeadersFinalAzureHeaderGetCreateRequest creates the PostDoubleHeadersFinalAzureHeaderGet request.
func (client *LROsClient) postDoubleHeadersFinalAzureHeaderGetCreateRequest(ctx context.Context, options *LROsBeginPostDoubleHeadersFinalAzureHeaderGetOptions) (*azcore.Request, error) {
	urlPath := "/lro/LROPostDoubleHeadersFinalAzureHeaderGet"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// postDoubleHeadersFinalAzureHeaderGetHandleResponse handles the PostDoubleHeadersFinalAzureHeaderGet response.
func (client *LROsClient) postDoubleHeadersFinalAzureHeaderGetHandleResponse(resp *azcore.Response) (ProductResponse, error) {
	var val *Product
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProductResponse{}, err
	}
	return ProductResponse{RawResponse: resp.Response, Product: val}, nil
}

// postDoubleHeadersFinalAzureHeaderGetHandleError handles the PostDoubleHeadersFinalAzureHeaderGet error response.
func (client *LROsClient) postDoubleHeadersFinalAzureHeaderGetHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginPostDoubleHeadersFinalAzureHeaderGetDefault - Long running post request, service returns a 202 to the initial request with both Location and Azure-Async
// header. Poll Azure-Async and it's success. Should NOT poll Location to get the final object
// if you support initial Autorest behavior.
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) BeginPostDoubleHeadersFinalAzureHeaderGetDefault(ctx context.Context, options *LROsBeginPostDoubleHeadersFinalAzureHeaderGetDefaultOptions) (ProductPollerResponse, error) {
	resp, err := client.postDoubleHeadersFinalAzureHeaderGetDefault(ctx, options)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	result := ProductPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LROsClient.PostDoubleHeadersFinalAzureHeaderGetDefault", "", resp, client.postDoubleHeadersFinalAzureHeaderGetDefaultHandleError)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	poller := &productPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumePostDoubleHeadersFinalAzureHeaderGetDefault creates a new ProductPoller from the specified resume token.
// token - The value must come from a previous call to ProductPoller.ResumeToken().
func (client *LROsClient) ResumePostDoubleHeadersFinalAzureHeaderGetDefault(ctx context.Context, token string) (ProductPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("LROsClient.PostDoubleHeadersFinalAzureHeaderGetDefault", token, client.postDoubleHeadersFinalAzureHeaderGetDefaultHandleError)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	poller := &productPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	result := ProductPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// PostDoubleHeadersFinalAzureHeaderGetDefault - Long running post request, service returns a 202 to the initial request with both Location and Azure-Async
// header. Poll Azure-Async and it's success. Should NOT poll Location to get the final object
// if you support initial Autorest behavior.
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) postDoubleHeadersFinalAzureHeaderGetDefault(ctx context.Context, options *LROsBeginPostDoubleHeadersFinalAzureHeaderGetDefaultOptions) (*azcore.Response, error) {
	req, err := client.postDoubleHeadersFinalAzureHeaderGetDefaultCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, client.postDoubleHeadersFinalAzureHeaderGetDefaultHandleError(resp)
	}
	return resp, nil
}

// postDoubleHeadersFinalAzureHeaderGetDefaultCreateRequest creates the PostDoubleHeadersFinalAzureHeaderGetDefault request.
func (client *LROsClient) postDoubleHeadersFinalAzureHeaderGetDefaultCreateRequest(ctx context.Context, options *LROsBeginPostDoubleHeadersFinalAzureHeaderGetDefaultOptions) (*azcore.Request, error) {
	urlPath := "/lro/LROPostDoubleHeadersFinalAzureHeaderGetDefault"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// postDoubleHeadersFinalAzureHeaderGetDefaultHandleResponse handles the PostDoubleHeadersFinalAzureHeaderGetDefault response.
func (client *LROsClient) postDoubleHeadersFinalAzureHeaderGetDefaultHandleResponse(resp *azcore.Response) (ProductResponse, error) {
	var val *Product
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProductResponse{}, err
	}
	return ProductResponse{RawResponse: resp.Response, Product: val}, nil
}

// postDoubleHeadersFinalAzureHeaderGetDefaultHandleError handles the PostDoubleHeadersFinalAzureHeaderGetDefault error response.
func (client *LROsClient) postDoubleHeadersFinalAzureHeaderGetDefaultHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginPostDoubleHeadersFinalLocationGet - Long running post request, service returns a 202 to the initial request with both Location and Azure-Async header.
// Poll Azure-Async and it's success. Should poll Location to get the final object
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) BeginPostDoubleHeadersFinalLocationGet(ctx context.Context, options *LROsBeginPostDoubleHeadersFinalLocationGetOptions) (ProductPollerResponse, error) {
	resp, err := client.postDoubleHeadersFinalLocationGet(ctx, options)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	result := ProductPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LROsClient.PostDoubleHeadersFinalLocationGet", "location", resp, client.postDoubleHeadersFinalLocationGetHandleError)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	poller := &productPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumePostDoubleHeadersFinalLocationGet creates a new ProductPoller from the specified resume token.
// token - The value must come from a previous call to ProductPoller.ResumeToken().
func (client *LROsClient) ResumePostDoubleHeadersFinalLocationGet(ctx context.Context, token string) (ProductPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("LROsClient.PostDoubleHeadersFinalLocationGet", token, client.postDoubleHeadersFinalLocationGetHandleError)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	poller := &productPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	result := ProductPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// PostDoubleHeadersFinalLocationGet - Long running post request, service returns a 202 to the initial request with both Location and Azure-Async header.
// Poll Azure-Async and it's success. Should poll Location to get the final object
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) postDoubleHeadersFinalLocationGet(ctx context.Context, options *LROsBeginPostDoubleHeadersFinalLocationGetOptions) (*azcore.Response, error) {
	req, err := client.postDoubleHeadersFinalLocationGetCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, client.postDoubleHeadersFinalLocationGetHandleError(resp)
	}
	return resp, nil
}

// postDoubleHeadersFinalLocationGetCreateRequest creates the PostDoubleHeadersFinalLocationGet request.
func (client *LROsClient) postDoubleHeadersFinalLocationGetCreateRequest(ctx context.Context, options *LROsBeginPostDoubleHeadersFinalLocationGetOptions) (*azcore.Request, error) {
	urlPath := "/lro/LROPostDoubleHeadersFinalLocationGet"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// postDoubleHeadersFinalLocationGetHandleResponse handles the PostDoubleHeadersFinalLocationGet response.
func (client *LROsClient) postDoubleHeadersFinalLocationGetHandleResponse(resp *azcore.Response) (ProductResponse, error) {
	var val *Product
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProductResponse{}, err
	}
	return ProductResponse{RawResponse: resp.Response, Product: val}, nil
}

// postDoubleHeadersFinalLocationGetHandleError handles the PostDoubleHeadersFinalLocationGet error response.
func (client *LROsClient) postDoubleHeadersFinalLocationGetHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginPut200Acceptedcanceled200 - Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Creating’.
// Polls return this value until the last poll returns a ‘200’ with
// ProvisioningState=’Canceled’
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) BeginPut200Acceptedcanceled200(ctx context.Context, options *LROsBeginPut200Acceptedcanceled200Options) (ProductPollerResponse, error) {
	resp, err := client.put200Acceptedcanceled200(ctx, options)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	result := ProductPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LROsClient.Put200Acceptedcanceled200", "", resp, client.put200Acceptedcanceled200HandleError)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	poller := &productPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumePut200Acceptedcanceled200 creates a new ProductPoller from the specified resume token.
// token - The value must come from a previous call to ProductPoller.ResumeToken().
func (client *LROsClient) ResumePut200Acceptedcanceled200(ctx context.Context, token string) (ProductPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("LROsClient.Put200Acceptedcanceled200", token, client.put200Acceptedcanceled200HandleError)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	poller := &productPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	result := ProductPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// Put200Acceptedcanceled200 - Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Creating’.
// Polls return this value until the last poll returns a ‘200’ with
// ProvisioningState=’Canceled’
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) put200Acceptedcanceled200(ctx context.Context, options *LROsBeginPut200Acceptedcanceled200Options) (*azcore.Response, error) {
	req, err := client.put200Acceptedcanceled200CreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.put200Acceptedcanceled200HandleError(resp)
	}
	return resp, nil
}

// put200Acceptedcanceled200CreateRequest creates the Put200Acceptedcanceled200 request.
func (client *LROsClient) put200Acceptedcanceled200CreateRequest(ctx context.Context, options *LROsBeginPut200Acceptedcanceled200Options) (*azcore.Request, error) {
	urlPath := "/lro/put/200/accepted/canceled/200"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// put200Acceptedcanceled200HandleResponse handles the Put200Acceptedcanceled200 response.
func (client *LROsClient) put200Acceptedcanceled200HandleResponse(resp *azcore.Response) (ProductResponse, error) {
	var val *Product
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProductResponse{}, err
	}
	return ProductResponse{RawResponse: resp.Response, Product: val}, nil
}

// put200Acceptedcanceled200HandleError handles the Put200Acceptedcanceled200 error response.
func (client *LROsClient) put200Acceptedcanceled200HandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginPut200Succeeded - Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Succeeded’.
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) BeginPut200Succeeded(ctx context.Context, options *LROsBeginPut200SucceededOptions) (ProductPollerResponse, error) {
	resp, err := client.put200Succeeded(ctx, options)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	result := ProductPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LROsClient.Put200Succeeded", "", resp, client.put200SucceededHandleError)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	poller := &productPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumePut200Succeeded creates a new ProductPoller from the specified resume token.
// token - The value must come from a previous call to ProductPoller.ResumeToken().
func (client *LROsClient) ResumePut200Succeeded(ctx context.Context, token string) (ProductPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("LROsClient.Put200Succeeded", token, client.put200SucceededHandleError)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	poller := &productPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	result := ProductPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// Put200Succeeded - Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Succeeded’.
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) put200Succeeded(ctx context.Context, options *LROsBeginPut200SucceededOptions) (*azcore.Response, error) {
	req, err := client.put200SucceededCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusNoContent) {
		return nil, client.put200SucceededHandleError(resp)
	}
	return resp, nil
}

// put200SucceededCreateRequest creates the Put200Succeeded request.
func (client *LROsClient) put200SucceededCreateRequest(ctx context.Context, options *LROsBeginPut200SucceededOptions) (*azcore.Request, error) {
	urlPath := "/lro/put/200/succeeded"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// put200SucceededHandleResponse handles the Put200Succeeded response.
func (client *LROsClient) put200SucceededHandleResponse(resp *azcore.Response) (ProductResponse, error) {
	var val *Product
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProductResponse{}, err
	}
	return ProductResponse{RawResponse: resp.Response, Product: val}, nil
}

// put200SucceededHandleError handles the Put200Succeeded error response.
func (client *LROsClient) put200SucceededHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginPut200SucceededNoState - Long running put request, service returns a 200 to the initial request, with an entity that does not contain ProvisioningState=’Succeeded’.
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) BeginPut200SucceededNoState(ctx context.Context, options *LROsBeginPut200SucceededNoStateOptions) (ProductPollerResponse, error) {
	resp, err := client.put200SucceededNoState(ctx, options)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	result := ProductPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LROsClient.Put200SucceededNoState", "", resp, client.put200SucceededNoStateHandleError)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	poller := &productPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumePut200SucceededNoState creates a new ProductPoller from the specified resume token.
// token - The value must come from a previous call to ProductPoller.ResumeToken().
func (client *LROsClient) ResumePut200SucceededNoState(ctx context.Context, token string) (ProductPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("LROsClient.Put200SucceededNoState", token, client.put200SucceededNoStateHandleError)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	poller := &productPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	result := ProductPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// Put200SucceededNoState - Long running put request, service returns a 200 to the initial request, with an entity that does not contain ProvisioningState=’Succeeded’.
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) put200SucceededNoState(ctx context.Context, options *LROsBeginPut200SucceededNoStateOptions) (*azcore.Response, error) {
	req, err := client.put200SucceededNoStateCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.put200SucceededNoStateHandleError(resp)
	}
	return resp, nil
}

// put200SucceededNoStateCreateRequest creates the Put200SucceededNoState request.
func (client *LROsClient) put200SucceededNoStateCreateRequest(ctx context.Context, options *LROsBeginPut200SucceededNoStateOptions) (*azcore.Request, error) {
	urlPath := "/lro/put/200/succeeded/nostate"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// put200SucceededNoStateHandleResponse handles the Put200SucceededNoState response.
func (client *LROsClient) put200SucceededNoStateHandleResponse(resp *azcore.Response) (ProductResponse, error) {
	var val *Product
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProductResponse{}, err
	}
	return ProductResponse{RawResponse: resp.Response, Product: val}, nil
}

// put200SucceededNoStateHandleError handles the Put200SucceededNoState error response.
func (client *LROsClient) put200SucceededNoStateHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginPut200UpdatingSucceeded204 - Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Updating’.
// Polls return this value until the last poll returns a ‘200’ with
// ProvisioningState=’Succeeded’
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) BeginPut200UpdatingSucceeded204(ctx context.Context, options *LROsBeginPut200UpdatingSucceeded204Options) (ProductPollerResponse, error) {
	resp, err := client.put200UpdatingSucceeded204(ctx, options)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	result := ProductPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LROsClient.Put200UpdatingSucceeded204", "", resp, client.put200UpdatingSucceeded204HandleError)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	poller := &productPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumePut200UpdatingSucceeded204 creates a new ProductPoller from the specified resume token.
// token - The value must come from a previous call to ProductPoller.ResumeToken().
func (client *LROsClient) ResumePut200UpdatingSucceeded204(ctx context.Context, token string) (ProductPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("LROsClient.Put200UpdatingSucceeded204", token, client.put200UpdatingSucceeded204HandleError)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	poller := &productPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	result := ProductPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// Put200UpdatingSucceeded204 - Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Updating’.
// Polls return this value until the last poll returns a ‘200’ with
// ProvisioningState=’Succeeded’
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) put200UpdatingSucceeded204(ctx context.Context, options *LROsBeginPut200UpdatingSucceeded204Options) (*azcore.Response, error) {
	req, err := client.put200UpdatingSucceeded204CreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.put200UpdatingSucceeded204HandleError(resp)
	}
	return resp, nil
}

// put200UpdatingSucceeded204CreateRequest creates the Put200UpdatingSucceeded204 request.
func (client *LROsClient) put200UpdatingSucceeded204CreateRequest(ctx context.Context, options *LROsBeginPut200UpdatingSucceeded204Options) (*azcore.Request, error) {
	urlPath := "/lro/put/200/updating/succeeded/200"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// put200UpdatingSucceeded204HandleResponse handles the Put200UpdatingSucceeded204 response.
func (client *LROsClient) put200UpdatingSucceeded204HandleResponse(resp *azcore.Response) (ProductResponse, error) {
	var val *Product
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProductResponse{}, err
	}
	return ProductResponse{RawResponse: resp.Response, Product: val}, nil
}

// put200UpdatingSucceeded204HandleError handles the Put200UpdatingSucceeded204 error response.
func (client *LROsClient) put200UpdatingSucceeded204HandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginPut201CreatingFailed200 - Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Created’.
// Polls return this value until the last poll returns a ‘200’ with
// ProvisioningState=’Failed’
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) BeginPut201CreatingFailed200(ctx context.Context, options *LROsBeginPut201CreatingFailed200Options) (ProductPollerResponse, error) {
	resp, err := client.put201CreatingFailed200(ctx, options)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	result := ProductPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LROsClient.Put201CreatingFailed200", "", resp, client.put201CreatingFailed200HandleError)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	poller := &productPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumePut201CreatingFailed200 creates a new ProductPoller from the specified resume token.
// token - The value must come from a previous call to ProductPoller.ResumeToken().
func (client *LROsClient) ResumePut201CreatingFailed200(ctx context.Context, token string) (ProductPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("LROsClient.Put201CreatingFailed200", token, client.put201CreatingFailed200HandleError)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	poller := &productPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	result := ProductPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// Put201CreatingFailed200 - Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Created’.
// Polls return this value until the last poll returns a ‘200’ with
// ProvisioningState=’Failed’
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) put201CreatingFailed200(ctx context.Context, options *LROsBeginPut201CreatingFailed200Options) (*azcore.Response, error) {
	req, err := client.put201CreatingFailed200CreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusCreated) {
		return nil, client.put201CreatingFailed200HandleError(resp)
	}
	return resp, nil
}

// put201CreatingFailed200CreateRequest creates the Put201CreatingFailed200 request.
func (client *LROsClient) put201CreatingFailed200CreateRequest(ctx context.Context, options *LROsBeginPut201CreatingFailed200Options) (*azcore.Request, error) {
	urlPath := "/lro/put/201/created/failed/200"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// put201CreatingFailed200HandleResponse handles the Put201CreatingFailed200 response.
func (client *LROsClient) put201CreatingFailed200HandleResponse(resp *azcore.Response) (ProductResponse, error) {
	var val *Product
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProductResponse{}, err
	}
	return ProductResponse{RawResponse: resp.Response, Product: val}, nil
}

// put201CreatingFailed200HandleError handles the Put201CreatingFailed200 error response.
func (client *LROsClient) put201CreatingFailed200HandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginPut201CreatingSucceeded200 - Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Creating’.
// Polls return this value until the last poll returns a ‘200’ with
// ProvisioningState=’Succeeded’
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) BeginPut201CreatingSucceeded200(ctx context.Context, options *LROsBeginPut201CreatingSucceeded200Options) (ProductPollerResponse, error) {
	resp, err := client.put201CreatingSucceeded200(ctx, options)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	result := ProductPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LROsClient.Put201CreatingSucceeded200", "", resp, client.put201CreatingSucceeded200HandleError)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	poller := &productPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumePut201CreatingSucceeded200 creates a new ProductPoller from the specified resume token.
// token - The value must come from a previous call to ProductPoller.ResumeToken().
func (client *LROsClient) ResumePut201CreatingSucceeded200(ctx context.Context, token string) (ProductPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("LROsClient.Put201CreatingSucceeded200", token, client.put201CreatingSucceeded200HandleError)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	poller := &productPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	result := ProductPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// Put201CreatingSucceeded200 - Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Creating’.
// Polls return this value until the last poll returns a ‘200’ with
// ProvisioningState=’Succeeded’
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) put201CreatingSucceeded200(ctx context.Context, options *LROsBeginPut201CreatingSucceeded200Options) (*azcore.Response, error) {
	req, err := client.put201CreatingSucceeded200CreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusCreated) {
		return nil, client.put201CreatingSucceeded200HandleError(resp)
	}
	return resp, nil
}

// put201CreatingSucceeded200CreateRequest creates the Put201CreatingSucceeded200 request.
func (client *LROsClient) put201CreatingSucceeded200CreateRequest(ctx context.Context, options *LROsBeginPut201CreatingSucceeded200Options) (*azcore.Request, error) {
	urlPath := "/lro/put/201/creating/succeeded/200"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// put201CreatingSucceeded200HandleResponse handles the Put201CreatingSucceeded200 response.
func (client *LROsClient) put201CreatingSucceeded200HandleResponse(resp *azcore.Response) (ProductResponse, error) {
	var val *Product
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProductResponse{}, err
	}
	return ProductResponse{RawResponse: resp.Response, Product: val}, nil
}

// put201CreatingSucceeded200HandleError handles the Put201CreatingSucceeded200 error response.
func (client *LROsClient) put201CreatingSucceeded200HandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginPut201Succeeded - Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Succeeded’.
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) BeginPut201Succeeded(ctx context.Context, options *LROsBeginPut201SucceededOptions) (ProductPollerResponse, error) {
	resp, err := client.put201Succeeded(ctx, options)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	result := ProductPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LROsClient.Put201Succeeded", "", resp, client.put201SucceededHandleError)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	poller := &productPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumePut201Succeeded creates a new ProductPoller from the specified resume token.
// token - The value must come from a previous call to ProductPoller.ResumeToken().
func (client *LROsClient) ResumePut201Succeeded(ctx context.Context, token string) (ProductPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("LROsClient.Put201Succeeded", token, client.put201SucceededHandleError)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	poller := &productPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	result := ProductPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// Put201Succeeded - Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Succeeded’.
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) put201Succeeded(ctx context.Context, options *LROsBeginPut201SucceededOptions) (*azcore.Response, error) {
	req, err := client.put201SucceededCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, client.put201SucceededHandleError(resp)
	}
	return resp, nil
}

// put201SucceededCreateRequest creates the Put201Succeeded request.
func (client *LROsClient) put201SucceededCreateRequest(ctx context.Context, options *LROsBeginPut201SucceededOptions) (*azcore.Request, error) {
	urlPath := "/lro/put/201/succeeded"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// put201SucceededHandleResponse handles the Put201Succeeded response.
func (client *LROsClient) put201SucceededHandleResponse(resp *azcore.Response) (ProductResponse, error) {
	var val *Product
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProductResponse{}, err
	}
	return ProductResponse{RawResponse: resp.Response, Product: val}, nil
}

// put201SucceededHandleError handles the Put201Succeeded error response.
func (client *LROsClient) put201SucceededHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginPut202Retry200 - Long running put request, service returns a 202 to the initial request, with a location header that points to a polling URL that
// returns a 200 and an entity that doesn't contains ProvisioningState
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) BeginPut202Retry200(ctx context.Context, options *LROsBeginPut202Retry200Options) (ProductPollerResponse, error) {
	resp, err := client.put202Retry200(ctx, options)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	result := ProductPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LROsClient.Put202Retry200", "", resp, client.put202Retry200HandleError)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	poller := &productPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumePut202Retry200 creates a new ProductPoller from the specified resume token.
// token - The value must come from a previous call to ProductPoller.ResumeToken().
func (client *LROsClient) ResumePut202Retry200(ctx context.Context, token string) (ProductPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("LROsClient.Put202Retry200", token, client.put202Retry200HandleError)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	poller := &productPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	result := ProductPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// Put202Retry200 - Long running put request, service returns a 202 to the initial request, with a location header that points to a polling URL that returns
// a 200 and an entity that doesn't contains ProvisioningState
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) put202Retry200(ctx context.Context, options *LROsBeginPut202Retry200Options) (*azcore.Response, error) {
	req, err := client.put202Retry200CreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, client.put202Retry200HandleError(resp)
	}
	return resp, nil
}

// put202Retry200CreateRequest creates the Put202Retry200 request.
func (client *LROsClient) put202Retry200CreateRequest(ctx context.Context, options *LROsBeginPut202Retry200Options) (*azcore.Request, error) {
	urlPath := "/lro/put/202/retry/200"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// put202Retry200HandleResponse handles the Put202Retry200 response.
func (client *LROsClient) put202Retry200HandleResponse(resp *azcore.Response) (ProductResponse, error) {
	var val *Product
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProductResponse{}, err
	}
	return ProductResponse{RawResponse: resp.Response, Product: val}, nil
}

// put202Retry200HandleError handles the Put202Retry200 error response.
func (client *LROsClient) put202Retry200HandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginPutAsyncNoHeaderInRetry - Long running put request, service returns a 202 to the initial request with Azure-AsyncOperation header. Subsequent calls
// to operation status do not contain Azure-AsyncOperation header.
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) BeginPutAsyncNoHeaderInRetry(ctx context.Context, options *LROsBeginPutAsyncNoHeaderInRetryOptions) (ProductPollerResponse, error) {
	resp, err := client.putAsyncNoHeaderInRetry(ctx, options)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	result := ProductPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LROsClient.PutAsyncNoHeaderInRetry", "", resp, client.putAsyncNoHeaderInRetryHandleError)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	poller := &productPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumePutAsyncNoHeaderInRetry creates a new ProductPoller from the specified resume token.
// token - The value must come from a previous call to ProductPoller.ResumeToken().
func (client *LROsClient) ResumePutAsyncNoHeaderInRetry(ctx context.Context, token string) (ProductPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("LROsClient.PutAsyncNoHeaderInRetry", token, client.putAsyncNoHeaderInRetryHandleError)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	poller := &productPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	result := ProductPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// PutAsyncNoHeaderInRetry - Long running put request, service returns a 202 to the initial request with Azure-AsyncOperation header. Subsequent calls to
// operation status do not contain Azure-AsyncOperation header.
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) putAsyncNoHeaderInRetry(ctx context.Context, options *LROsBeginPutAsyncNoHeaderInRetryOptions) (*azcore.Response, error) {
	req, err := client.putAsyncNoHeaderInRetryCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, client.putAsyncNoHeaderInRetryHandleError(resp)
	}
	return resp, nil
}

// putAsyncNoHeaderInRetryCreateRequest creates the PutAsyncNoHeaderInRetry request.
func (client *LROsClient) putAsyncNoHeaderInRetryCreateRequest(ctx context.Context, options *LROsBeginPutAsyncNoHeaderInRetryOptions) (*azcore.Request, error) {
	urlPath := "/lro/putasync/noheader/201/200"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// putAsyncNoHeaderInRetryHandleResponse handles the PutAsyncNoHeaderInRetry response.
func (client *LROsClient) putAsyncNoHeaderInRetryHandleResponse(resp *azcore.Response) (ProductResponse, error) {
	var val *Product
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProductResponse{}, err
	}
	return ProductResponse{RawResponse: resp.Response, Product: val}, nil
}

// putAsyncNoHeaderInRetryHandleError handles the PutAsyncNoHeaderInRetry error response.
func (client *LROsClient) putAsyncNoHeaderInRetryHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginPutAsyncNoRetrySucceeded - Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’.
// Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) BeginPutAsyncNoRetrySucceeded(ctx context.Context, options *LROsBeginPutAsyncNoRetrySucceededOptions) (ProductPollerResponse, error) {
	resp, err := client.putAsyncNoRetrySucceeded(ctx, options)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	result := ProductPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LROsClient.PutAsyncNoRetrySucceeded", "", resp, client.putAsyncNoRetrySucceededHandleError)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	poller := &productPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumePutAsyncNoRetrySucceeded creates a new ProductPoller from the specified resume token.
// token - The value must come from a previous call to ProductPoller.ResumeToken().
func (client *LROsClient) ResumePutAsyncNoRetrySucceeded(ctx context.Context, token string) (ProductPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("LROsClient.PutAsyncNoRetrySucceeded", token, client.putAsyncNoRetrySucceededHandleError)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	poller := &productPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	result := ProductPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// PutAsyncNoRetrySucceeded - Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’.
// Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) putAsyncNoRetrySucceeded(ctx context.Context, options *LROsBeginPutAsyncNoRetrySucceededOptions) (*azcore.Response, error) {
	req, err := client.putAsyncNoRetrySucceededCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.putAsyncNoRetrySucceededHandleError(resp)
	}
	return resp, nil
}

// putAsyncNoRetrySucceededCreateRequest creates the PutAsyncNoRetrySucceeded request.
func (client *LROsClient) putAsyncNoRetrySucceededCreateRequest(ctx context.Context, options *LROsBeginPutAsyncNoRetrySucceededOptions) (*azcore.Request, error) {
	urlPath := "/lro/putasync/noretry/succeeded"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// putAsyncNoRetrySucceededHandleResponse handles the PutAsyncNoRetrySucceeded response.
func (client *LROsClient) putAsyncNoRetrySucceededHandleResponse(resp *azcore.Response) (ProductResponse, error) {
	var val *Product
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProductResponse{}, err
	}
	return ProductResponse{RawResponse: resp.Response, Product: val}, nil
}

// putAsyncNoRetrySucceededHandleError handles the PutAsyncNoRetrySucceeded error response.
func (client *LROsClient) putAsyncNoRetrySucceededHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginPutAsyncNoRetrycanceled - Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’.
// Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) BeginPutAsyncNoRetrycanceled(ctx context.Context, options *LROsBeginPutAsyncNoRetrycanceledOptions) (ProductPollerResponse, error) {
	resp, err := client.putAsyncNoRetrycanceled(ctx, options)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	result := ProductPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LROsClient.PutAsyncNoRetrycanceled", "", resp, client.putAsyncNoRetrycanceledHandleError)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	poller := &productPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumePutAsyncNoRetrycanceled creates a new ProductPoller from the specified resume token.
// token - The value must come from a previous call to ProductPoller.ResumeToken().
func (client *LROsClient) ResumePutAsyncNoRetrycanceled(ctx context.Context, token string) (ProductPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("LROsClient.PutAsyncNoRetrycanceled", token, client.putAsyncNoRetrycanceledHandleError)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	poller := &productPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	result := ProductPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// PutAsyncNoRetrycanceled - Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’.
// Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) putAsyncNoRetrycanceled(ctx context.Context, options *LROsBeginPutAsyncNoRetrycanceledOptions) (*azcore.Response, error) {
	req, err := client.putAsyncNoRetrycanceledCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.putAsyncNoRetrycanceledHandleError(resp)
	}
	return resp, nil
}

// putAsyncNoRetrycanceledCreateRequest creates the PutAsyncNoRetrycanceled request.
func (client *LROsClient) putAsyncNoRetrycanceledCreateRequest(ctx context.Context, options *LROsBeginPutAsyncNoRetrycanceledOptions) (*azcore.Request, error) {
	urlPath := "/lro/putasync/noretry/canceled"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// putAsyncNoRetrycanceledHandleResponse handles the PutAsyncNoRetrycanceled response.
func (client *LROsClient) putAsyncNoRetrycanceledHandleResponse(resp *azcore.Response) (ProductResponse, error) {
	var val *Product
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProductResponse{}, err
	}
	return ProductResponse{RawResponse: resp.Response, Product: val}, nil
}

// putAsyncNoRetrycanceledHandleError handles the PutAsyncNoRetrycanceled error response.
func (client *LROsClient) putAsyncNoRetrycanceledHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginPutAsyncNonResource - Long running put request with non resource.
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) BeginPutAsyncNonResource(ctx context.Context, options *LROsBeginPutAsyncNonResourceOptions) (SKUPollerResponse, error) {
	resp, err := client.putAsyncNonResource(ctx, options)
	if err != nil {
		return SKUPollerResponse{}, err
	}
	result := SKUPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LROsClient.PutAsyncNonResource", "", resp, client.putAsyncNonResourceHandleError)
	if err != nil {
		return SKUPollerResponse{}, err
	}
	poller := &skuPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (SKUResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumePutAsyncNonResource creates a new SKUPoller from the specified resume token.
// token - The value must come from a previous call to SKUPoller.ResumeToken().
func (client *LROsClient) ResumePutAsyncNonResource(ctx context.Context, token string) (SKUPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("LROsClient.PutAsyncNonResource", token, client.putAsyncNonResourceHandleError)
	if err != nil {
		return SKUPollerResponse{}, err
	}
	poller := &skuPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return SKUPollerResponse{}, err
	}
	result := SKUPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (SKUResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// PutAsyncNonResource - Long running put request with non resource.
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) putAsyncNonResource(ctx context.Context, options *LROsBeginPutAsyncNonResourceOptions) (*azcore.Response, error) {
	req, err := client.putAsyncNonResourceCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, client.putAsyncNonResourceHandleError(resp)
	}
	return resp, nil
}

// putAsyncNonResourceCreateRequest creates the PutAsyncNonResource request.
func (client *LROsClient) putAsyncNonResourceCreateRequest(ctx context.Context, options *LROsBeginPutAsyncNonResourceOptions) (*azcore.Request, error) {
	urlPath := "/lro/putnonresourceasync/202/200"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	if options != nil && options.SKU != nil {
		return req, req.MarshalAsJSON(options.SKU)
	}
	return req, nil
}

// putAsyncNonResourceHandleResponse handles the PutAsyncNonResource response.
func (client *LROsClient) putAsyncNonResourceHandleResponse(resp *azcore.Response) (SKUResponse, error) {
	var val *SKU
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SKUResponse{}, err
	}
	return SKUResponse{RawResponse: resp.Response, SKU: val}, nil
}

// putAsyncNonResourceHandleError handles the PutAsyncNonResource error response.
func (client *LROsClient) putAsyncNonResourceHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginPutAsyncRetryFailed - Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’.
// Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) BeginPutAsyncRetryFailed(ctx context.Context, options *LROsBeginPutAsyncRetryFailedOptions) (ProductPollerResponse, error) {
	resp, err := client.putAsyncRetryFailed(ctx, options)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	result := ProductPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LROsClient.PutAsyncRetryFailed", "", resp, client.putAsyncRetryFailedHandleError)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	poller := &productPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumePutAsyncRetryFailed creates a new ProductPoller from the specified resume token.
// token - The value must come from a previous call to ProductPoller.ResumeToken().
func (client *LROsClient) ResumePutAsyncRetryFailed(ctx context.Context, token string) (ProductPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("LROsClient.PutAsyncRetryFailed", token, client.putAsyncRetryFailedHandleError)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	poller := &productPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	result := ProductPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// PutAsyncRetryFailed - Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’.
// Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) putAsyncRetryFailed(ctx context.Context, options *LROsBeginPutAsyncRetryFailedOptions) (*azcore.Response, error) {
	req, err := client.putAsyncRetryFailedCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.putAsyncRetryFailedHandleError(resp)
	}
	return resp, nil
}

// putAsyncRetryFailedCreateRequest creates the PutAsyncRetryFailed request.
func (client *LROsClient) putAsyncRetryFailedCreateRequest(ctx context.Context, options *LROsBeginPutAsyncRetryFailedOptions) (*azcore.Request, error) {
	urlPath := "/lro/putasync/retry/failed"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// putAsyncRetryFailedHandleResponse handles the PutAsyncRetryFailed response.
func (client *LROsClient) putAsyncRetryFailedHandleResponse(resp *azcore.Response) (ProductResponse, error) {
	var val *Product
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProductResponse{}, err
	}
	return ProductResponse{RawResponse: resp.Response, Product: val}, nil
}

// putAsyncRetryFailedHandleError handles the PutAsyncRetryFailed error response.
func (client *LROsClient) putAsyncRetryFailedHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginPutAsyncRetrySucceeded - Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’.
// Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) BeginPutAsyncRetrySucceeded(ctx context.Context, options *LROsBeginPutAsyncRetrySucceededOptions) (ProductPollerResponse, error) {
	resp, err := client.putAsyncRetrySucceeded(ctx, options)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	result := ProductPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LROsClient.PutAsyncRetrySucceeded", "", resp, client.putAsyncRetrySucceededHandleError)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	poller := &productPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumePutAsyncRetrySucceeded creates a new ProductPoller from the specified resume token.
// token - The value must come from a previous call to ProductPoller.ResumeToken().
func (client *LROsClient) ResumePutAsyncRetrySucceeded(ctx context.Context, token string) (ProductPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("LROsClient.PutAsyncRetrySucceeded", token, client.putAsyncRetrySucceededHandleError)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	poller := &productPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	result := ProductPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// PutAsyncRetrySucceeded - Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’.
// Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) putAsyncRetrySucceeded(ctx context.Context, options *LROsBeginPutAsyncRetrySucceededOptions) (*azcore.Response, error) {
	req, err := client.putAsyncRetrySucceededCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.putAsyncRetrySucceededHandleError(resp)
	}
	return resp, nil
}

// putAsyncRetrySucceededCreateRequest creates the PutAsyncRetrySucceeded request.
func (client *LROsClient) putAsyncRetrySucceededCreateRequest(ctx context.Context, options *LROsBeginPutAsyncRetrySucceededOptions) (*azcore.Request, error) {
	urlPath := "/lro/putasync/retry/succeeded"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// putAsyncRetrySucceededHandleResponse handles the PutAsyncRetrySucceeded response.
func (client *LROsClient) putAsyncRetrySucceededHandleResponse(resp *azcore.Response) (ProductResponse, error) {
	var val *Product
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProductResponse{}, err
	}
	return ProductResponse{RawResponse: resp.Response, Product: val}, nil
}

// putAsyncRetrySucceededHandleError handles the PutAsyncRetrySucceeded error response.
func (client *LROsClient) putAsyncRetrySucceededHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginPutAsyncSubResource - Long running put request with sub resource.
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) BeginPutAsyncSubResource(ctx context.Context, options *LROsBeginPutAsyncSubResourceOptions) (SubProductPollerResponse, error) {
	resp, err := client.putAsyncSubResource(ctx, options)
	if err != nil {
		return SubProductPollerResponse{}, err
	}
	result := SubProductPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LROsClient.PutAsyncSubResource", "", resp, client.putAsyncSubResourceHandleError)
	if err != nil {
		return SubProductPollerResponse{}, err
	}
	poller := &subProductPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (SubProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumePutAsyncSubResource creates a new SubProductPoller from the specified resume token.
// token - The value must come from a previous call to SubProductPoller.ResumeToken().
func (client *LROsClient) ResumePutAsyncSubResource(ctx context.Context, token string) (SubProductPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("LROsClient.PutAsyncSubResource", token, client.putAsyncSubResourceHandleError)
	if err != nil {
		return SubProductPollerResponse{}, err
	}
	poller := &subProductPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return SubProductPollerResponse{}, err
	}
	result := SubProductPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (SubProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// PutAsyncSubResource - Long running put request with sub resource.
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) putAsyncSubResource(ctx context.Context, options *LROsBeginPutAsyncSubResourceOptions) (*azcore.Response, error) {
	req, err := client.putAsyncSubResourceCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, client.putAsyncSubResourceHandleError(resp)
	}
	return resp, nil
}

// putAsyncSubResourceCreateRequest creates the PutAsyncSubResource request.
func (client *LROsClient) putAsyncSubResourceCreateRequest(ctx context.Context, options *LROsBeginPutAsyncSubResourceOptions) (*azcore.Request, error) {
	urlPath := "/lro/putsubresourceasync/202/200"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// putAsyncSubResourceHandleResponse handles the PutAsyncSubResource response.
func (client *LROsClient) putAsyncSubResourceHandleResponse(resp *azcore.Response) (SubProductResponse, error) {
	var val *SubProduct
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SubProductResponse{}, err
	}
	return SubProductResponse{RawResponse: resp.Response, SubProduct: val}, nil
}

// putAsyncSubResourceHandleError handles the PutAsyncSubResource error response.
func (client *LROsClient) putAsyncSubResourceHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginPutNoHeaderInRetry - Long running put request, service returns a 202 to the initial request with location header. Subsequent calls to operation
// status do not contain location header.
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) BeginPutNoHeaderInRetry(ctx context.Context, options *LROsBeginPutNoHeaderInRetryOptions) (ProductPollerResponse, error) {
	resp, err := client.putNoHeaderInRetry(ctx, options)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	result := ProductPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LROsClient.PutNoHeaderInRetry", "", resp, client.putNoHeaderInRetryHandleError)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	poller := &productPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumePutNoHeaderInRetry creates a new ProductPoller from the specified resume token.
// token - The value must come from a previous call to ProductPoller.ResumeToken().
func (client *LROsClient) ResumePutNoHeaderInRetry(ctx context.Context, token string) (ProductPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("LROsClient.PutNoHeaderInRetry", token, client.putNoHeaderInRetryHandleError)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	poller := &productPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return ProductPollerResponse{}, err
	}
	result := ProductPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// PutNoHeaderInRetry - Long running put request, service returns a 202 to the initial request with location header. Subsequent calls to operation status
// do not contain location header.
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) putNoHeaderInRetry(ctx context.Context, options *LROsBeginPutNoHeaderInRetryOptions) (*azcore.Response, error) {
	req, err := client.putNoHeaderInRetryCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, client.putNoHeaderInRetryHandleError(resp)
	}
	return resp, nil
}

// putNoHeaderInRetryCreateRequest creates the PutNoHeaderInRetry request.
func (client *LROsClient) putNoHeaderInRetryCreateRequest(ctx context.Context, options *LROsBeginPutNoHeaderInRetryOptions) (*azcore.Request, error) {
	urlPath := "/lro/put/noheader/202/200"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// putNoHeaderInRetryHandleResponse handles the PutNoHeaderInRetry response.
func (client *LROsClient) putNoHeaderInRetryHandleResponse(resp *azcore.Response) (ProductResponse, error) {
	var val *Product
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProductResponse{}, err
	}
	return ProductResponse{RawResponse: resp.Response, Product: val}, nil
}

// putNoHeaderInRetryHandleError handles the PutNoHeaderInRetry error response.
func (client *LROsClient) putNoHeaderInRetryHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginPutNonResource - Long running put request with non resource.
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) BeginPutNonResource(ctx context.Context, options *LROsBeginPutNonResourceOptions) (SKUPollerResponse, error) {
	resp, err := client.putNonResource(ctx, options)
	if err != nil {
		return SKUPollerResponse{}, err
	}
	result := SKUPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LROsClient.PutNonResource", "", resp, client.putNonResourceHandleError)
	if err != nil {
		return SKUPollerResponse{}, err
	}
	poller := &skuPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (SKUResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumePutNonResource creates a new SKUPoller from the specified resume token.
// token - The value must come from a previous call to SKUPoller.ResumeToken().
func (client *LROsClient) ResumePutNonResource(ctx context.Context, token string) (SKUPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("LROsClient.PutNonResource", token, client.putNonResourceHandleError)
	if err != nil {
		return SKUPollerResponse{}, err
	}
	poller := &skuPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return SKUPollerResponse{}, err
	}
	result := SKUPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (SKUResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// PutNonResource - Long running put request with non resource.
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) putNonResource(ctx context.Context, options *LROsBeginPutNonResourceOptions) (*azcore.Response, error) {
	req, err := client.putNonResourceCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, client.putNonResourceHandleError(resp)
	}
	return resp, nil
}

// putNonResourceCreateRequest creates the PutNonResource request.
func (client *LROsClient) putNonResourceCreateRequest(ctx context.Context, options *LROsBeginPutNonResourceOptions) (*azcore.Request, error) {
	urlPath := "/lro/putnonresource/202/200"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	if options != nil && options.SKU != nil {
		return req, req.MarshalAsJSON(options.SKU)
	}
	return req, nil
}

// putNonResourceHandleResponse handles the PutNonResource response.
func (client *LROsClient) putNonResourceHandleResponse(resp *azcore.Response) (SKUResponse, error) {
	var val *SKU
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SKUResponse{}, err
	}
	return SKUResponse{RawResponse: resp.Response, SKU: val}, nil
}

// putNonResourceHandleError handles the PutNonResource error response.
func (client *LROsClient) putNonResourceHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginPutSubResource - Long running put request with sub resource.
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) BeginPutSubResource(ctx context.Context, options *LROsBeginPutSubResourceOptions) (SubProductPollerResponse, error) {
	resp, err := client.putSubResource(ctx, options)
	if err != nil {
		return SubProductPollerResponse{}, err
	}
	result := SubProductPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LROsClient.PutSubResource", "", resp, client.putSubResourceHandleError)
	if err != nil {
		return SubProductPollerResponse{}, err
	}
	poller := &subProductPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (SubProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumePutSubResource creates a new SubProductPoller from the specified resume token.
// token - The value must come from a previous call to SubProductPoller.ResumeToken().
func (client *LROsClient) ResumePutSubResource(ctx context.Context, token string) (SubProductPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("LROsClient.PutSubResource", token, client.putSubResourceHandleError)
	if err != nil {
		return SubProductPollerResponse{}, err
	}
	poller := &subProductPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return SubProductPollerResponse{}, err
	}
	result := SubProductPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (SubProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// PutSubResource - Long running put request with sub resource.
// If the operation fails it returns the *CloudError error type.
func (client *LROsClient) putSubResource(ctx context.Context, options *LROsBeginPutSubResourceOptions) (*azcore.Response, error) {
	req, err := client.putSubResourceCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, client.putSubResourceHandleError(resp)
	}
	return resp, nil
}

// putSubResourceCreateRequest creates the PutSubResource request.
func (client *LROsClient) putSubResourceCreateRequest(ctx context.Context, options *LROsBeginPutSubResourceOptions) (*azcore.Request, error) {
	urlPath := "/lro/putsubresource/202/200"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// putSubResourceHandleResponse handles the PutSubResource response.
func (client *LROsClient) putSubResourceHandleResponse(resp *azcore.Response) (SubProductResponse, error) {
	var val *SubProduct
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SubProductResponse{}, err
	}
	return SubProductResponse{RawResponse: resp.Response, SubProduct: val}, nil
}

// putSubResourceHandleError handles the PutSubResource error response.
func (client *LROsClient) putSubResourceHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}
