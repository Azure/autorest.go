//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package lrogroup

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
)

// LROsClient contains the methods for the LROs group.
// Don't use this type directly, use NewLROsClient() instead.
type LROsClient struct {
	pl runtime.Pipeline
}

// NewLROsClient creates a new instance of LROsClient with the specified values.
// options - pass nil to accept the default values.
func NewLROsClient(options *azcore.ClientOptions) *LROsClient {
	if options == nil {
		options = &azcore.ClientOptions{}
	}
	client := &LROsClient{
		pl: runtime.NewPipeline(moduleName, moduleVersion, runtime.PipelineOptions{}, options),
	}
	return client
}

// BeginDelete202NoRetry204 - Long running delete request, service returns a 202 to the initial request. Polls return this
// value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROsClientBeginDelete202NoRetry204Options contains the optional parameters for the LROsClient.BeginDelete202NoRetry204
// method.
func (client *LROsClient) BeginDelete202NoRetry204(ctx context.Context, options *LROsClientBeginDelete202NoRetry204Options) (*LROsClientDelete202NoRetry204Poller, error) {
	resp, err := client.delete202NoRetry204(ctx, options)
	if err != nil {
		return nil, err
	}
	pt, err := armruntime.NewPoller("LROsClient.Delete202NoRetry204", "", resp, client.pl)
	if err != nil {
		return nil, err
	}
	return &LROsClientDelete202NoRetry204Poller{pt: pt}, nil
}

// Delete202NoRetry204 - Long running delete request, service returns a 202 to the initial request. Polls return this value
// until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROsClient) delete202NoRetry204(ctx context.Context, options *LROsClientBeginDelete202NoRetry204Options) (*http.Response, error) {
	req, err := client.delete202NoRetry204CreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// delete202NoRetry204CreateRequest creates the Delete202NoRetry204 request.
func (client *LROsClient) delete202NoRetry204CreateRequest(ctx context.Context, options *LROsClientBeginDelete202NoRetry204Options) (*policy.Request, error) {
	urlPath := "/lro/delete/202/noretry/204"
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// BeginDelete202Retry200 - Long running delete request, service returns a 202 to the initial request. Polls return this value
// until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROsClientBeginDelete202Retry200Options contains the optional parameters for the LROsClient.BeginDelete202Retry200
// method.
func (client *LROsClient) BeginDelete202Retry200(ctx context.Context, options *LROsClientBeginDelete202Retry200Options) (*LROsClientDelete202Retry200Poller, error) {
	resp, err := client.delete202Retry200(ctx, options)
	if err != nil {
		return nil, err
	}
	pt, err := armruntime.NewPoller("LROsClient.Delete202Retry200", "", resp, client.pl)
	if err != nil {
		return nil, err
	}
	return &LROsClientDelete202Retry200Poller{pt: pt}, nil
}

// Delete202Retry200 - Long running delete request, service returns a 202 to the initial request. Polls return this value
// until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROsClient) delete202Retry200(ctx context.Context, options *LROsClientBeginDelete202Retry200Options) (*http.Response, error) {
	req, err := client.delete202Retry200CreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// delete202Retry200CreateRequest creates the Delete202Retry200 request.
func (client *LROsClient) delete202Retry200CreateRequest(ctx context.Context, options *LROsClientBeginDelete202Retry200Options) (*policy.Request, error) {
	urlPath := "/lro/delete/202/retry/200"
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// BeginDelete204Succeeded - Long running delete succeeds and returns right away
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROsClientBeginDelete204SucceededOptions contains the optional parameters for the LROsClient.BeginDelete204Succeeded
// method.
func (client *LROsClient) BeginDelete204Succeeded(ctx context.Context, options *LROsClientBeginDelete204SucceededOptions) (*LROsClientDelete204SucceededPoller, error) {
	resp, err := client.delete204Succeeded(ctx, options)
	if err != nil {
		return nil, err
	}
	pt, err := armruntime.NewPoller("LROsClient.Delete204Succeeded", "", resp, client.pl)
	if err != nil {
		return nil, err
	}
	return &LROsClientDelete204SucceededPoller{pt: pt}, nil
}

// Delete204Succeeded - Long running delete succeeds and returns right away
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROsClient) delete204Succeeded(ctx context.Context, options *LROsClientBeginDelete204SucceededOptions) (*http.Response, error) {
	req, err := client.delete204SucceededCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// delete204SucceededCreateRequest creates the Delete204Succeeded request.
func (client *LROsClient) delete204SucceededCreateRequest(ctx context.Context, options *LROsClientBeginDelete204SucceededOptions) (*policy.Request, error) {
	urlPath := "/lro/delete/204/succeeded"
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// BeginDeleteAsyncNoHeaderInRetry - Long running delete request, service returns an Azure-AsyncOperation header in the initial
// request. Subsequent calls to operation status do not contain Azure-AsyncOperation header.
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROsClientBeginDeleteAsyncNoHeaderInRetryOptions contains the optional parameters for the LROsClient.BeginDeleteAsyncNoHeaderInRetry
// method.
func (client *LROsClient) BeginDeleteAsyncNoHeaderInRetry(ctx context.Context, options *LROsClientBeginDeleteAsyncNoHeaderInRetryOptions) (*LROsClientDeleteAsyncNoHeaderInRetryPoller, error) {
	resp, err := client.deleteAsyncNoHeaderInRetry(ctx, options)
	if err != nil {
		return nil, err
	}
	pt, err := armruntime.NewPoller("LROsClient.DeleteAsyncNoHeaderInRetry", "", resp, client.pl)
	if err != nil {
		return nil, err
	}
	return &LROsClientDeleteAsyncNoHeaderInRetryPoller{pt: pt}, nil
}

// DeleteAsyncNoHeaderInRetry - Long running delete request, service returns an Azure-AsyncOperation header in the initial
// request. Subsequent calls to operation status do not contain Azure-AsyncOperation header.
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROsClient) deleteAsyncNoHeaderInRetry(ctx context.Context, options *LROsClientBeginDeleteAsyncNoHeaderInRetryOptions) (*http.Response, error) {
	req, err := client.deleteAsyncNoHeaderInRetryCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted, http.StatusNoContent) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// deleteAsyncNoHeaderInRetryCreateRequest creates the DeleteAsyncNoHeaderInRetry request.
func (client *LROsClient) deleteAsyncNoHeaderInRetryCreateRequest(ctx context.Context, options *LROsClientBeginDeleteAsyncNoHeaderInRetryOptions) (*policy.Request, error) {
	urlPath := "/lro/deleteasync/noheader/202/204"
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// BeginDeleteAsyncNoRetrySucceeded - Long running delete request, service returns a 202 to the initial request. Poll the
// endpoint indicated in the Azure-AsyncOperation header for operation status
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROsClientBeginDeleteAsyncNoRetrySucceededOptions contains the optional parameters for the LROsClient.BeginDeleteAsyncNoRetrySucceeded
// method.
func (client *LROsClient) BeginDeleteAsyncNoRetrySucceeded(ctx context.Context, options *LROsClientBeginDeleteAsyncNoRetrySucceededOptions) (*LROsClientDeleteAsyncNoRetrySucceededPoller, error) {
	resp, err := client.deleteAsyncNoRetrySucceeded(ctx, options)
	if err != nil {
		return nil, err
	}
	pt, err := armruntime.NewPoller("LROsClient.DeleteAsyncNoRetrySucceeded", "", resp, client.pl)
	if err != nil {
		return nil, err
	}
	return &LROsClientDeleteAsyncNoRetrySucceededPoller{pt: pt}, nil
}

// DeleteAsyncNoRetrySucceeded - Long running delete request, service returns a 202 to the initial request. Poll the endpoint
// indicated in the Azure-AsyncOperation header for operation status
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROsClient) deleteAsyncNoRetrySucceeded(ctx context.Context, options *LROsClientBeginDeleteAsyncNoRetrySucceededOptions) (*http.Response, error) {
	req, err := client.deleteAsyncNoRetrySucceededCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// deleteAsyncNoRetrySucceededCreateRequest creates the DeleteAsyncNoRetrySucceeded request.
func (client *LROsClient) deleteAsyncNoRetrySucceededCreateRequest(ctx context.Context, options *LROsClientBeginDeleteAsyncNoRetrySucceededOptions) (*policy.Request, error) {
	urlPath := "/lro/deleteasync/noretry/succeeded"
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// BeginDeleteAsyncRetryFailed - Long running delete request, service returns a 202 to the initial request. Poll the endpoint
// indicated in the Azure-AsyncOperation header for operation status
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROsClientBeginDeleteAsyncRetryFailedOptions contains the optional parameters for the LROsClient.BeginDeleteAsyncRetryFailed
// method.
func (client *LROsClient) BeginDeleteAsyncRetryFailed(ctx context.Context, options *LROsClientBeginDeleteAsyncRetryFailedOptions) (*LROsClientDeleteAsyncRetryFailedPoller, error) {
	resp, err := client.deleteAsyncRetryFailed(ctx, options)
	if err != nil {
		return nil, err
	}
	pt, err := armruntime.NewPoller("LROsClient.DeleteAsyncRetryFailed", "", resp, client.pl)
	if err != nil {
		return nil, err
	}
	return &LROsClientDeleteAsyncRetryFailedPoller{pt: pt}, nil
}

// DeleteAsyncRetryFailed - Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated
// in the Azure-AsyncOperation header for operation status
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROsClient) deleteAsyncRetryFailed(ctx context.Context, options *LROsClientBeginDeleteAsyncRetryFailedOptions) (*http.Response, error) {
	req, err := client.deleteAsyncRetryFailedCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// deleteAsyncRetryFailedCreateRequest creates the DeleteAsyncRetryFailed request.
func (client *LROsClient) deleteAsyncRetryFailedCreateRequest(ctx context.Context, options *LROsClientBeginDeleteAsyncRetryFailedOptions) (*policy.Request, error) {
	urlPath := "/lro/deleteasync/retry/failed"
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// BeginDeleteAsyncRetrySucceeded - Long running delete request, service returns a 202 to the initial request. Poll the endpoint
// indicated in the Azure-AsyncOperation header for operation status
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROsClientBeginDeleteAsyncRetrySucceededOptions contains the optional parameters for the LROsClient.BeginDeleteAsyncRetrySucceeded
// method.
func (client *LROsClient) BeginDeleteAsyncRetrySucceeded(ctx context.Context, options *LROsClientBeginDeleteAsyncRetrySucceededOptions) (*LROsClientDeleteAsyncRetrySucceededPoller, error) {
	resp, err := client.deleteAsyncRetrySucceeded(ctx, options)
	if err != nil {
		return nil, err
	}
	pt, err := armruntime.NewPoller("LROsClient.DeleteAsyncRetrySucceeded", "", resp, client.pl)
	if err != nil {
		return nil, err
	}
	return &LROsClientDeleteAsyncRetrySucceededPoller{pt: pt}, nil
}

// DeleteAsyncRetrySucceeded - Long running delete request, service returns a 202 to the initial request. Poll the endpoint
// indicated in the Azure-AsyncOperation header for operation status
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROsClient) deleteAsyncRetrySucceeded(ctx context.Context, options *LROsClientBeginDeleteAsyncRetrySucceededOptions) (*http.Response, error) {
	req, err := client.deleteAsyncRetrySucceededCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// deleteAsyncRetrySucceededCreateRequest creates the DeleteAsyncRetrySucceeded request.
func (client *LROsClient) deleteAsyncRetrySucceededCreateRequest(ctx context.Context, options *LROsClientBeginDeleteAsyncRetrySucceededOptions) (*policy.Request, error) {
	urlPath := "/lro/deleteasync/retry/succeeded"
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// BeginDeleteAsyncRetrycanceled - Long running delete request, service returns a 202 to the initial request. Poll the endpoint
// indicated in the Azure-AsyncOperation header for operation status
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROsClientBeginDeleteAsyncRetrycanceledOptions contains the optional parameters for the LROsClient.BeginDeleteAsyncRetrycanceled
// method.
func (client *LROsClient) BeginDeleteAsyncRetrycanceled(ctx context.Context, options *LROsClientBeginDeleteAsyncRetrycanceledOptions) (*LROsClientDeleteAsyncRetrycanceledPoller, error) {
	resp, err := client.deleteAsyncRetrycanceled(ctx, options)
	if err != nil {
		return nil, err
	}
	pt, err := armruntime.NewPoller("LROsClient.DeleteAsyncRetrycanceled", "", resp, client.pl)
	if err != nil {
		return nil, err
	}
	return &LROsClientDeleteAsyncRetrycanceledPoller{pt: pt}, nil
}

// DeleteAsyncRetrycanceled - Long running delete request, service returns a 202 to the initial request. Poll the endpoint
// indicated in the Azure-AsyncOperation header for operation status
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROsClient) deleteAsyncRetrycanceled(ctx context.Context, options *LROsClientBeginDeleteAsyncRetrycanceledOptions) (*http.Response, error) {
	req, err := client.deleteAsyncRetrycanceledCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// deleteAsyncRetrycanceledCreateRequest creates the DeleteAsyncRetrycanceled request.
func (client *LROsClient) deleteAsyncRetrycanceledCreateRequest(ctx context.Context, options *LROsClientBeginDeleteAsyncRetrycanceledOptions) (*policy.Request, error) {
	urlPath := "/lro/deleteasync/retry/canceled"
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// BeginDeleteNoHeaderInRetry - Long running delete request, service returns a location header in the initial request. Subsequent
// calls to operation status do not contain location header.
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROsClientBeginDeleteNoHeaderInRetryOptions contains the optional parameters for the LROsClient.BeginDeleteNoHeaderInRetry
// method.
func (client *LROsClient) BeginDeleteNoHeaderInRetry(ctx context.Context, options *LROsClientBeginDeleteNoHeaderInRetryOptions) (*LROsClientDeleteNoHeaderInRetryPoller, error) {
	resp, err := client.deleteNoHeaderInRetry(ctx, options)
	if err != nil {
		return nil, err
	}
	pt, err := armruntime.NewPoller("LROsClient.DeleteNoHeaderInRetry", "", resp, client.pl)
	if err != nil {
		return nil, err
	}
	return &LROsClientDeleteNoHeaderInRetryPoller{pt: pt}, nil
}

// DeleteNoHeaderInRetry - Long running delete request, service returns a location header in the initial request. Subsequent
// calls to operation status do not contain location header.
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROsClient) deleteNoHeaderInRetry(ctx context.Context, options *LROsClientBeginDeleteNoHeaderInRetryOptions) (*http.Response, error) {
	req, err := client.deleteNoHeaderInRetryCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted, http.StatusNoContent) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// deleteNoHeaderInRetryCreateRequest creates the DeleteNoHeaderInRetry request.
func (client *LROsClient) deleteNoHeaderInRetryCreateRequest(ctx context.Context, options *LROsClientBeginDeleteNoHeaderInRetryOptions) (*policy.Request, error) {
	urlPath := "/lro/delete/noheader"
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// BeginDeleteProvisioning202Accepted200Succeeded - Long running delete request, service returns a 202 to the initial request,
// with an entity that contains ProvisioningState=’Accepted’. Polls return this value until the last poll returns a ‘200’
// with
// ProvisioningState=’Succeeded’
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROsClientBeginDeleteProvisioning202Accepted200SucceededOptions contains the optional parameters for the LROsClient.BeginDeleteProvisioning202Accepted200Succeeded
// method.
func (client *LROsClient) BeginDeleteProvisioning202Accepted200Succeeded(ctx context.Context, options *LROsClientBeginDeleteProvisioning202Accepted200SucceededOptions) (*LROsClientDeleteProvisioning202Accepted200SucceededPoller, error) {
	resp, err := client.deleteProvisioning202Accepted200Succeeded(ctx, options)
	if err != nil {
		return nil, err
	}
	pt, err := armruntime.NewPoller("LROsClient.DeleteProvisioning202Accepted200Succeeded", "", resp, client.pl)
	if err != nil {
		return nil, err
	}
	return &LROsClientDeleteProvisioning202Accepted200SucceededPoller{pt: pt}, nil
}

// DeleteProvisioning202Accepted200Succeeded - Long running delete request, service returns a 202 to the initial request,
// with an entity that contains ProvisioningState=’Accepted’. Polls return this value until the last poll returns a ‘200’
// with
// ProvisioningState=’Succeeded’
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROsClient) deleteProvisioning202Accepted200Succeeded(ctx context.Context, options *LROsClientBeginDeleteProvisioning202Accepted200SucceededOptions) (*http.Response, error) {
	req, err := client.deleteProvisioning202Accepted200SucceededCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// deleteProvisioning202Accepted200SucceededCreateRequest creates the DeleteProvisioning202Accepted200Succeeded request.
func (client *LROsClient) deleteProvisioning202Accepted200SucceededCreateRequest(ctx context.Context, options *LROsClientBeginDeleteProvisioning202Accepted200SucceededOptions) (*policy.Request, error) {
	urlPath := "/lro/delete/provisioning/202/accepted/200/succeeded"
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// BeginDeleteProvisioning202DeletingFailed200 - Long running delete request, service returns a 202 to the initial request,
// with an entity that contains ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’
// with
// ProvisioningState=’Failed’
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROsClientBeginDeleteProvisioning202DeletingFailed200Options contains the optional parameters for the LROsClient.BeginDeleteProvisioning202DeletingFailed200
// method.
func (client *LROsClient) BeginDeleteProvisioning202DeletingFailed200(ctx context.Context, options *LROsClientBeginDeleteProvisioning202DeletingFailed200Options) (*LROsClientDeleteProvisioning202DeletingFailed200Poller, error) {
	resp, err := client.deleteProvisioning202DeletingFailed200(ctx, options)
	if err != nil {
		return nil, err
	}
	pt, err := armruntime.NewPoller("LROsClient.DeleteProvisioning202DeletingFailed200", "", resp, client.pl)
	if err != nil {
		return nil, err
	}
	return &LROsClientDeleteProvisioning202DeletingFailed200Poller{pt: pt}, nil
}

// DeleteProvisioning202DeletingFailed200 - Long running delete request, service returns a 202 to the initial request, with
// an entity that contains ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’ with
// ProvisioningState=’Failed’
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROsClient) deleteProvisioning202DeletingFailed200(ctx context.Context, options *LROsClientBeginDeleteProvisioning202DeletingFailed200Options) (*http.Response, error) {
	req, err := client.deleteProvisioning202DeletingFailed200CreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// deleteProvisioning202DeletingFailed200CreateRequest creates the DeleteProvisioning202DeletingFailed200 request.
func (client *LROsClient) deleteProvisioning202DeletingFailed200CreateRequest(ctx context.Context, options *LROsClientBeginDeleteProvisioning202DeletingFailed200Options) (*policy.Request, error) {
	urlPath := "/lro/delete/provisioning/202/deleting/200/failed"
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// BeginDeleteProvisioning202Deletingcanceled200 - Long running delete request, service returns a 202 to the initial request,
// with an entity that contains ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’
// with
// ProvisioningState=’Canceled’
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROsClientBeginDeleteProvisioning202Deletingcanceled200Options contains the optional parameters for the LROsClient.BeginDeleteProvisioning202Deletingcanceled200
// method.
func (client *LROsClient) BeginDeleteProvisioning202Deletingcanceled200(ctx context.Context, options *LROsClientBeginDeleteProvisioning202Deletingcanceled200Options) (*LROsClientDeleteProvisioning202Deletingcanceled200Poller, error) {
	resp, err := client.deleteProvisioning202Deletingcanceled200(ctx, options)
	if err != nil {
		return nil, err
	}
	pt, err := armruntime.NewPoller("LROsClient.DeleteProvisioning202Deletingcanceled200", "", resp, client.pl)
	if err != nil {
		return nil, err
	}
	return &LROsClientDeleteProvisioning202Deletingcanceled200Poller{pt: pt}, nil
}

// DeleteProvisioning202Deletingcanceled200 - Long running delete request, service returns a 202 to the initial request, with
// an entity that contains ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’ with
// ProvisioningState=’Canceled’
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROsClient) deleteProvisioning202Deletingcanceled200(ctx context.Context, options *LROsClientBeginDeleteProvisioning202Deletingcanceled200Options) (*http.Response, error) {
	req, err := client.deleteProvisioning202Deletingcanceled200CreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// deleteProvisioning202Deletingcanceled200CreateRequest creates the DeleteProvisioning202Deletingcanceled200 request.
func (client *LROsClient) deleteProvisioning202Deletingcanceled200CreateRequest(ctx context.Context, options *LROsClientBeginDeleteProvisioning202Deletingcanceled200Options) (*policy.Request, error) {
	urlPath := "/lro/delete/provisioning/202/deleting/200/canceled"
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// BeginPatch200SucceededIgnoreHeaders - Long running put request, service returns a 200 to the initial request with location
// header. We should not have any subsequent calls after receiving this first response.
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROsClientBeginPatch200SucceededIgnoreHeadersOptions contains the optional parameters for the LROsClient.BeginPatch200SucceededIgnoreHeaders
// method.
func (client *LROsClient) BeginPatch200SucceededIgnoreHeaders(ctx context.Context, options *LROsClientBeginPatch200SucceededIgnoreHeadersOptions) (*LROsClientPatch200SucceededIgnoreHeadersPoller, error) {
	resp, err := client.patch200SucceededIgnoreHeaders(ctx, options)
	if err != nil {
		return nil, err
	}
	pt, err := armruntime.NewPoller("LROsClient.Patch200SucceededIgnoreHeaders", "", resp, client.pl)
	if err != nil {
		return nil, err
	}
	return &LROsClientPatch200SucceededIgnoreHeadersPoller{pt: pt}, nil
}

// Patch200SucceededIgnoreHeaders - Long running put request, service returns a 200 to the initial request with location header.
// We should not have any subsequent calls after receiving this first response.
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROsClient) patch200SucceededIgnoreHeaders(ctx context.Context, options *LROsClientBeginPatch200SucceededIgnoreHeadersOptions) (*http.Response, error) {
	req, err := client.patch200SucceededIgnoreHeadersCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// patch200SucceededIgnoreHeadersCreateRequest creates the Patch200SucceededIgnoreHeaders request.
func (client *LROsClient) patch200SucceededIgnoreHeadersCreateRequest(ctx context.Context, options *LROsClientBeginPatch200SucceededIgnoreHeadersOptions) (*policy.Request, error) {
	urlPath := "/lro/patch/200/succeeded/ignoreheaders"
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, runtime.MarshalAsJSON(req, *options.Product)
	}
	return req, nil
}

// BeginPost200WithPayload - Long running post request, service returns a 202 to the initial request, with 'Location' header.
// Poll returns a 200 with a response body after success.
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROsClientBeginPost200WithPayloadOptions contains the optional parameters for the LROsClient.BeginPost200WithPayload
// method.
func (client *LROsClient) BeginPost200WithPayload(ctx context.Context, options *LROsClientBeginPost200WithPayloadOptions) (*LROsClientPost200WithPayloadPoller, error) {
	resp, err := client.post200WithPayload(ctx, options)
	if err != nil {
		return nil, err
	}
	pt, err := armruntime.NewPoller("LROsClient.Post200WithPayload", "", resp, client.pl)
	if err != nil {
		return nil, err
	}
	return &LROsClientPost200WithPayloadPoller{pt: pt}, nil
}

// Post200WithPayload - Long running post request, service returns a 202 to the initial request, with 'Location' header. Poll
// returns a 200 with a response body after success.
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROsClient) post200WithPayload(ctx context.Context, options *LROsClientBeginPost200WithPayloadOptions) (*http.Response, error) {
	req, err := client.post200WithPayloadCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// post200WithPayloadCreateRequest creates the Post200WithPayload request.
func (client *LROsClient) post200WithPayloadCreateRequest(ctx context.Context, options *LROsClientBeginPost200WithPayloadOptions) (*policy.Request, error) {
	urlPath := "/lro/post/payload/200"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// BeginPost202List - Long running put request, service returns a 202 with empty body to first request, returns a 200 with
// body [{ 'id': '100', 'name': 'foo' }].
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROsClientBeginPost202ListOptions contains the optional parameters for the LROsClient.BeginPost202List method.
func (client *LROsClient) BeginPost202List(ctx context.Context, options *LROsClientBeginPost202ListOptions) (*LROsClientPost202ListPoller, error) {
	resp, err := client.post202List(ctx, options)
	if err != nil {
		return nil, err
	}
	pt, err := armruntime.NewPoller("LROsClient.Post202List", "", resp, client.pl)
	if err != nil {
		return nil, err
	}
	return &LROsClientPost202ListPoller{pt: pt}, nil
}

// Post202List - Long running put request, service returns a 202 with empty body to first request, returns a 200 with body
// [{ 'id': '100', 'name': 'foo' }].
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROsClient) post202List(ctx context.Context, options *LROsClientBeginPost202ListOptions) (*http.Response, error) {
	req, err := client.post202ListCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// post202ListCreateRequest creates the Post202List request.
func (client *LROsClient) post202ListCreateRequest(ctx context.Context, options *LROsClientBeginPost202ListOptions) (*policy.Request, error) {
	urlPath := "/lro/list"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// BeginPost202NoRetry204 - Long running post request, service returns a 202 to the initial request, with 'Location' header,
// 204 with noresponse body after success
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROsClientBeginPost202NoRetry204Options contains the optional parameters for the LROsClient.BeginPost202NoRetry204
// method.
func (client *LROsClient) BeginPost202NoRetry204(ctx context.Context, options *LROsClientBeginPost202NoRetry204Options) (*LROsClientPost202NoRetry204Poller, error) {
	resp, err := client.post202NoRetry204(ctx, options)
	if err != nil {
		return nil, err
	}
	pt, err := armruntime.NewPoller("LROsClient.Post202NoRetry204", "", resp, client.pl)
	if err != nil {
		return nil, err
	}
	return &LROsClientPost202NoRetry204Poller{pt: pt}, nil
}

// Post202NoRetry204 - Long running post request, service returns a 202 to the initial request, with 'Location' header, 204
// with noresponse body after success
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROsClient) post202NoRetry204(ctx context.Context, options *LROsClientBeginPost202NoRetry204Options) (*http.Response, error) {
	req, err := client.post202NoRetry204CreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// post202NoRetry204CreateRequest creates the Post202NoRetry204 request.
func (client *LROsClient) post202NoRetry204CreateRequest(ctx context.Context, options *LROsClientBeginPost202NoRetry204Options) (*policy.Request, error) {
	urlPath := "/lro/post/202/noretry/204"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, runtime.MarshalAsJSON(req, *options.Product)
	}
	return req, nil
}

// BeginPost202Retry200 - Long running post request, service returns a 202 to the initial request, with 'Location' and 'Retry-After'
// headers, Polls return a 200 with a response body after success
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROsClientBeginPost202Retry200Options contains the optional parameters for the LROsClient.BeginPost202Retry200
// method.
func (client *LROsClient) BeginPost202Retry200(ctx context.Context, options *LROsClientBeginPost202Retry200Options) (*LROsClientPost202Retry200Poller, error) {
	resp, err := client.post202Retry200(ctx, options)
	if err != nil {
		return nil, err
	}
	pt, err := armruntime.NewPoller("LROsClient.Post202Retry200", "", resp, client.pl)
	if err != nil {
		return nil, err
	}
	return &LROsClientPost202Retry200Poller{pt: pt}, nil
}

// Post202Retry200 - Long running post request, service returns a 202 to the initial request, with 'Location' and 'Retry-After'
// headers, Polls return a 200 with a response body after success
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROsClient) post202Retry200(ctx context.Context, options *LROsClientBeginPost202Retry200Options) (*http.Response, error) {
	req, err := client.post202Retry200CreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// post202Retry200CreateRequest creates the Post202Retry200 request.
func (client *LROsClient) post202Retry200CreateRequest(ctx context.Context, options *LROsClientBeginPost202Retry200Options) (*policy.Request, error) {
	urlPath := "/lro/post/202/retry/200"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, runtime.MarshalAsJSON(req, *options.Product)
	}
	return req, nil
}

// BeginPostAsyncNoRetrySucceeded - Long running post request, service returns a 202 to the initial request, with an entity
// that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROsClientBeginPostAsyncNoRetrySucceededOptions contains the optional parameters for the LROsClient.BeginPostAsyncNoRetrySucceeded
// method.
func (client *LROsClient) BeginPostAsyncNoRetrySucceeded(ctx context.Context, options *LROsClientBeginPostAsyncNoRetrySucceededOptions) (*LROsClientPostAsyncNoRetrySucceededPoller, error) {
	resp, err := client.postAsyncNoRetrySucceeded(ctx, options)
	if err != nil {
		return nil, err
	}
	pt, err := armruntime.NewPoller("LROsClient.PostAsyncNoRetrySucceeded", "", resp, client.pl)
	if err != nil {
		return nil, err
	}
	return &LROsClientPostAsyncNoRetrySucceededPoller{pt: pt}, nil
}

// PostAsyncNoRetrySucceeded - Long running post request, service returns a 202 to the initial request, with an entity that
// contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROsClient) postAsyncNoRetrySucceeded(ctx context.Context, options *LROsClientBeginPostAsyncNoRetrySucceededOptions) (*http.Response, error) {
	req, err := client.postAsyncNoRetrySucceededCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// postAsyncNoRetrySucceededCreateRequest creates the PostAsyncNoRetrySucceeded request.
func (client *LROsClient) postAsyncNoRetrySucceededCreateRequest(ctx context.Context, options *LROsClientBeginPostAsyncNoRetrySucceededOptions) (*policy.Request, error) {
	urlPath := "/lro/postasync/noretry/succeeded"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, runtime.MarshalAsJSON(req, *options.Product)
	}
	return req, nil
}

// BeginPostAsyncRetryFailed - Long running post request, service returns a 202 to the initial request, with an entity that
// contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROsClientBeginPostAsyncRetryFailedOptions contains the optional parameters for the LROsClient.BeginPostAsyncRetryFailed
// method.
func (client *LROsClient) BeginPostAsyncRetryFailed(ctx context.Context, options *LROsClientBeginPostAsyncRetryFailedOptions) (*LROsClientPostAsyncRetryFailedPoller, error) {
	resp, err := client.postAsyncRetryFailed(ctx, options)
	if err != nil {
		return nil, err
	}
	pt, err := armruntime.NewPoller("LROsClient.PostAsyncRetryFailed", "", resp, client.pl)
	if err != nil {
		return nil, err
	}
	return &LROsClientPostAsyncRetryFailedPoller{pt: pt}, nil
}

// PostAsyncRetryFailed - Long running post request, service returns a 202 to the initial request, with an entity that contains
// ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROsClient) postAsyncRetryFailed(ctx context.Context, options *LROsClientBeginPostAsyncRetryFailedOptions) (*http.Response, error) {
	req, err := client.postAsyncRetryFailedCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// postAsyncRetryFailedCreateRequest creates the PostAsyncRetryFailed request.
func (client *LROsClient) postAsyncRetryFailedCreateRequest(ctx context.Context, options *LROsClientBeginPostAsyncRetryFailedOptions) (*policy.Request, error) {
	urlPath := "/lro/postasync/retry/failed"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, runtime.MarshalAsJSON(req, *options.Product)
	}
	return req, nil
}

// BeginPostAsyncRetrySucceeded - Long running post request, service returns a 202 to the initial request, with an entity
// that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROsClientBeginPostAsyncRetrySucceededOptions contains the optional parameters for the LROsClient.BeginPostAsyncRetrySucceeded
// method.
func (client *LROsClient) BeginPostAsyncRetrySucceeded(ctx context.Context, options *LROsClientBeginPostAsyncRetrySucceededOptions) (*LROsClientPostAsyncRetrySucceededPoller, error) {
	resp, err := client.postAsyncRetrySucceeded(ctx, options)
	if err != nil {
		return nil, err
	}
	pt, err := armruntime.NewPoller("LROsClient.PostAsyncRetrySucceeded", "", resp, client.pl)
	if err != nil {
		return nil, err
	}
	return &LROsClientPostAsyncRetrySucceededPoller{pt: pt}, nil
}

// PostAsyncRetrySucceeded - Long running post request, service returns a 202 to the initial request, with an entity that
// contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROsClient) postAsyncRetrySucceeded(ctx context.Context, options *LROsClientBeginPostAsyncRetrySucceededOptions) (*http.Response, error) {
	req, err := client.postAsyncRetrySucceededCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// postAsyncRetrySucceededCreateRequest creates the PostAsyncRetrySucceeded request.
func (client *LROsClient) postAsyncRetrySucceededCreateRequest(ctx context.Context, options *LROsClientBeginPostAsyncRetrySucceededOptions) (*policy.Request, error) {
	urlPath := "/lro/postasync/retry/succeeded"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, runtime.MarshalAsJSON(req, *options.Product)
	}
	return req, nil
}

// BeginPostAsyncRetrycanceled - Long running post request, service returns a 202 to the initial request, with an entity that
// contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROsClientBeginPostAsyncRetrycanceledOptions contains the optional parameters for the LROsClient.BeginPostAsyncRetrycanceled
// method.
func (client *LROsClient) BeginPostAsyncRetrycanceled(ctx context.Context, options *LROsClientBeginPostAsyncRetrycanceledOptions) (*LROsClientPostAsyncRetrycanceledPoller, error) {
	resp, err := client.postAsyncRetrycanceled(ctx, options)
	if err != nil {
		return nil, err
	}
	pt, err := armruntime.NewPoller("LROsClient.PostAsyncRetrycanceled", "", resp, client.pl)
	if err != nil {
		return nil, err
	}
	return &LROsClientPostAsyncRetrycanceledPoller{pt: pt}, nil
}

// PostAsyncRetrycanceled - Long running post request, service returns a 202 to the initial request, with an entity that contains
// ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROsClient) postAsyncRetrycanceled(ctx context.Context, options *LROsClientBeginPostAsyncRetrycanceledOptions) (*http.Response, error) {
	req, err := client.postAsyncRetrycanceledCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// postAsyncRetrycanceledCreateRequest creates the PostAsyncRetrycanceled request.
func (client *LROsClient) postAsyncRetrycanceledCreateRequest(ctx context.Context, options *LROsClientBeginPostAsyncRetrycanceledOptions) (*policy.Request, error) {
	urlPath := "/lro/postasync/retry/canceled"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, runtime.MarshalAsJSON(req, *options.Product)
	}
	return req, nil
}

// BeginPostDoubleHeadersFinalAzureHeaderGet - Long running post request, service returns a 202 to the initial request with
// both Location and Azure-Async header. Poll Azure-Async and it's success. Should NOT poll Location to get the final object
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROsClientBeginPostDoubleHeadersFinalAzureHeaderGetOptions contains the optional parameters for the LROsClient.BeginPostDoubleHeadersFinalAzureHeaderGet
// method.
func (client *LROsClient) BeginPostDoubleHeadersFinalAzureHeaderGet(ctx context.Context, options *LROsClientBeginPostDoubleHeadersFinalAzureHeaderGetOptions) (*LROsClientPostDoubleHeadersFinalAzureHeaderGetPoller, error) {
	resp, err := client.postDoubleHeadersFinalAzureHeaderGet(ctx, options)
	if err != nil {
		return nil, err
	}
	pt, err := armruntime.NewPoller("LROsClient.PostDoubleHeadersFinalAzureHeaderGet", "azure-async-operation", resp, client.pl)
	if err != nil {
		return nil, err
	}
	return &LROsClientPostDoubleHeadersFinalAzureHeaderGetPoller{pt: pt}, nil
}

// PostDoubleHeadersFinalAzureHeaderGet - Long running post request, service returns a 202 to the initial request with both
// Location and Azure-Async header. Poll Azure-Async and it's success. Should NOT poll Location to get the final object
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROsClient) postDoubleHeadersFinalAzureHeaderGet(ctx context.Context, options *LROsClientBeginPostDoubleHeadersFinalAzureHeaderGetOptions) (*http.Response, error) {
	req, err := client.postDoubleHeadersFinalAzureHeaderGetCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// postDoubleHeadersFinalAzureHeaderGetCreateRequest creates the PostDoubleHeadersFinalAzureHeaderGet request.
func (client *LROsClient) postDoubleHeadersFinalAzureHeaderGetCreateRequest(ctx context.Context, options *LROsClientBeginPostDoubleHeadersFinalAzureHeaderGetOptions) (*policy.Request, error) {
	urlPath := "/lro/LROPostDoubleHeadersFinalAzureHeaderGet"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// BeginPostDoubleHeadersFinalAzureHeaderGetDefault - Long running post request, service returns a 202 to the initial request
// with both Location and Azure-Async header. Poll Azure-Async and it's success. Should NOT poll Location to get the final
// object
// if you support initial Autorest behavior.
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROsClientBeginPostDoubleHeadersFinalAzureHeaderGetDefaultOptions contains the optional parameters for the LROsClient.BeginPostDoubleHeadersFinalAzureHeaderGetDefault
// method.
func (client *LROsClient) BeginPostDoubleHeadersFinalAzureHeaderGetDefault(ctx context.Context, options *LROsClientBeginPostDoubleHeadersFinalAzureHeaderGetDefaultOptions) (*LROsClientPostDoubleHeadersFinalAzureHeaderGetDefaultPoller, error) {
	resp, err := client.postDoubleHeadersFinalAzureHeaderGetDefault(ctx, options)
	if err != nil {
		return nil, err
	}
	pt, err := armruntime.NewPoller("LROsClient.PostDoubleHeadersFinalAzureHeaderGetDefault", "", resp, client.pl)
	if err != nil {
		return nil, err
	}
	return &LROsClientPostDoubleHeadersFinalAzureHeaderGetDefaultPoller{pt: pt}, nil
}

// PostDoubleHeadersFinalAzureHeaderGetDefault - Long running post request, service returns a 202 to the initial request with
// both Location and Azure-Async header. Poll Azure-Async and it's success. Should NOT poll Location to get the final object
// if you support initial Autorest behavior.
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROsClient) postDoubleHeadersFinalAzureHeaderGetDefault(ctx context.Context, options *LROsClientBeginPostDoubleHeadersFinalAzureHeaderGetDefaultOptions) (*http.Response, error) {
	req, err := client.postDoubleHeadersFinalAzureHeaderGetDefaultCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// postDoubleHeadersFinalAzureHeaderGetDefaultCreateRequest creates the PostDoubleHeadersFinalAzureHeaderGetDefault request.
func (client *LROsClient) postDoubleHeadersFinalAzureHeaderGetDefaultCreateRequest(ctx context.Context, options *LROsClientBeginPostDoubleHeadersFinalAzureHeaderGetDefaultOptions) (*policy.Request, error) {
	urlPath := "/lro/LROPostDoubleHeadersFinalAzureHeaderGetDefault"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// BeginPostDoubleHeadersFinalLocationGet - Long running post request, service returns a 202 to the initial request with both
// Location and Azure-Async header. Poll Azure-Async and it's success. Should poll Location to get the final object
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROsClientBeginPostDoubleHeadersFinalLocationGetOptions contains the optional parameters for the LROsClient.BeginPostDoubleHeadersFinalLocationGet
// method.
func (client *LROsClient) BeginPostDoubleHeadersFinalLocationGet(ctx context.Context, options *LROsClientBeginPostDoubleHeadersFinalLocationGetOptions) (*LROsClientPostDoubleHeadersFinalLocationGetPoller, error) {
	resp, err := client.postDoubleHeadersFinalLocationGet(ctx, options)
	if err != nil {
		return nil, err
	}
	pt, err := armruntime.NewPoller("LROsClient.PostDoubleHeadersFinalLocationGet", "location", resp, client.pl)
	if err != nil {
		return nil, err
	}
	return &LROsClientPostDoubleHeadersFinalLocationGetPoller{pt: pt}, nil
}

// PostDoubleHeadersFinalLocationGet - Long running post request, service returns a 202 to the initial request with both Location
// and Azure-Async header. Poll Azure-Async and it's success. Should poll Location to get the final object
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROsClient) postDoubleHeadersFinalLocationGet(ctx context.Context, options *LROsClientBeginPostDoubleHeadersFinalLocationGetOptions) (*http.Response, error) {
	req, err := client.postDoubleHeadersFinalLocationGetCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// postDoubleHeadersFinalLocationGetCreateRequest creates the PostDoubleHeadersFinalLocationGet request.
func (client *LROsClient) postDoubleHeadersFinalLocationGetCreateRequest(ctx context.Context, options *LROsClientBeginPostDoubleHeadersFinalLocationGetOptions) (*policy.Request, error) {
	urlPath := "/lro/LROPostDoubleHeadersFinalLocationGet"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// BeginPut200Acceptedcanceled200 - Long running put request, service returns a 201 to the initial request, with an entity
// that contains ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’ with
// ProvisioningState=’Canceled’
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROsClientBeginPut200Acceptedcanceled200Options contains the optional parameters for the LROsClient.BeginPut200Acceptedcanceled200
// method.
func (client *LROsClient) BeginPut200Acceptedcanceled200(ctx context.Context, options *LROsClientBeginPut200Acceptedcanceled200Options) (*LROsClientPut200Acceptedcanceled200Poller, error) {
	resp, err := client.put200Acceptedcanceled200(ctx, options)
	if err != nil {
		return nil, err
	}
	pt, err := armruntime.NewPoller("LROsClient.Put200Acceptedcanceled200", "", resp, client.pl)
	if err != nil {
		return nil, err
	}
	return &LROsClientPut200Acceptedcanceled200Poller{pt: pt}, nil
}

// Put200Acceptedcanceled200 - Long running put request, service returns a 201 to the initial request, with an entity that
// contains ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’ with
// ProvisioningState=’Canceled’
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROsClient) put200Acceptedcanceled200(ctx context.Context, options *LROsClientBeginPut200Acceptedcanceled200Options) (*http.Response, error) {
	req, err := client.put200Acceptedcanceled200CreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// put200Acceptedcanceled200CreateRequest creates the Put200Acceptedcanceled200 request.
func (client *LROsClient) put200Acceptedcanceled200CreateRequest(ctx context.Context, options *LROsClientBeginPut200Acceptedcanceled200Options) (*policy.Request, error) {
	urlPath := "/lro/put/200/accepted/canceled/200"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, runtime.MarshalAsJSON(req, *options.Product)
	}
	return req, nil
}

// BeginPut200Succeeded - Long running put request, service returns a 200 to the initial request, with an entity that contains
// ProvisioningState=’Succeeded’.
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROsClientBeginPut200SucceededOptions contains the optional parameters for the LROsClient.BeginPut200Succeeded
// method.
func (client *LROsClient) BeginPut200Succeeded(ctx context.Context, options *LROsClientBeginPut200SucceededOptions) (*LROsClientPut200SucceededPoller, error) {
	resp, err := client.put200Succeeded(ctx, options)
	if err != nil {
		return nil, err
	}
	pt, err := armruntime.NewPoller("LROsClient.Put200Succeeded", "", resp, client.pl)
	if err != nil {
		return nil, err
	}
	return &LROsClientPut200SucceededPoller{pt: pt}, nil
}

// Put200Succeeded - Long running put request, service returns a 200 to the initial request, with an entity that contains
// ProvisioningState=’Succeeded’.
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROsClient) put200Succeeded(ctx context.Context, options *LROsClientBeginPut200SucceededOptions) (*http.Response, error) {
	req, err := client.put200SucceededCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// put200SucceededCreateRequest creates the Put200Succeeded request.
func (client *LROsClient) put200SucceededCreateRequest(ctx context.Context, options *LROsClientBeginPut200SucceededOptions) (*policy.Request, error) {
	urlPath := "/lro/put/200/succeeded"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, runtime.MarshalAsJSON(req, *options.Product)
	}
	return req, nil
}

// BeginPut200SucceededNoState - Long running put request, service returns a 200 to the initial request, with an entity that
// does not contain ProvisioningState=’Succeeded’.
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROsClientBeginPut200SucceededNoStateOptions contains the optional parameters for the LROsClient.BeginPut200SucceededNoState
// method.
func (client *LROsClient) BeginPut200SucceededNoState(ctx context.Context, options *LROsClientBeginPut200SucceededNoStateOptions) (*LROsClientPut200SucceededNoStatePoller, error) {
	resp, err := client.put200SucceededNoState(ctx, options)
	if err != nil {
		return nil, err
	}
	pt, err := armruntime.NewPoller("LROsClient.Put200SucceededNoState", "", resp, client.pl)
	if err != nil {
		return nil, err
	}
	return &LROsClientPut200SucceededNoStatePoller{pt: pt}, nil
}

// Put200SucceededNoState - Long running put request, service returns a 200 to the initial request, with an entity that does
// not contain ProvisioningState=’Succeeded’.
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROsClient) put200SucceededNoState(ctx context.Context, options *LROsClientBeginPut200SucceededNoStateOptions) (*http.Response, error) {
	req, err := client.put200SucceededNoStateCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// put200SucceededNoStateCreateRequest creates the Put200SucceededNoState request.
func (client *LROsClient) put200SucceededNoStateCreateRequest(ctx context.Context, options *LROsClientBeginPut200SucceededNoStateOptions) (*policy.Request, error) {
	urlPath := "/lro/put/200/succeeded/nostate"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, runtime.MarshalAsJSON(req, *options.Product)
	}
	return req, nil
}

// BeginPut200UpdatingSucceeded204 - Long running put request, service returns a 201 to the initial request, with an entity
// that contains ProvisioningState=’Updating’. Polls return this value until the last poll returns a ‘200’ with
// ProvisioningState=’Succeeded’
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROsClientBeginPut200UpdatingSucceeded204Options contains the optional parameters for the LROsClient.BeginPut200UpdatingSucceeded204
// method.
func (client *LROsClient) BeginPut200UpdatingSucceeded204(ctx context.Context, options *LROsClientBeginPut200UpdatingSucceeded204Options) (*LROsClientPut200UpdatingSucceeded204Poller, error) {
	resp, err := client.put200UpdatingSucceeded204(ctx, options)
	if err != nil {
		return nil, err
	}
	pt, err := armruntime.NewPoller("LROsClient.Put200UpdatingSucceeded204", "", resp, client.pl)
	if err != nil {
		return nil, err
	}
	return &LROsClientPut200UpdatingSucceeded204Poller{pt: pt}, nil
}

// Put200UpdatingSucceeded204 - Long running put request, service returns a 201 to the initial request, with an entity that
// contains ProvisioningState=’Updating’. Polls return this value until the last poll returns a ‘200’ with
// ProvisioningState=’Succeeded’
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROsClient) put200UpdatingSucceeded204(ctx context.Context, options *LROsClientBeginPut200UpdatingSucceeded204Options) (*http.Response, error) {
	req, err := client.put200UpdatingSucceeded204CreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// put200UpdatingSucceeded204CreateRequest creates the Put200UpdatingSucceeded204 request.
func (client *LROsClient) put200UpdatingSucceeded204CreateRequest(ctx context.Context, options *LROsClientBeginPut200UpdatingSucceeded204Options) (*policy.Request, error) {
	urlPath := "/lro/put/200/updating/succeeded/200"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, runtime.MarshalAsJSON(req, *options.Product)
	}
	return req, nil
}

// BeginPut201CreatingFailed200 - Long running put request, service returns a 201 to the initial request, with an entity that
// contains ProvisioningState=’Created’. Polls return this value until the last poll returns a ‘200’ with
// ProvisioningState=’Failed’
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROsClientBeginPut201CreatingFailed200Options contains the optional parameters for the LROsClient.BeginPut201CreatingFailed200
// method.
func (client *LROsClient) BeginPut201CreatingFailed200(ctx context.Context, options *LROsClientBeginPut201CreatingFailed200Options) (*LROsClientPut201CreatingFailed200Poller, error) {
	resp, err := client.put201CreatingFailed200(ctx, options)
	if err != nil {
		return nil, err
	}
	pt, err := armruntime.NewPoller("LROsClient.Put201CreatingFailed200", "", resp, client.pl)
	if err != nil {
		return nil, err
	}
	return &LROsClientPut201CreatingFailed200Poller{pt: pt}, nil
}

// Put201CreatingFailed200 - Long running put request, service returns a 201 to the initial request, with an entity that contains
// ProvisioningState=’Created’. Polls return this value until the last poll returns a ‘200’ with
// ProvisioningState=’Failed’
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROsClient) put201CreatingFailed200(ctx context.Context, options *LROsClientBeginPut201CreatingFailed200Options) (*http.Response, error) {
	req, err := client.put201CreatingFailed200CreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// put201CreatingFailed200CreateRequest creates the Put201CreatingFailed200 request.
func (client *LROsClient) put201CreatingFailed200CreateRequest(ctx context.Context, options *LROsClientBeginPut201CreatingFailed200Options) (*policy.Request, error) {
	urlPath := "/lro/put/201/created/failed/200"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, runtime.MarshalAsJSON(req, *options.Product)
	}
	return req, nil
}

// BeginPut201CreatingSucceeded200 - Long running put request, service returns a 201 to the initial request, with an entity
// that contains ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’ with
// ProvisioningState=’Succeeded’
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROsClientBeginPut201CreatingSucceeded200Options contains the optional parameters for the LROsClient.BeginPut201CreatingSucceeded200
// method.
func (client *LROsClient) BeginPut201CreatingSucceeded200(ctx context.Context, options *LROsClientBeginPut201CreatingSucceeded200Options) (*LROsClientPut201CreatingSucceeded200Poller, error) {
	resp, err := client.put201CreatingSucceeded200(ctx, options)
	if err != nil {
		return nil, err
	}
	pt, err := armruntime.NewPoller("LROsClient.Put201CreatingSucceeded200", "", resp, client.pl)
	if err != nil {
		return nil, err
	}
	return &LROsClientPut201CreatingSucceeded200Poller{pt: pt}, nil
}

// Put201CreatingSucceeded200 - Long running put request, service returns a 201 to the initial request, with an entity that
// contains ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’ with
// ProvisioningState=’Succeeded’
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROsClient) put201CreatingSucceeded200(ctx context.Context, options *LROsClientBeginPut201CreatingSucceeded200Options) (*http.Response, error) {
	req, err := client.put201CreatingSucceeded200CreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// put201CreatingSucceeded200CreateRequest creates the Put201CreatingSucceeded200 request.
func (client *LROsClient) put201CreatingSucceeded200CreateRequest(ctx context.Context, options *LROsClientBeginPut201CreatingSucceeded200Options) (*policy.Request, error) {
	urlPath := "/lro/put/201/creating/succeeded/200"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, runtime.MarshalAsJSON(req, *options.Product)
	}
	return req, nil
}

// BeginPut201Succeeded - Long running put request, service returns a 201 to the initial request, with an entity that contains
// ProvisioningState=’Succeeded’.
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROsClientBeginPut201SucceededOptions contains the optional parameters for the LROsClient.BeginPut201Succeeded
// method.
func (client *LROsClient) BeginPut201Succeeded(ctx context.Context, options *LROsClientBeginPut201SucceededOptions) (*LROsClientPut201SucceededPoller, error) {
	resp, err := client.put201Succeeded(ctx, options)
	if err != nil {
		return nil, err
	}
	pt, err := armruntime.NewPoller("LROsClient.Put201Succeeded", "", resp, client.pl)
	if err != nil {
		return nil, err
	}
	return &LROsClientPut201SucceededPoller{pt: pt}, nil
}

// Put201Succeeded - Long running put request, service returns a 201 to the initial request, with an entity that contains
// ProvisioningState=’Succeeded’.
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROsClient) put201Succeeded(ctx context.Context, options *LROsClientBeginPut201SucceededOptions) (*http.Response, error) {
	req, err := client.put201SucceededCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// put201SucceededCreateRequest creates the Put201Succeeded request.
func (client *LROsClient) put201SucceededCreateRequest(ctx context.Context, options *LROsClientBeginPut201SucceededOptions) (*policy.Request, error) {
	urlPath := "/lro/put/201/succeeded"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, runtime.MarshalAsJSON(req, *options.Product)
	}
	return req, nil
}

// BeginPut202Retry200 - Long running put request, service returns a 202 to the initial request, with a location header that
// points to a polling URL that returns a 200 and an entity that doesn't contains ProvisioningState
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROsClientBeginPut202Retry200Options contains the optional parameters for the LROsClient.BeginPut202Retry200
// method.
func (client *LROsClient) BeginPut202Retry200(ctx context.Context, options *LROsClientBeginPut202Retry200Options) (*LROsClientPut202Retry200Poller, error) {
	resp, err := client.put202Retry200(ctx, options)
	if err != nil {
		return nil, err
	}
	pt, err := armruntime.NewPoller("LROsClient.Put202Retry200", "", resp, client.pl)
	if err != nil {
		return nil, err
	}
	return &LROsClientPut202Retry200Poller{pt: pt}, nil
}

// Put202Retry200 - Long running put request, service returns a 202 to the initial request, with a location header that points
// to a polling URL that returns a 200 and an entity that doesn't contains ProvisioningState
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROsClient) put202Retry200(ctx context.Context, options *LROsClientBeginPut202Retry200Options) (*http.Response, error) {
	req, err := client.put202Retry200CreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// put202Retry200CreateRequest creates the Put202Retry200 request.
func (client *LROsClient) put202Retry200CreateRequest(ctx context.Context, options *LROsClientBeginPut202Retry200Options) (*policy.Request, error) {
	urlPath := "/lro/put/202/retry/200"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, runtime.MarshalAsJSON(req, *options.Product)
	}
	return req, nil
}

// BeginPutAsyncNoHeaderInRetry - Long running put request, service returns a 202 to the initial request with Azure-AsyncOperation
// header. Subsequent calls to operation status do not contain Azure-AsyncOperation header.
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROsClientBeginPutAsyncNoHeaderInRetryOptions contains the optional parameters for the LROsClient.BeginPutAsyncNoHeaderInRetry
// method.
func (client *LROsClient) BeginPutAsyncNoHeaderInRetry(ctx context.Context, options *LROsClientBeginPutAsyncNoHeaderInRetryOptions) (*LROsClientPutAsyncNoHeaderInRetryPoller, error) {
	resp, err := client.putAsyncNoHeaderInRetry(ctx, options)
	if err != nil {
		return nil, err
	}
	pt, err := armruntime.NewPoller("LROsClient.PutAsyncNoHeaderInRetry", "", resp, client.pl)
	if err != nil {
		return nil, err
	}
	return &LROsClientPutAsyncNoHeaderInRetryPoller{pt: pt}, nil
}

// PutAsyncNoHeaderInRetry - Long running put request, service returns a 202 to the initial request with Azure-AsyncOperation
// header. Subsequent calls to operation status do not contain Azure-AsyncOperation header.
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROsClient) putAsyncNoHeaderInRetry(ctx context.Context, options *LROsClientBeginPutAsyncNoHeaderInRetryOptions) (*http.Response, error) {
	req, err := client.putAsyncNoHeaderInRetryCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// putAsyncNoHeaderInRetryCreateRequest creates the PutAsyncNoHeaderInRetry request.
func (client *LROsClient) putAsyncNoHeaderInRetryCreateRequest(ctx context.Context, options *LROsClientBeginPutAsyncNoHeaderInRetryOptions) (*policy.Request, error) {
	urlPath := "/lro/putasync/noheader/201/200"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, runtime.MarshalAsJSON(req, *options.Product)
	}
	return req, nil
}

// BeginPutAsyncNoRetrySucceeded - Long running put request, service returns a 200 to the initial request, with an entity
// that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROsClientBeginPutAsyncNoRetrySucceededOptions contains the optional parameters for the LROsClient.BeginPutAsyncNoRetrySucceeded
// method.
func (client *LROsClient) BeginPutAsyncNoRetrySucceeded(ctx context.Context, options *LROsClientBeginPutAsyncNoRetrySucceededOptions) (*LROsClientPutAsyncNoRetrySucceededPoller, error) {
	resp, err := client.putAsyncNoRetrySucceeded(ctx, options)
	if err != nil {
		return nil, err
	}
	pt, err := armruntime.NewPoller("LROsClient.PutAsyncNoRetrySucceeded", "", resp, client.pl)
	if err != nil {
		return nil, err
	}
	return &LROsClientPutAsyncNoRetrySucceededPoller{pt: pt}, nil
}

// PutAsyncNoRetrySucceeded - Long running put request, service returns a 200 to the initial request, with an entity that
// contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROsClient) putAsyncNoRetrySucceeded(ctx context.Context, options *LROsClientBeginPutAsyncNoRetrySucceededOptions) (*http.Response, error) {
	req, err := client.putAsyncNoRetrySucceededCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// putAsyncNoRetrySucceededCreateRequest creates the PutAsyncNoRetrySucceeded request.
func (client *LROsClient) putAsyncNoRetrySucceededCreateRequest(ctx context.Context, options *LROsClientBeginPutAsyncNoRetrySucceededOptions) (*policy.Request, error) {
	urlPath := "/lro/putasync/noretry/succeeded"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, runtime.MarshalAsJSON(req, *options.Product)
	}
	return req, nil
}

// BeginPutAsyncNoRetrycanceled - Long running put request, service returns a 200 to the initial request, with an entity that
// contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROsClientBeginPutAsyncNoRetrycanceledOptions contains the optional parameters for the LROsClient.BeginPutAsyncNoRetrycanceled
// method.
func (client *LROsClient) BeginPutAsyncNoRetrycanceled(ctx context.Context, options *LROsClientBeginPutAsyncNoRetrycanceledOptions) (*LROsClientPutAsyncNoRetrycanceledPoller, error) {
	resp, err := client.putAsyncNoRetrycanceled(ctx, options)
	if err != nil {
		return nil, err
	}
	pt, err := armruntime.NewPoller("LROsClient.PutAsyncNoRetrycanceled", "", resp, client.pl)
	if err != nil {
		return nil, err
	}
	return &LROsClientPutAsyncNoRetrycanceledPoller{pt: pt}, nil
}

// PutAsyncNoRetrycanceled - Long running put request, service returns a 200 to the initial request, with an entity that contains
// ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROsClient) putAsyncNoRetrycanceled(ctx context.Context, options *LROsClientBeginPutAsyncNoRetrycanceledOptions) (*http.Response, error) {
	req, err := client.putAsyncNoRetrycanceledCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// putAsyncNoRetrycanceledCreateRequest creates the PutAsyncNoRetrycanceled request.
func (client *LROsClient) putAsyncNoRetrycanceledCreateRequest(ctx context.Context, options *LROsClientBeginPutAsyncNoRetrycanceledOptions) (*policy.Request, error) {
	urlPath := "/lro/putasync/noretry/canceled"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, runtime.MarshalAsJSON(req, *options.Product)
	}
	return req, nil
}

// BeginPutAsyncNonResource - Long running put request with non resource.
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROsClientBeginPutAsyncNonResourceOptions contains the optional parameters for the LROsClient.BeginPutAsyncNonResource
// method.
func (client *LROsClient) BeginPutAsyncNonResource(ctx context.Context, options *LROsClientBeginPutAsyncNonResourceOptions) (*LROsClientPutAsyncNonResourcePoller, error) {
	resp, err := client.putAsyncNonResource(ctx, options)
	if err != nil {
		return nil, err
	}
	pt, err := armruntime.NewPoller("LROsClient.PutAsyncNonResource", "", resp, client.pl)
	if err != nil {
		return nil, err
	}
	return &LROsClientPutAsyncNonResourcePoller{pt: pt}, nil
}

// PutAsyncNonResource - Long running put request with non resource.
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROsClient) putAsyncNonResource(ctx context.Context, options *LROsClientBeginPutAsyncNonResourceOptions) (*http.Response, error) {
	req, err := client.putAsyncNonResourceCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// putAsyncNonResourceCreateRequest creates the PutAsyncNonResource request.
func (client *LROsClient) putAsyncNonResourceCreateRequest(ctx context.Context, options *LROsClientBeginPutAsyncNonResourceOptions) (*policy.Request, error) {
	urlPath := "/lro/putnonresourceasync/202/200"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.SKU != nil {
		return req, runtime.MarshalAsJSON(req, *options.SKU)
	}
	return req, nil
}

// BeginPutAsyncRetryFailed - Long running put request, service returns a 200 to the initial request, with an entity that
// contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROsClientBeginPutAsyncRetryFailedOptions contains the optional parameters for the LROsClient.BeginPutAsyncRetryFailed
// method.
func (client *LROsClient) BeginPutAsyncRetryFailed(ctx context.Context, options *LROsClientBeginPutAsyncRetryFailedOptions) (*LROsClientPutAsyncRetryFailedPoller, error) {
	resp, err := client.putAsyncRetryFailed(ctx, options)
	if err != nil {
		return nil, err
	}
	pt, err := armruntime.NewPoller("LROsClient.PutAsyncRetryFailed", "", resp, client.pl)
	if err != nil {
		return nil, err
	}
	return &LROsClientPutAsyncRetryFailedPoller{pt: pt}, nil
}

// PutAsyncRetryFailed - Long running put request, service returns a 200 to the initial request, with an entity that contains
// ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROsClient) putAsyncRetryFailed(ctx context.Context, options *LROsClientBeginPutAsyncRetryFailedOptions) (*http.Response, error) {
	req, err := client.putAsyncRetryFailedCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// putAsyncRetryFailedCreateRequest creates the PutAsyncRetryFailed request.
func (client *LROsClient) putAsyncRetryFailedCreateRequest(ctx context.Context, options *LROsClientBeginPutAsyncRetryFailedOptions) (*policy.Request, error) {
	urlPath := "/lro/putasync/retry/failed"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, runtime.MarshalAsJSON(req, *options.Product)
	}
	return req, nil
}

// BeginPutAsyncRetrySucceeded - Long running put request, service returns a 200 to the initial request, with an entity that
// contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROsClientBeginPutAsyncRetrySucceededOptions contains the optional parameters for the LROsClient.BeginPutAsyncRetrySucceeded
// method.
func (client *LROsClient) BeginPutAsyncRetrySucceeded(ctx context.Context, options *LROsClientBeginPutAsyncRetrySucceededOptions) (*LROsClientPutAsyncRetrySucceededPoller, error) {
	resp, err := client.putAsyncRetrySucceeded(ctx, options)
	if err != nil {
		return nil, err
	}
	pt, err := armruntime.NewPoller("LROsClient.PutAsyncRetrySucceeded", "", resp, client.pl)
	if err != nil {
		return nil, err
	}
	return &LROsClientPutAsyncRetrySucceededPoller{pt: pt}, nil
}

// PutAsyncRetrySucceeded - Long running put request, service returns a 200 to the initial request, with an entity that contains
// ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROsClient) putAsyncRetrySucceeded(ctx context.Context, options *LROsClientBeginPutAsyncRetrySucceededOptions) (*http.Response, error) {
	req, err := client.putAsyncRetrySucceededCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// putAsyncRetrySucceededCreateRequest creates the PutAsyncRetrySucceeded request.
func (client *LROsClient) putAsyncRetrySucceededCreateRequest(ctx context.Context, options *LROsClientBeginPutAsyncRetrySucceededOptions) (*policy.Request, error) {
	urlPath := "/lro/putasync/retry/succeeded"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, runtime.MarshalAsJSON(req, *options.Product)
	}
	return req, nil
}

// BeginPutAsyncSubResource - Long running put request with sub resource.
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROsClientBeginPutAsyncSubResourceOptions contains the optional parameters for the LROsClient.BeginPutAsyncSubResource
// method.
func (client *LROsClient) BeginPutAsyncSubResource(ctx context.Context, options *LROsClientBeginPutAsyncSubResourceOptions) (*LROsClientPutAsyncSubResourcePoller, error) {
	resp, err := client.putAsyncSubResource(ctx, options)
	if err != nil {
		return nil, err
	}
	pt, err := armruntime.NewPoller("LROsClient.PutAsyncSubResource", "", resp, client.pl)
	if err != nil {
		return nil, err
	}
	return &LROsClientPutAsyncSubResourcePoller{pt: pt}, nil
}

// PutAsyncSubResource - Long running put request with sub resource.
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROsClient) putAsyncSubResource(ctx context.Context, options *LROsClientBeginPutAsyncSubResourceOptions) (*http.Response, error) {
	req, err := client.putAsyncSubResourceCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// putAsyncSubResourceCreateRequest creates the PutAsyncSubResource request.
func (client *LROsClient) putAsyncSubResourceCreateRequest(ctx context.Context, options *LROsClientBeginPutAsyncSubResourceOptions) (*policy.Request, error) {
	urlPath := "/lro/putsubresourceasync/202/200"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, runtime.MarshalAsJSON(req, *options.Product)
	}
	return req, nil
}

// BeginPutNoHeaderInRetry - Long running put request, service returns a 202 to the initial request with location header.
// Subsequent calls to operation status do not contain location header.
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROsClientBeginPutNoHeaderInRetryOptions contains the optional parameters for the LROsClient.BeginPutNoHeaderInRetry
// method.
func (client *LROsClient) BeginPutNoHeaderInRetry(ctx context.Context, options *LROsClientBeginPutNoHeaderInRetryOptions) (*LROsClientPutNoHeaderInRetryPoller, error) {
	resp, err := client.putNoHeaderInRetry(ctx, options)
	if err != nil {
		return nil, err
	}
	pt, err := armruntime.NewPoller("LROsClient.PutNoHeaderInRetry", "", resp, client.pl)
	if err != nil {
		return nil, err
	}
	return &LROsClientPutNoHeaderInRetryPoller{pt: pt}, nil
}

// PutNoHeaderInRetry - Long running put request, service returns a 202 to the initial request with location header. Subsequent
// calls to operation status do not contain location header.
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROsClient) putNoHeaderInRetry(ctx context.Context, options *LROsClientBeginPutNoHeaderInRetryOptions) (*http.Response, error) {
	req, err := client.putNoHeaderInRetryCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// putNoHeaderInRetryCreateRequest creates the PutNoHeaderInRetry request.
func (client *LROsClient) putNoHeaderInRetryCreateRequest(ctx context.Context, options *LROsClientBeginPutNoHeaderInRetryOptions) (*policy.Request, error) {
	urlPath := "/lro/put/noheader/202/200"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, runtime.MarshalAsJSON(req, *options.Product)
	}
	return req, nil
}

// BeginPutNonResource - Long running put request with non resource.
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROsClientBeginPutNonResourceOptions contains the optional parameters for the LROsClient.BeginPutNonResource
// method.
func (client *LROsClient) BeginPutNonResource(ctx context.Context, options *LROsClientBeginPutNonResourceOptions) (*LROsClientPutNonResourcePoller, error) {
	resp, err := client.putNonResource(ctx, options)
	if err != nil {
		return nil, err
	}
	pt, err := armruntime.NewPoller("LROsClient.PutNonResource", "", resp, client.pl)
	if err != nil {
		return nil, err
	}
	return &LROsClientPutNonResourcePoller{pt: pt}, nil
}

// PutNonResource - Long running put request with non resource.
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROsClient) putNonResource(ctx context.Context, options *LROsClientBeginPutNonResourceOptions) (*http.Response, error) {
	req, err := client.putNonResourceCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// putNonResourceCreateRequest creates the PutNonResource request.
func (client *LROsClient) putNonResourceCreateRequest(ctx context.Context, options *LROsClientBeginPutNonResourceOptions) (*policy.Request, error) {
	urlPath := "/lro/putnonresource/202/200"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.SKU != nil {
		return req, runtime.MarshalAsJSON(req, *options.SKU)
	}
	return req, nil
}

// BeginPutSubResource - Long running put request with sub resource.
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROsClientBeginPutSubResourceOptions contains the optional parameters for the LROsClient.BeginPutSubResource
// method.
func (client *LROsClient) BeginPutSubResource(ctx context.Context, options *LROsClientBeginPutSubResourceOptions) (*LROsClientPutSubResourcePoller, error) {
	resp, err := client.putSubResource(ctx, options)
	if err != nil {
		return nil, err
	}
	pt, err := armruntime.NewPoller("LROsClient.PutSubResource", "", resp, client.pl)
	if err != nil {
		return nil, err
	}
	return &LROsClientPutSubResourcePoller{pt: pt}, nil
}

// PutSubResource - Long running put request with sub resource.
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROsClient) putSubResource(ctx context.Context, options *LROsClientBeginPutSubResourceOptions) (*http.Response, error) {
	req, err := client.putSubResourceCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// putSubResourceCreateRequest creates the PutSubResource request.
func (client *LROsClient) putSubResourceCreateRequest(ctx context.Context, options *LROsClientBeginPutSubResourceOptions) (*policy.Request, error) {
	urlPath := "/lro/putsubresource/202/200"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, runtime.MarshalAsJSON(req, *options.Product)
	}
	return req, nil
}
