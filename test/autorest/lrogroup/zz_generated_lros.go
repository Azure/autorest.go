// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package lrogroup

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/armcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"time"
)

// LrOSOperations contains the methods for the LrOS group.
type LrOSOperations interface {
	// BeginDelete202NoRetry204 - Long running delete request, service returns a 202 to the initial request. Polls return this
	// value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
	BeginDelete202NoRetry204(ctx context.Context, options *LrOSDelete202NoRetry204Options) (*ProductPollerResponse, error)
	// ResumeDelete202NoRetry204 - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeDelete202NoRetry204(token string) (ProductPoller, error)
	// BeginDelete202Retry200 - Long running delete request, service returns a 202 to the initial request. Polls return this value
	// until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
	BeginDelete202Retry200(ctx context.Context, options *LrOSDelete202Retry200Options) (*ProductPollerResponse, error)
	// ResumeDelete202Retry200 - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeDelete202Retry200(token string) (ProductPoller, error)
	// BeginDelete204Succeeded - Long running delete succeeds and returns right away
	BeginDelete204Succeeded(ctx context.Context, options *LrOSDelete204SucceededOptions) (*HTTPPollerResponse, error)
	// ResumeDelete204Succeeded - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeDelete204Succeeded(token string) (HTTPPoller, error)
	// BeginDeleteAsyncNoHeaderInRetry - Long running delete request, service returns an Azure-AsyncOperation header in the initial
	// request. Subsequent calls to operation status do not contain Azure-AsyncOperation header.
	BeginDeleteAsyncNoHeaderInRetry(ctx context.Context, options *LrOSDeleteAsyncNoHeaderInRetryOptions) (*HTTPPollerResponse, error)
	// ResumeDeleteAsyncNoHeaderInRetry - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeDeleteAsyncNoHeaderInRetry(token string) (HTTPPoller, error)
	// BeginDeleteAsyncNoRetrySucceeded - Long running delete request, service returns a 202 to the initial request. Poll the
	// endpoint indicated in the Azure-AsyncOperation header for operation status
	BeginDeleteAsyncNoRetrySucceeded(ctx context.Context, options *LrOSDeleteAsyncNoRetrySucceededOptions) (*HTTPPollerResponse, error)
	// ResumeDeleteAsyncNoRetrySucceeded - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeDeleteAsyncNoRetrySucceeded(token string) (HTTPPoller, error)
	// BeginDeleteAsyncRetryFailed - Long running delete request, service returns a 202 to the initial request. Poll the endpoint
	// indicated in the Azure-AsyncOperation header for operation status
	BeginDeleteAsyncRetryFailed(ctx context.Context, options *LrOSDeleteAsyncRetryFailedOptions) (*HTTPPollerResponse, error)
	// ResumeDeleteAsyncRetryFailed - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeDeleteAsyncRetryFailed(token string) (HTTPPoller, error)
	// BeginDeleteAsyncRetrySucceeded - Long running delete request, service returns a 202 to the initial request. Poll the endpoint
	// indicated in the Azure-AsyncOperation header for operation status
	BeginDeleteAsyncRetrySucceeded(ctx context.Context, options *LrOSDeleteAsyncRetrySucceededOptions) (*HTTPPollerResponse, error)
	// ResumeDeleteAsyncRetrySucceeded - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeDeleteAsyncRetrySucceeded(token string) (HTTPPoller, error)
	// BeginDeleteAsyncRetrycanceled - Long running delete request, service returns a 202 to the initial request. Poll the endpoint
	// indicated in the Azure-AsyncOperation header for operation status
	BeginDeleteAsyncRetrycanceled(ctx context.Context, options *LrOSDeleteAsyncRetrycanceledOptions) (*HTTPPollerResponse, error)
	// ResumeDeleteAsyncRetrycanceled - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeDeleteAsyncRetrycanceled(token string) (HTTPPoller, error)
	// BeginDeleteNoHeaderInRetry - Long running delete request, service returns a location header in the initial request. Subsequent
	// calls to operation status do not contain location header.
	BeginDeleteNoHeaderInRetry(ctx context.Context, options *LrOSDeleteNoHeaderInRetryOptions) (*HTTPPollerResponse, error)
	// ResumeDeleteNoHeaderInRetry - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeDeleteNoHeaderInRetry(token string) (HTTPPoller, error)
	// BeginDeleteProvisioning202Accepted200Succeeded - Long running delete request, service returns a 202 to the initial request,
	// with an entity that contains ProvisioningState=’Accepted’. Polls return this value until the last poll returns a ‘200’
	// with
	// ProvisioningState=’Succeeded’
	BeginDeleteProvisioning202Accepted200Succeeded(ctx context.Context, options *LrOSDeleteProvisioning202Accepted200SucceededOptions) (*ProductPollerResponse, error)
	// ResumeDeleteProvisioning202Accepted200Succeeded - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeDeleteProvisioning202Accepted200Succeeded(token string) (ProductPoller, error)
	// BeginDeleteProvisioning202DeletingFailed200 - Long running delete request, service returns a 202 to the initial request,
	// with an entity that contains ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’
	// with
	// ProvisioningState=’Failed’
	BeginDeleteProvisioning202DeletingFailed200(ctx context.Context, options *LrOSDeleteProvisioning202DeletingFailed200Options) (*ProductPollerResponse, error)
	// ResumeDeleteProvisioning202DeletingFailed200 - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeDeleteProvisioning202DeletingFailed200(token string) (ProductPoller, error)
	// BeginDeleteProvisioning202Deletingcanceled200 - Long running delete request, service returns a 202 to the initial request,
	// with an entity that contains ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’
	// with
	// ProvisioningState=’Canceled’
	BeginDeleteProvisioning202Deletingcanceled200(ctx context.Context, options *LrOSDeleteProvisioning202Deletingcanceled200Options) (*ProductPollerResponse, error)
	// ResumeDeleteProvisioning202Deletingcanceled200 - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeDeleteProvisioning202Deletingcanceled200(token string) (ProductPoller, error)
	// BeginPost200WithPayload - Long running post request, service returns a 202 to the initial request, with 'Location' header.
	// Poll returns a 200 with a response body after success.
	BeginPost200WithPayload(ctx context.Context, options *LrOSPost200WithPayloadOptions) (*SKUPollerResponse, error)
	// ResumePost200WithPayload - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumePost200WithPayload(token string) (SKUPoller, error)
	// BeginPost202List - Long running put request, service returns a 202 with empty body to first request, returns a 200 with
	// body [{ 'id': '100', 'name': 'foo' }].
	BeginPost202List(ctx context.Context, options *LrOSPost202ListOptions) (*ProductArrayPollerResponse, error)
	// ResumePost202List - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumePost202List(token string) (ProductArrayPoller, error)
	// BeginPost202NoRetry204 - Long running post request, service returns a 202 to the initial request, with 'Location' header,
	// 204 with noresponse body after success
	BeginPost202NoRetry204(ctx context.Context, options *LrOSPost202NoRetry204Options) (*ProductPollerResponse, error)
	// ResumePost202NoRetry204 - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumePost202NoRetry204(token string) (ProductPoller, error)
	// BeginPost202Retry200 - Long running post request, service returns a 202 to the initial request, with 'Location' and 'Retry-After'
	// headers, Polls return a 200 with a response body after success
	BeginPost202Retry200(ctx context.Context, options *LrOSPost202Retry200Options) (*HTTPPollerResponse, error)
	// ResumePost202Retry200 - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumePost202Retry200(token string) (HTTPPoller, error)
	// BeginPostAsyncNoRetrySucceeded - Long running post request, service returns a 202 to the initial request, with an entity
	// that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
	// operation status
	BeginPostAsyncNoRetrySucceeded(ctx context.Context, options *LrOSPostAsyncNoRetrySucceededOptions) (*ProductPollerResponse, error)
	// ResumePostAsyncNoRetrySucceeded - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumePostAsyncNoRetrySucceeded(token string) (ProductPoller, error)
	// BeginPostAsyncRetryFailed - Long running post request, service returns a 202 to the initial request, with an entity that
	// contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
	// operation status
	BeginPostAsyncRetryFailed(ctx context.Context, options *LrOSPostAsyncRetryFailedOptions) (*HTTPPollerResponse, error)
	// ResumePostAsyncRetryFailed - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumePostAsyncRetryFailed(token string) (HTTPPoller, error)
	// BeginPostAsyncRetrySucceeded - Long running post request, service returns a 202 to the initial request, with an entity
	// that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
	// operation status
	BeginPostAsyncRetrySucceeded(ctx context.Context, options *LrOSPostAsyncRetrySucceededOptions) (*ProductPollerResponse, error)
	// ResumePostAsyncRetrySucceeded - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumePostAsyncRetrySucceeded(token string) (ProductPoller, error)
	// BeginPostAsyncRetrycanceled - Long running post request, service returns a 202 to the initial request, with an entity that
	// contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
	// operation status
	BeginPostAsyncRetrycanceled(ctx context.Context, options *LrOSPostAsyncRetrycanceledOptions) (*HTTPPollerResponse, error)
	// ResumePostAsyncRetrycanceled - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumePostAsyncRetrycanceled(token string) (HTTPPoller, error)
	// BeginPostDoubleHeadersFinalAzureHeaderGet - Long running post request, service returns a 202 to the initial request with
	// both Location and Azure-Async header. Poll Azure-Async and it's success. Should NOT poll Location to get the final object
	BeginPostDoubleHeadersFinalAzureHeaderGet(ctx context.Context, options *LrOSPostDoubleHeadersFinalAzureHeaderGetOptions) (*ProductPollerResponse, error)
	// ResumePostDoubleHeadersFinalAzureHeaderGet - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumePostDoubleHeadersFinalAzureHeaderGet(token string) (ProductPoller, error)
	// BeginPostDoubleHeadersFinalAzureHeaderGetDefault - Long running post request, service returns a 202 to the initial request
	// with both Location and Azure-Async header. Poll Azure-Async and it's success. Should NOT poll Location to get the final
	// object
	// if you support initial Autorest behavior.
	BeginPostDoubleHeadersFinalAzureHeaderGetDefault(ctx context.Context, options *LrOSPostDoubleHeadersFinalAzureHeaderGetDefaultOptions) (*ProductPollerResponse, error)
	// ResumePostDoubleHeadersFinalAzureHeaderGetDefault - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumePostDoubleHeadersFinalAzureHeaderGetDefault(token string) (ProductPoller, error)
	// BeginPostDoubleHeadersFinalLocationGet - Long running post request, service returns a 202 to the initial request with both
	// Location and Azure-Async header. Poll Azure-Async and it's success. Should poll Location to get the final object
	BeginPostDoubleHeadersFinalLocationGet(ctx context.Context, options *LrOSPostDoubleHeadersFinalLocationGetOptions) (*ProductPollerResponse, error)
	// ResumePostDoubleHeadersFinalLocationGet - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumePostDoubleHeadersFinalLocationGet(token string) (ProductPoller, error)
	// BeginPut200Acceptedcanceled200 - Long running put request, service returns a 201 to the initial request, with an entity
	// that contains ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’ with
	// ProvisioningState=’Canceled’
	BeginPut200Acceptedcanceled200(ctx context.Context, options *LrOSPut200Acceptedcanceled200Options) (*ProductPollerResponse, error)
	// ResumePut200Acceptedcanceled200 - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumePut200Acceptedcanceled200(token string) (ProductPoller, error)
	// BeginPut200Succeeded - Long running put request, service returns a 200 to the initial request, with an entity that contains
	// ProvisioningState=’Succeeded’.
	BeginPut200Succeeded(ctx context.Context, options *LrOSPut200SucceededOptions) (*ProductPollerResponse, error)
	// ResumePut200Succeeded - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumePut200Succeeded(token string) (ProductPoller, error)
	// BeginPut200SucceededNoState - Long running put request, service returns a 200 to the initial request, with an entity that
	// does not contain ProvisioningState=’Succeeded’.
	BeginPut200SucceededNoState(ctx context.Context, options *LrOSPut200SucceededNoStateOptions) (*ProductPollerResponse, error)
	// ResumePut200SucceededNoState - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumePut200SucceededNoState(token string) (ProductPoller, error)
	// BeginPut200UpdatingSucceeded204 - Long running put request, service returns a 201 to the initial request, with an entity
	// that contains ProvisioningState=’Updating’. Polls return this value until the last poll returns a ‘200’ with
	// ProvisioningState=’Succeeded’
	BeginPut200UpdatingSucceeded204(ctx context.Context, options *LrOSPut200UpdatingSucceeded204Options) (*ProductPollerResponse, error)
	// ResumePut200UpdatingSucceeded204 - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumePut200UpdatingSucceeded204(token string) (ProductPoller, error)
	// BeginPut201CreatingFailed200 - Long running put request, service returns a 201 to the initial request, with an entity that
	// contains ProvisioningState=’Created’. Polls return this value until the last poll returns a ‘200’ with
	// ProvisioningState=’Failed’
	BeginPut201CreatingFailed200(ctx context.Context, options *LrOSPut201CreatingFailed200Options) (*ProductPollerResponse, error)
	// ResumePut201CreatingFailed200 - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumePut201CreatingFailed200(token string) (ProductPoller, error)
	// BeginPut201CreatingSucceeded200 - Long running put request, service returns a 201 to the initial request, with an entity
	// that contains ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’ with
	// ProvisioningState=’Succeeded’
	BeginPut201CreatingSucceeded200(ctx context.Context, options *LrOSPut201CreatingSucceeded200Options) (*ProductPollerResponse, error)
	// ResumePut201CreatingSucceeded200 - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumePut201CreatingSucceeded200(token string) (ProductPoller, error)
	// BeginPut201Succeeded - Long running put request, service returns a 201 to the initial request, with an entity that contains
	// ProvisioningState=’Succeeded’.
	BeginPut201Succeeded(ctx context.Context, options *LrOSPut201SucceededOptions) (*ProductPollerResponse, error)
	// ResumePut201Succeeded - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumePut201Succeeded(token string) (ProductPoller, error)
	// BeginPut202Retry200 - Long running put request, service returns a 202 to the initial request, with a location header that
	// points to a polling URL that returns a 200 and an entity that doesn't contains ProvisioningState
	BeginPut202Retry200(ctx context.Context, options *LrOSPut202Retry200Options) (*ProductPollerResponse, error)
	// ResumePut202Retry200 - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumePut202Retry200(token string) (ProductPoller, error)
	// BeginPutAsyncNoHeaderInRetry - Long running put request, service returns a 202 to the initial request with Azure-AsyncOperation
	// header. Subsequent calls to operation status do not contain Azure-AsyncOperation header.
	BeginPutAsyncNoHeaderInRetry(ctx context.Context, options *LrOSPutAsyncNoHeaderInRetryOptions) (*ProductPollerResponse, error)
	// ResumePutAsyncNoHeaderInRetry - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumePutAsyncNoHeaderInRetry(token string) (ProductPoller, error)
	// BeginPutAsyncNoRetrySucceeded - Long running put request, service returns a 200 to the initial request, with an entity
	// that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
	// operation status
	BeginPutAsyncNoRetrySucceeded(ctx context.Context, options *LrOSPutAsyncNoRetrySucceededOptions) (*ProductPollerResponse, error)
	// ResumePutAsyncNoRetrySucceeded - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumePutAsyncNoRetrySucceeded(token string) (ProductPoller, error)
	// BeginPutAsyncNoRetrycanceled - Long running put request, service returns a 200 to the initial request, with an entity that
	// contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
	// operation status
	BeginPutAsyncNoRetrycanceled(ctx context.Context, options *LrOSPutAsyncNoRetrycanceledOptions) (*ProductPollerResponse, error)
	// ResumePutAsyncNoRetrycanceled - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumePutAsyncNoRetrycanceled(token string) (ProductPoller, error)
	// BeginPutAsyncNonResource - Long running put request with non resource.
	BeginPutAsyncNonResource(ctx context.Context, options *LrOSPutAsyncNonResourceOptions) (*SKUPollerResponse, error)
	// ResumePutAsyncNonResource - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumePutAsyncNonResource(token string) (SKUPoller, error)
	// BeginPutAsyncRetryFailed - Long running put request, service returns a 200 to the initial request, with an entity that
	// contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
	// operation status
	BeginPutAsyncRetryFailed(ctx context.Context, options *LrOSPutAsyncRetryFailedOptions) (*ProductPollerResponse, error)
	// ResumePutAsyncRetryFailed - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumePutAsyncRetryFailed(token string) (ProductPoller, error)
	// BeginPutAsyncRetrySucceeded - Long running put request, service returns a 200 to the initial request, with an entity that
	// contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
	// operation status
	BeginPutAsyncRetrySucceeded(ctx context.Context, options *LrOSPutAsyncRetrySucceededOptions) (*ProductPollerResponse, error)
	// ResumePutAsyncRetrySucceeded - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumePutAsyncRetrySucceeded(token string) (ProductPoller, error)
	// BeginPutAsyncSubResource - Long running put request with sub resource.
	BeginPutAsyncSubResource(ctx context.Context, options *LrOSPutAsyncSubResourceOptions) (*SubProductPollerResponse, error)
	// ResumePutAsyncSubResource - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumePutAsyncSubResource(token string) (SubProductPoller, error)
	// BeginPutNoHeaderInRetry - Long running put request, service returns a 202 to the initial request with location header.
	// Subsequent calls to operation status do not contain location header.
	BeginPutNoHeaderInRetry(ctx context.Context, options *LrOSPutNoHeaderInRetryOptions) (*ProductPollerResponse, error)
	// ResumePutNoHeaderInRetry - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumePutNoHeaderInRetry(token string) (ProductPoller, error)
	// BeginPutNonResource - Long running put request with non resource.
	BeginPutNonResource(ctx context.Context, options *LrOSPutNonResourceOptions) (*SKUPollerResponse, error)
	// ResumePutNonResource - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumePutNonResource(token string) (SKUPoller, error)
	// BeginPutSubResource - Long running put request with sub resource.
	BeginPutSubResource(ctx context.Context, options *LrOSPutSubResourceOptions) (*SubProductPollerResponse, error)
	// ResumePutSubResource - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumePutSubResource(token string) (SubProductPoller, error)
}

// LrOSClient implements the LrOSOperations interface.
// Don't use this type directly, use NewLrOSClient() instead.
type LrOSClient struct {
	*Client
}

// NewLrOSClient creates a new instance of LrOSClient with the specified values.
func NewLrOSClient(c *Client) LrOSOperations {
	return &LrOSClient{Client: c}
}

// Do invokes the Do() method on the pipeline associated with this client.
func (client *LrOSClient) Do(req *azcore.Request) (*azcore.Response, error) {
	return client.p.Do(req)
}

func (client *LrOSClient) BeginDelete202NoRetry204(ctx context.Context, options *LrOSDelete202NoRetry204Options) (*ProductPollerResponse, error) {
	resp, err := client.Delete202NoRetry204(ctx, options)
	if err != nil {
		return nil, err
	}
	result := &ProductPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LrOSClient.Delete202NoRetry204", "", resp, client.Delete202NoRetry204HandleError)
	if err != nil {
		return nil, err
	}
	poller := &productPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *LrOSClient) ResumeDelete202NoRetry204(token string) (ProductPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("LrOSClient.Delete202NoRetry204", token, client.Delete202NoRetry204HandleError)
	if err != nil {
		return nil, err
	}
	return &productPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// Delete202NoRetry204 - Long running delete request, service returns a 202 to the initial request. Polls return this value until the last poll returns
// a ‘200’ with ProvisioningState=’Succeeded’
func (client *LrOSClient) Delete202NoRetry204(ctx context.Context, options *LrOSDelete202NoRetry204Options) (*azcore.Response, error) {
	req, err := client.Delete202NoRetry204CreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.Delete202NoRetry204HandleError(resp)
	}
	return resp, nil
}

// Delete202NoRetry204CreateRequest creates the Delete202NoRetry204 request.
func (client *LrOSClient) Delete202NoRetry204CreateRequest(ctx context.Context, options *LrOSDelete202NoRetry204Options) (*azcore.Request, error) {
	urlPath := "/lro/delete/202/noretry/204"
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// Delete202NoRetry204HandleResponse handles the Delete202NoRetry204 response.
func (client *LrOSClient) Delete202NoRetry204HandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// Delete202NoRetry204HandleError handles the Delete202NoRetry204 error response.
func (client *LrOSClient) Delete202NoRetry204HandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *LrOSClient) BeginDelete202Retry200(ctx context.Context, options *LrOSDelete202Retry200Options) (*ProductPollerResponse, error) {
	resp, err := client.Delete202Retry200(ctx, options)
	if err != nil {
		return nil, err
	}
	result := &ProductPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LrOSClient.Delete202Retry200", "", resp, client.Delete202Retry200HandleError)
	if err != nil {
		return nil, err
	}
	poller := &productPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *LrOSClient) ResumeDelete202Retry200(token string) (ProductPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("LrOSClient.Delete202Retry200", token, client.Delete202Retry200HandleError)
	if err != nil {
		return nil, err
	}
	return &productPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// Delete202Retry200 - Long running delete request, service returns a 202 to the initial request. Polls return this value until the last poll returns a
// ‘200’ with ProvisioningState=’Succeeded’
func (client *LrOSClient) Delete202Retry200(ctx context.Context, options *LrOSDelete202Retry200Options) (*azcore.Response, error) {
	req, err := client.Delete202Retry200CreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.Delete202Retry200HandleError(resp)
	}
	return resp, nil
}

// Delete202Retry200CreateRequest creates the Delete202Retry200 request.
func (client *LrOSClient) Delete202Retry200CreateRequest(ctx context.Context, options *LrOSDelete202Retry200Options) (*azcore.Request, error) {
	urlPath := "/lro/delete/202/retry/200"
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// Delete202Retry200HandleResponse handles the Delete202Retry200 response.
func (client *LrOSClient) Delete202Retry200HandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// Delete202Retry200HandleError handles the Delete202Retry200 error response.
func (client *LrOSClient) Delete202Retry200HandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *LrOSClient) BeginDelete204Succeeded(ctx context.Context, options *LrOSDelete204SucceededOptions) (*HTTPPollerResponse, error) {
	resp, err := client.Delete204Succeeded(ctx, options)
	if err != nil {
		return nil, err
	}
	result := &HTTPPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LrOSClient.Delete204Succeeded", "", resp, client.Delete204SucceededHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *LrOSClient) ResumeDelete204Succeeded(token string) (HTTPPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("LrOSClient.Delete204Succeeded", token, client.Delete204SucceededHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// Delete204Succeeded - Long running delete succeeds and returns right away
func (client *LrOSClient) Delete204Succeeded(ctx context.Context, options *LrOSDelete204SucceededOptions) (*azcore.Response, error) {
	req, err := client.Delete204SucceededCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusNoContent) {
		return nil, client.Delete204SucceededHandleError(resp)
	}
	return resp, nil
}

// Delete204SucceededCreateRequest creates the Delete204Succeeded request.
func (client *LrOSClient) Delete204SucceededCreateRequest(ctx context.Context, options *LrOSDelete204SucceededOptions) (*azcore.Request, error) {
	urlPath := "/lro/delete/204/succeeded"
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// Delete204SucceededHandleError handles the Delete204Succeeded error response.
func (client *LrOSClient) Delete204SucceededHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *LrOSClient) BeginDeleteAsyncNoHeaderInRetry(ctx context.Context, options *LrOSDeleteAsyncNoHeaderInRetryOptions) (*HTTPPollerResponse, error) {
	resp, err := client.DeleteAsyncNoHeaderInRetry(ctx, options)
	if err != nil {
		return nil, err
	}
	result := &HTTPPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LrOSClient.DeleteAsyncNoHeaderInRetry", "", resp, client.DeleteAsyncNoHeaderInRetryHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *LrOSClient) ResumeDeleteAsyncNoHeaderInRetry(token string) (HTTPPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("LrOSClient.DeleteAsyncNoHeaderInRetry", token, client.DeleteAsyncNoHeaderInRetryHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// DeleteAsyncNoHeaderInRetry - Long running delete request, service returns an Azure-AsyncOperation header in the initial request. Subsequent calls to
// operation status do not contain Azure-AsyncOperation header.
func (client *LrOSClient) DeleteAsyncNoHeaderInRetry(ctx context.Context, options *LrOSDeleteAsyncNoHeaderInRetryOptions) (*azcore.Response, error) {
	req, err := client.DeleteAsyncNoHeaderInRetryCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted, http.StatusNoContent) {
		return nil, client.DeleteAsyncNoHeaderInRetryHandleError(resp)
	}
	return resp, nil
}

// DeleteAsyncNoHeaderInRetryCreateRequest creates the DeleteAsyncNoHeaderInRetry request.
func (client *LrOSClient) DeleteAsyncNoHeaderInRetryCreateRequest(ctx context.Context, options *LrOSDeleteAsyncNoHeaderInRetryOptions) (*azcore.Request, error) {
	urlPath := "/lro/deleteasync/noheader/202/204"
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// DeleteAsyncNoHeaderInRetryHandleError handles the DeleteAsyncNoHeaderInRetry error response.
func (client *LrOSClient) DeleteAsyncNoHeaderInRetryHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *LrOSClient) BeginDeleteAsyncNoRetrySucceeded(ctx context.Context, options *LrOSDeleteAsyncNoRetrySucceededOptions) (*HTTPPollerResponse, error) {
	resp, err := client.DeleteAsyncNoRetrySucceeded(ctx, options)
	if err != nil {
		return nil, err
	}
	result := &HTTPPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LrOSClient.DeleteAsyncNoRetrySucceeded", "", resp, client.DeleteAsyncNoRetrySucceededHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *LrOSClient) ResumeDeleteAsyncNoRetrySucceeded(token string) (HTTPPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("LrOSClient.DeleteAsyncNoRetrySucceeded", token, client.DeleteAsyncNoRetrySucceededHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// DeleteAsyncNoRetrySucceeded - Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation
// header for operation status
func (client *LrOSClient) DeleteAsyncNoRetrySucceeded(ctx context.Context, options *LrOSDeleteAsyncNoRetrySucceededOptions) (*azcore.Response, error) {
	req, err := client.DeleteAsyncNoRetrySucceededCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, client.DeleteAsyncNoRetrySucceededHandleError(resp)
	}
	return resp, nil
}

// DeleteAsyncNoRetrySucceededCreateRequest creates the DeleteAsyncNoRetrySucceeded request.
func (client *LrOSClient) DeleteAsyncNoRetrySucceededCreateRequest(ctx context.Context, options *LrOSDeleteAsyncNoRetrySucceededOptions) (*azcore.Request, error) {
	urlPath := "/lro/deleteasync/noretry/succeeded"
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// DeleteAsyncNoRetrySucceededHandleError handles the DeleteAsyncNoRetrySucceeded error response.
func (client *LrOSClient) DeleteAsyncNoRetrySucceededHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *LrOSClient) BeginDeleteAsyncRetryFailed(ctx context.Context, options *LrOSDeleteAsyncRetryFailedOptions) (*HTTPPollerResponse, error) {
	resp, err := client.DeleteAsyncRetryFailed(ctx, options)
	if err != nil {
		return nil, err
	}
	result := &HTTPPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LrOSClient.DeleteAsyncRetryFailed", "", resp, client.DeleteAsyncRetryFailedHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *LrOSClient) ResumeDeleteAsyncRetryFailed(token string) (HTTPPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("LrOSClient.DeleteAsyncRetryFailed", token, client.DeleteAsyncRetryFailedHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// DeleteAsyncRetryFailed - Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation
// header for operation status
func (client *LrOSClient) DeleteAsyncRetryFailed(ctx context.Context, options *LrOSDeleteAsyncRetryFailedOptions) (*azcore.Response, error) {
	req, err := client.DeleteAsyncRetryFailedCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, client.DeleteAsyncRetryFailedHandleError(resp)
	}
	return resp, nil
}

// DeleteAsyncRetryFailedCreateRequest creates the DeleteAsyncRetryFailed request.
func (client *LrOSClient) DeleteAsyncRetryFailedCreateRequest(ctx context.Context, options *LrOSDeleteAsyncRetryFailedOptions) (*azcore.Request, error) {
	urlPath := "/lro/deleteasync/retry/failed"
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// DeleteAsyncRetryFailedHandleError handles the DeleteAsyncRetryFailed error response.
func (client *LrOSClient) DeleteAsyncRetryFailedHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *LrOSClient) BeginDeleteAsyncRetrySucceeded(ctx context.Context, options *LrOSDeleteAsyncRetrySucceededOptions) (*HTTPPollerResponse, error) {
	resp, err := client.DeleteAsyncRetrySucceeded(ctx, options)
	if err != nil {
		return nil, err
	}
	result := &HTTPPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LrOSClient.DeleteAsyncRetrySucceeded", "", resp, client.DeleteAsyncRetrySucceededHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *LrOSClient) ResumeDeleteAsyncRetrySucceeded(token string) (HTTPPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("LrOSClient.DeleteAsyncRetrySucceeded", token, client.DeleteAsyncRetrySucceededHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// DeleteAsyncRetrySucceeded - Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation
// header for operation status
func (client *LrOSClient) DeleteAsyncRetrySucceeded(ctx context.Context, options *LrOSDeleteAsyncRetrySucceededOptions) (*azcore.Response, error) {
	req, err := client.DeleteAsyncRetrySucceededCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, client.DeleteAsyncRetrySucceededHandleError(resp)
	}
	return resp, nil
}

// DeleteAsyncRetrySucceededCreateRequest creates the DeleteAsyncRetrySucceeded request.
func (client *LrOSClient) DeleteAsyncRetrySucceededCreateRequest(ctx context.Context, options *LrOSDeleteAsyncRetrySucceededOptions) (*azcore.Request, error) {
	urlPath := "/lro/deleteasync/retry/succeeded"
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// DeleteAsyncRetrySucceededHandleError handles the DeleteAsyncRetrySucceeded error response.
func (client *LrOSClient) DeleteAsyncRetrySucceededHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *LrOSClient) BeginDeleteAsyncRetrycanceled(ctx context.Context, options *LrOSDeleteAsyncRetrycanceledOptions) (*HTTPPollerResponse, error) {
	resp, err := client.DeleteAsyncRetrycanceled(ctx, options)
	if err != nil {
		return nil, err
	}
	result := &HTTPPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LrOSClient.DeleteAsyncRetrycanceled", "", resp, client.DeleteAsyncRetrycanceledHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *LrOSClient) ResumeDeleteAsyncRetrycanceled(token string) (HTTPPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("LrOSClient.DeleteAsyncRetrycanceled", token, client.DeleteAsyncRetrycanceledHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// DeleteAsyncRetrycanceled - Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation
// header for operation status
func (client *LrOSClient) DeleteAsyncRetrycanceled(ctx context.Context, options *LrOSDeleteAsyncRetrycanceledOptions) (*azcore.Response, error) {
	req, err := client.DeleteAsyncRetrycanceledCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, client.DeleteAsyncRetrycanceledHandleError(resp)
	}
	return resp, nil
}

// DeleteAsyncRetrycanceledCreateRequest creates the DeleteAsyncRetrycanceled request.
func (client *LrOSClient) DeleteAsyncRetrycanceledCreateRequest(ctx context.Context, options *LrOSDeleteAsyncRetrycanceledOptions) (*azcore.Request, error) {
	urlPath := "/lro/deleteasync/retry/canceled"
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// DeleteAsyncRetrycanceledHandleError handles the DeleteAsyncRetrycanceled error response.
func (client *LrOSClient) DeleteAsyncRetrycanceledHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *LrOSClient) BeginDeleteNoHeaderInRetry(ctx context.Context, options *LrOSDeleteNoHeaderInRetryOptions) (*HTTPPollerResponse, error) {
	resp, err := client.DeleteNoHeaderInRetry(ctx, options)
	if err != nil {
		return nil, err
	}
	result := &HTTPPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LrOSClient.DeleteNoHeaderInRetry", "", resp, client.DeleteNoHeaderInRetryHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *LrOSClient) ResumeDeleteNoHeaderInRetry(token string) (HTTPPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("LrOSClient.DeleteNoHeaderInRetry", token, client.DeleteNoHeaderInRetryHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// DeleteNoHeaderInRetry - Long running delete request, service returns a location header in the initial request. Subsequent calls to operation status do
// not contain location header.
func (client *LrOSClient) DeleteNoHeaderInRetry(ctx context.Context, options *LrOSDeleteNoHeaderInRetryOptions) (*azcore.Response, error) {
	req, err := client.DeleteNoHeaderInRetryCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted, http.StatusNoContent) {
		return nil, client.DeleteNoHeaderInRetryHandleError(resp)
	}
	return resp, nil
}

// DeleteNoHeaderInRetryCreateRequest creates the DeleteNoHeaderInRetry request.
func (client *LrOSClient) DeleteNoHeaderInRetryCreateRequest(ctx context.Context, options *LrOSDeleteNoHeaderInRetryOptions) (*azcore.Request, error) {
	urlPath := "/lro/delete/noheader"
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// DeleteNoHeaderInRetryHandleError handles the DeleteNoHeaderInRetry error response.
func (client *LrOSClient) DeleteNoHeaderInRetryHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *LrOSClient) BeginDeleteProvisioning202Accepted200Succeeded(ctx context.Context, options *LrOSDeleteProvisioning202Accepted200SucceededOptions) (*ProductPollerResponse, error) {
	resp, err := client.DeleteProvisioning202Accepted200Succeeded(ctx, options)
	if err != nil {
		return nil, err
	}
	result := &ProductPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LrOSClient.DeleteProvisioning202Accepted200Succeeded", "", resp, client.DeleteProvisioning202Accepted200SucceededHandleError)
	if err != nil {
		return nil, err
	}
	poller := &productPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *LrOSClient) ResumeDeleteProvisioning202Accepted200Succeeded(token string) (ProductPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("LrOSClient.DeleteProvisioning202Accepted200Succeeded", token, client.DeleteProvisioning202Accepted200SucceededHandleError)
	if err != nil {
		return nil, err
	}
	return &productPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// DeleteProvisioning202Accepted200Succeeded - Long running delete request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Accepted’.
// Polls return this value until the last poll returns a ‘200’ with
// ProvisioningState=’Succeeded’
func (client *LrOSClient) DeleteProvisioning202Accepted200Succeeded(ctx context.Context, options *LrOSDeleteProvisioning202Accepted200SucceededOptions) (*azcore.Response, error) {
	req, err := client.DeleteProvisioning202Accepted200SucceededCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.DeleteProvisioning202Accepted200SucceededHandleError(resp)
	}
	return resp, nil
}

// DeleteProvisioning202Accepted200SucceededCreateRequest creates the DeleteProvisioning202Accepted200Succeeded request.
func (client *LrOSClient) DeleteProvisioning202Accepted200SucceededCreateRequest(ctx context.Context, options *LrOSDeleteProvisioning202Accepted200SucceededOptions) (*azcore.Request, error) {
	urlPath := "/lro/delete/provisioning/202/accepted/200/succeeded"
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// DeleteProvisioning202Accepted200SucceededHandleResponse handles the DeleteProvisioning202Accepted200Succeeded response.
func (client *LrOSClient) DeleteProvisioning202Accepted200SucceededHandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// DeleteProvisioning202Accepted200SucceededHandleError handles the DeleteProvisioning202Accepted200Succeeded error response.
func (client *LrOSClient) DeleteProvisioning202Accepted200SucceededHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *LrOSClient) BeginDeleteProvisioning202DeletingFailed200(ctx context.Context, options *LrOSDeleteProvisioning202DeletingFailed200Options) (*ProductPollerResponse, error) {
	resp, err := client.DeleteProvisioning202DeletingFailed200(ctx, options)
	if err != nil {
		return nil, err
	}
	result := &ProductPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LrOSClient.DeleteProvisioning202DeletingFailed200", "", resp, client.DeleteProvisioning202DeletingFailed200HandleError)
	if err != nil {
		return nil, err
	}
	poller := &productPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *LrOSClient) ResumeDeleteProvisioning202DeletingFailed200(token string) (ProductPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("LrOSClient.DeleteProvisioning202DeletingFailed200", token, client.DeleteProvisioning202DeletingFailed200HandleError)
	if err != nil {
		return nil, err
	}
	return &productPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// DeleteProvisioning202DeletingFailed200 - Long running delete request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’.
// Polls return this value until the last poll returns a ‘200’ with
// ProvisioningState=’Failed’
func (client *LrOSClient) DeleteProvisioning202DeletingFailed200(ctx context.Context, options *LrOSDeleteProvisioning202DeletingFailed200Options) (*azcore.Response, error) {
	req, err := client.DeleteProvisioning202DeletingFailed200CreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.DeleteProvisioning202DeletingFailed200HandleError(resp)
	}
	return resp, nil
}

// DeleteProvisioning202DeletingFailed200CreateRequest creates the DeleteProvisioning202DeletingFailed200 request.
func (client *LrOSClient) DeleteProvisioning202DeletingFailed200CreateRequest(ctx context.Context, options *LrOSDeleteProvisioning202DeletingFailed200Options) (*azcore.Request, error) {
	urlPath := "/lro/delete/provisioning/202/deleting/200/failed"
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// DeleteProvisioning202DeletingFailed200HandleResponse handles the DeleteProvisioning202DeletingFailed200 response.
func (client *LrOSClient) DeleteProvisioning202DeletingFailed200HandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// DeleteProvisioning202DeletingFailed200HandleError handles the DeleteProvisioning202DeletingFailed200 error response.
func (client *LrOSClient) DeleteProvisioning202DeletingFailed200HandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *LrOSClient) BeginDeleteProvisioning202Deletingcanceled200(ctx context.Context, options *LrOSDeleteProvisioning202Deletingcanceled200Options) (*ProductPollerResponse, error) {
	resp, err := client.DeleteProvisioning202Deletingcanceled200(ctx, options)
	if err != nil {
		return nil, err
	}
	result := &ProductPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LrOSClient.DeleteProvisioning202Deletingcanceled200", "", resp, client.DeleteProvisioning202Deletingcanceled200HandleError)
	if err != nil {
		return nil, err
	}
	poller := &productPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *LrOSClient) ResumeDeleteProvisioning202Deletingcanceled200(token string) (ProductPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("LrOSClient.DeleteProvisioning202Deletingcanceled200", token, client.DeleteProvisioning202Deletingcanceled200HandleError)
	if err != nil {
		return nil, err
	}
	return &productPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// DeleteProvisioning202Deletingcanceled200 - Long running delete request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’.
// Polls return this value until the last poll returns a ‘200’ with
// ProvisioningState=’Canceled’
func (client *LrOSClient) DeleteProvisioning202Deletingcanceled200(ctx context.Context, options *LrOSDeleteProvisioning202Deletingcanceled200Options) (*azcore.Response, error) {
	req, err := client.DeleteProvisioning202Deletingcanceled200CreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.DeleteProvisioning202Deletingcanceled200HandleError(resp)
	}
	return resp, nil
}

// DeleteProvisioning202Deletingcanceled200CreateRequest creates the DeleteProvisioning202Deletingcanceled200 request.
func (client *LrOSClient) DeleteProvisioning202Deletingcanceled200CreateRequest(ctx context.Context, options *LrOSDeleteProvisioning202Deletingcanceled200Options) (*azcore.Request, error) {
	urlPath := "/lro/delete/provisioning/202/deleting/200/canceled"
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// DeleteProvisioning202Deletingcanceled200HandleResponse handles the DeleteProvisioning202Deletingcanceled200 response.
func (client *LrOSClient) DeleteProvisioning202Deletingcanceled200HandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// DeleteProvisioning202Deletingcanceled200HandleError handles the DeleteProvisioning202Deletingcanceled200 error response.
func (client *LrOSClient) DeleteProvisioning202Deletingcanceled200HandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *LrOSClient) BeginPost200WithPayload(ctx context.Context, options *LrOSPost200WithPayloadOptions) (*SKUPollerResponse, error) {
	resp, err := client.Post200WithPayload(ctx, options)
	if err != nil {
		return nil, err
	}
	result := &SKUPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LrOSClient.Post200WithPayload", "", resp, client.Post200WithPayloadHandleError)
	if err != nil {
		return nil, err
	}
	poller := &skuPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*SKUResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *LrOSClient) ResumePost200WithPayload(token string) (SKUPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("LrOSClient.Post200WithPayload", token, client.Post200WithPayloadHandleError)
	if err != nil {
		return nil, err
	}
	return &skuPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// Post200WithPayload - Long running post request, service returns a 202 to the initial request, with 'Location' header. Poll returns a 200 with a response
// body after success.
func (client *LrOSClient) Post200WithPayload(ctx context.Context, options *LrOSPost200WithPayloadOptions) (*azcore.Response, error) {
	req, err := client.Post200WithPayloadCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.Post200WithPayloadHandleError(resp)
	}
	return resp, nil
}

// Post200WithPayloadCreateRequest creates the Post200WithPayload request.
func (client *LrOSClient) Post200WithPayloadCreateRequest(ctx context.Context, options *LrOSPost200WithPayloadOptions) (*azcore.Request, error) {
	urlPath := "/lro/post/payload/200"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// Post200WithPayloadHandleResponse handles the Post200WithPayload response.
func (client *LrOSClient) Post200WithPayloadHandleResponse(resp *azcore.Response) (*SKUResponse, error) {
	result := SKUResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.SKU)
}

// Post200WithPayloadHandleError handles the Post200WithPayload error response.
func (client *LrOSClient) Post200WithPayloadHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *LrOSClient) BeginPost202List(ctx context.Context, options *LrOSPost202ListOptions) (*ProductArrayPollerResponse, error) {
	resp, err := client.Post202List(ctx, options)
	if err != nil {
		return nil, err
	}
	result := &ProductArrayPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LrOSClient.Post202List", "", resp, client.Post202ListHandleError)
	if err != nil {
		return nil, err
	}
	poller := &productArrayPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*ProductArrayResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *LrOSClient) ResumePost202List(token string) (ProductArrayPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("LrOSClient.Post202List", token, client.Post202ListHandleError)
	if err != nil {
		return nil, err
	}
	return &productArrayPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// Post202List - Long running put request, service returns a 202 with empty body to first request, returns a 200 with body [{ 'id': '100', 'name': 'foo'
// }].
func (client *LrOSClient) Post202List(ctx context.Context, options *LrOSPost202ListOptions) (*azcore.Response, error) {
	req, err := client.Post202ListCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.Post202ListHandleError(resp)
	}
	return resp, nil
}

// Post202ListCreateRequest creates the Post202List request.
func (client *LrOSClient) Post202ListCreateRequest(ctx context.Context, options *LrOSPost202ListOptions) (*azcore.Request, error) {
	urlPath := "/lro/list"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// Post202ListHandleResponse handles the Post202List response.
func (client *LrOSClient) Post202ListHandleResponse(resp *azcore.Response) (*ProductArrayResponse, error) {
	result := ProductArrayResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ProductArray)
}

// Post202ListHandleError handles the Post202List error response.
func (client *LrOSClient) Post202ListHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *LrOSClient) BeginPost202NoRetry204(ctx context.Context, options *LrOSPost202NoRetry204Options) (*ProductPollerResponse, error) {
	resp, err := client.Post202NoRetry204(ctx, options)
	if err != nil {
		return nil, err
	}
	result := &ProductPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LrOSClient.Post202NoRetry204", "", resp, client.Post202NoRetry204HandleError)
	if err != nil {
		return nil, err
	}
	poller := &productPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *LrOSClient) ResumePost202NoRetry204(token string) (ProductPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("LrOSClient.Post202NoRetry204", token, client.Post202NoRetry204HandleError)
	if err != nil {
		return nil, err
	}
	return &productPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// Post202NoRetry204 - Long running post request, service returns a 202 to the initial request, with 'Location' header, 204 with noresponse body after success
func (client *LrOSClient) Post202NoRetry204(ctx context.Context, options *LrOSPost202NoRetry204Options) (*azcore.Response, error) {
	req, err := client.Post202NoRetry204CreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, client.Post202NoRetry204HandleError(resp)
	}
	return resp, nil
}

// Post202NoRetry204CreateRequest creates the Post202NoRetry204 request.
func (client *LrOSClient) Post202NoRetry204CreateRequest(ctx context.Context, options *LrOSPost202NoRetry204Options) (*azcore.Request, error) {
	urlPath := "/lro/post/202/noretry/204"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	if options != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// Post202NoRetry204HandleResponse handles the Post202NoRetry204 response.
func (client *LrOSClient) Post202NoRetry204HandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// Post202NoRetry204HandleError handles the Post202NoRetry204 error response.
func (client *LrOSClient) Post202NoRetry204HandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *LrOSClient) BeginPost202Retry200(ctx context.Context, options *LrOSPost202Retry200Options) (*HTTPPollerResponse, error) {
	resp, err := client.Post202Retry200(ctx, options)
	if err != nil {
		return nil, err
	}
	result := &HTTPPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LrOSClient.Post202Retry200", "", resp, client.Post202Retry200HandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *LrOSClient) ResumePost202Retry200(token string) (HTTPPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("LrOSClient.Post202Retry200", token, client.Post202Retry200HandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// Post202Retry200 - Long running post request, service returns a 202 to the initial request, with 'Location' and 'Retry-After' headers, Polls return a
// 200 with a response body after success
func (client *LrOSClient) Post202Retry200(ctx context.Context, options *LrOSPost202Retry200Options) (*azcore.Response, error) {
	req, err := client.Post202Retry200CreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, client.Post202Retry200HandleError(resp)
	}
	return resp, nil
}

// Post202Retry200CreateRequest creates the Post202Retry200 request.
func (client *LrOSClient) Post202Retry200CreateRequest(ctx context.Context, options *LrOSPost202Retry200Options) (*azcore.Request, error) {
	urlPath := "/lro/post/202/retry/200"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	if options != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// Post202Retry200HandleError handles the Post202Retry200 error response.
func (client *LrOSClient) Post202Retry200HandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *LrOSClient) BeginPostAsyncNoRetrySucceeded(ctx context.Context, options *LrOSPostAsyncNoRetrySucceededOptions) (*ProductPollerResponse, error) {
	resp, err := client.PostAsyncNoRetrySucceeded(ctx, options)
	if err != nil {
		return nil, err
	}
	result := &ProductPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LrOSClient.PostAsyncNoRetrySucceeded", "", resp, client.PostAsyncNoRetrySucceededHandleError)
	if err != nil {
		return nil, err
	}
	poller := &productPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *LrOSClient) ResumePostAsyncNoRetrySucceeded(token string) (ProductPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("LrOSClient.PostAsyncNoRetrySucceeded", token, client.PostAsyncNoRetrySucceededHandleError)
	if err != nil {
		return nil, err
	}
	return &productPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// PostAsyncNoRetrySucceeded - Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’.
// Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
func (client *LrOSClient) PostAsyncNoRetrySucceeded(ctx context.Context, options *LrOSPostAsyncNoRetrySucceededOptions) (*azcore.Response, error) {
	req, err := client.PostAsyncNoRetrySucceededCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.PostAsyncNoRetrySucceededHandleError(resp)
	}
	return resp, nil
}

// PostAsyncNoRetrySucceededCreateRequest creates the PostAsyncNoRetrySucceeded request.
func (client *LrOSClient) PostAsyncNoRetrySucceededCreateRequest(ctx context.Context, options *LrOSPostAsyncNoRetrySucceededOptions) (*azcore.Request, error) {
	urlPath := "/lro/postasync/noretry/succeeded"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	if options != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// PostAsyncNoRetrySucceededHandleResponse handles the PostAsyncNoRetrySucceeded response.
func (client *LrOSClient) PostAsyncNoRetrySucceededHandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// PostAsyncNoRetrySucceededHandleError handles the PostAsyncNoRetrySucceeded error response.
func (client *LrOSClient) PostAsyncNoRetrySucceededHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *LrOSClient) BeginPostAsyncRetryFailed(ctx context.Context, options *LrOSPostAsyncRetryFailedOptions) (*HTTPPollerResponse, error) {
	resp, err := client.PostAsyncRetryFailed(ctx, options)
	if err != nil {
		return nil, err
	}
	result := &HTTPPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LrOSClient.PostAsyncRetryFailed", "", resp, client.PostAsyncRetryFailedHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *LrOSClient) ResumePostAsyncRetryFailed(token string) (HTTPPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("LrOSClient.PostAsyncRetryFailed", token, client.PostAsyncRetryFailedHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// PostAsyncRetryFailed - Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’.
// Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
func (client *LrOSClient) PostAsyncRetryFailed(ctx context.Context, options *LrOSPostAsyncRetryFailedOptions) (*azcore.Response, error) {
	req, err := client.PostAsyncRetryFailedCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, client.PostAsyncRetryFailedHandleError(resp)
	}
	return resp, nil
}

// PostAsyncRetryFailedCreateRequest creates the PostAsyncRetryFailed request.
func (client *LrOSClient) PostAsyncRetryFailedCreateRequest(ctx context.Context, options *LrOSPostAsyncRetryFailedOptions) (*azcore.Request, error) {
	urlPath := "/lro/postasync/retry/failed"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	if options != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// PostAsyncRetryFailedHandleError handles the PostAsyncRetryFailed error response.
func (client *LrOSClient) PostAsyncRetryFailedHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *LrOSClient) BeginPostAsyncRetrySucceeded(ctx context.Context, options *LrOSPostAsyncRetrySucceededOptions) (*ProductPollerResponse, error) {
	resp, err := client.PostAsyncRetrySucceeded(ctx, options)
	if err != nil {
		return nil, err
	}
	result := &ProductPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LrOSClient.PostAsyncRetrySucceeded", "", resp, client.PostAsyncRetrySucceededHandleError)
	if err != nil {
		return nil, err
	}
	poller := &productPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *LrOSClient) ResumePostAsyncRetrySucceeded(token string) (ProductPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("LrOSClient.PostAsyncRetrySucceeded", token, client.PostAsyncRetrySucceededHandleError)
	if err != nil {
		return nil, err
	}
	return &productPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// PostAsyncRetrySucceeded - Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’.
// Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
func (client *LrOSClient) PostAsyncRetrySucceeded(ctx context.Context, options *LrOSPostAsyncRetrySucceededOptions) (*azcore.Response, error) {
	req, err := client.PostAsyncRetrySucceededCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.PostAsyncRetrySucceededHandleError(resp)
	}
	return resp, nil
}

// PostAsyncRetrySucceededCreateRequest creates the PostAsyncRetrySucceeded request.
func (client *LrOSClient) PostAsyncRetrySucceededCreateRequest(ctx context.Context, options *LrOSPostAsyncRetrySucceededOptions) (*azcore.Request, error) {
	urlPath := "/lro/postasync/retry/succeeded"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	if options != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// PostAsyncRetrySucceededHandleResponse handles the PostAsyncRetrySucceeded response.
func (client *LrOSClient) PostAsyncRetrySucceededHandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// PostAsyncRetrySucceededHandleError handles the PostAsyncRetrySucceeded error response.
func (client *LrOSClient) PostAsyncRetrySucceededHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *LrOSClient) BeginPostAsyncRetrycanceled(ctx context.Context, options *LrOSPostAsyncRetrycanceledOptions) (*HTTPPollerResponse, error) {
	resp, err := client.PostAsyncRetrycanceled(ctx, options)
	if err != nil {
		return nil, err
	}
	result := &HTTPPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LrOSClient.PostAsyncRetrycanceled", "", resp, client.PostAsyncRetrycanceledHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *LrOSClient) ResumePostAsyncRetrycanceled(token string) (HTTPPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("LrOSClient.PostAsyncRetrycanceled", token, client.PostAsyncRetrycanceledHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// PostAsyncRetrycanceled - Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’.
// Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
func (client *LrOSClient) PostAsyncRetrycanceled(ctx context.Context, options *LrOSPostAsyncRetrycanceledOptions) (*azcore.Response, error) {
	req, err := client.PostAsyncRetrycanceledCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, client.PostAsyncRetrycanceledHandleError(resp)
	}
	return resp, nil
}

// PostAsyncRetrycanceledCreateRequest creates the PostAsyncRetrycanceled request.
func (client *LrOSClient) PostAsyncRetrycanceledCreateRequest(ctx context.Context, options *LrOSPostAsyncRetrycanceledOptions) (*azcore.Request, error) {
	urlPath := "/lro/postasync/retry/canceled"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	if options != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// PostAsyncRetrycanceledHandleError handles the PostAsyncRetrycanceled error response.
func (client *LrOSClient) PostAsyncRetrycanceledHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *LrOSClient) BeginPostDoubleHeadersFinalAzureHeaderGet(ctx context.Context, options *LrOSPostDoubleHeadersFinalAzureHeaderGetOptions) (*ProductPollerResponse, error) {
	resp, err := client.PostDoubleHeadersFinalAzureHeaderGet(ctx, options)
	if err != nil {
		return nil, err
	}
	result := &ProductPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LrOSClient.PostDoubleHeadersFinalAzureHeaderGet", "azure-async-operation", resp, client.PostDoubleHeadersFinalAzureHeaderGetHandleError)
	if err != nil {
		return nil, err
	}
	poller := &productPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *LrOSClient) ResumePostDoubleHeadersFinalAzureHeaderGet(token string) (ProductPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("LrOSClient.PostDoubleHeadersFinalAzureHeaderGet", token, client.PostDoubleHeadersFinalAzureHeaderGetHandleError)
	if err != nil {
		return nil, err
	}
	return &productPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// PostDoubleHeadersFinalAzureHeaderGet - Long running post request, service returns a 202 to the initial request with both Location and Azure-Async header.
// Poll Azure-Async and it's success. Should NOT poll Location to get the final object
func (client *LrOSClient) PostDoubleHeadersFinalAzureHeaderGet(ctx context.Context, options *LrOSPostDoubleHeadersFinalAzureHeaderGetOptions) (*azcore.Response, error) {
	req, err := client.PostDoubleHeadersFinalAzureHeaderGetCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, client.PostDoubleHeadersFinalAzureHeaderGetHandleError(resp)
	}
	return resp, nil
}

// PostDoubleHeadersFinalAzureHeaderGetCreateRequest creates the PostDoubleHeadersFinalAzureHeaderGet request.
func (client *LrOSClient) PostDoubleHeadersFinalAzureHeaderGetCreateRequest(ctx context.Context, options *LrOSPostDoubleHeadersFinalAzureHeaderGetOptions) (*azcore.Request, error) {
	urlPath := "/lro/LROPostDoubleHeadersFinalAzureHeaderGet"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// PostDoubleHeadersFinalAzureHeaderGetHandleResponse handles the PostDoubleHeadersFinalAzureHeaderGet response.
func (client *LrOSClient) PostDoubleHeadersFinalAzureHeaderGetHandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// PostDoubleHeadersFinalAzureHeaderGetHandleError handles the PostDoubleHeadersFinalAzureHeaderGet error response.
func (client *LrOSClient) PostDoubleHeadersFinalAzureHeaderGetHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *LrOSClient) BeginPostDoubleHeadersFinalAzureHeaderGetDefault(ctx context.Context, options *LrOSPostDoubleHeadersFinalAzureHeaderGetDefaultOptions) (*ProductPollerResponse, error) {
	resp, err := client.PostDoubleHeadersFinalAzureHeaderGetDefault(ctx, options)
	if err != nil {
		return nil, err
	}
	result := &ProductPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LrOSClient.PostDoubleHeadersFinalAzureHeaderGetDefault", "", resp, client.PostDoubleHeadersFinalAzureHeaderGetDefaultHandleError)
	if err != nil {
		return nil, err
	}
	poller := &productPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *LrOSClient) ResumePostDoubleHeadersFinalAzureHeaderGetDefault(token string) (ProductPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("LrOSClient.PostDoubleHeadersFinalAzureHeaderGetDefault", token, client.PostDoubleHeadersFinalAzureHeaderGetDefaultHandleError)
	if err != nil {
		return nil, err
	}
	return &productPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// PostDoubleHeadersFinalAzureHeaderGetDefault - Long running post request, service returns a 202 to the initial request with both Location and Azure-Async
// header. Poll Azure-Async and it's success. Should NOT poll Location to get the final object
// if you support initial Autorest behavior.
func (client *LrOSClient) PostDoubleHeadersFinalAzureHeaderGetDefault(ctx context.Context, options *LrOSPostDoubleHeadersFinalAzureHeaderGetDefaultOptions) (*azcore.Response, error) {
	req, err := client.PostDoubleHeadersFinalAzureHeaderGetDefaultCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, client.PostDoubleHeadersFinalAzureHeaderGetDefaultHandleError(resp)
	}
	return resp, nil
}

// PostDoubleHeadersFinalAzureHeaderGetDefaultCreateRequest creates the PostDoubleHeadersFinalAzureHeaderGetDefault request.
func (client *LrOSClient) PostDoubleHeadersFinalAzureHeaderGetDefaultCreateRequest(ctx context.Context, options *LrOSPostDoubleHeadersFinalAzureHeaderGetDefaultOptions) (*azcore.Request, error) {
	urlPath := "/lro/LROPostDoubleHeadersFinalAzureHeaderGetDefault"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// PostDoubleHeadersFinalAzureHeaderGetDefaultHandleResponse handles the PostDoubleHeadersFinalAzureHeaderGetDefault response.
func (client *LrOSClient) PostDoubleHeadersFinalAzureHeaderGetDefaultHandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// PostDoubleHeadersFinalAzureHeaderGetDefaultHandleError handles the PostDoubleHeadersFinalAzureHeaderGetDefault error response.
func (client *LrOSClient) PostDoubleHeadersFinalAzureHeaderGetDefaultHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *LrOSClient) BeginPostDoubleHeadersFinalLocationGet(ctx context.Context, options *LrOSPostDoubleHeadersFinalLocationGetOptions) (*ProductPollerResponse, error) {
	resp, err := client.PostDoubleHeadersFinalLocationGet(ctx, options)
	if err != nil {
		return nil, err
	}
	result := &ProductPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LrOSClient.PostDoubleHeadersFinalLocationGet", "location", resp, client.PostDoubleHeadersFinalLocationGetHandleError)
	if err != nil {
		return nil, err
	}
	poller := &productPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *LrOSClient) ResumePostDoubleHeadersFinalLocationGet(token string) (ProductPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("LrOSClient.PostDoubleHeadersFinalLocationGet", token, client.PostDoubleHeadersFinalLocationGetHandleError)
	if err != nil {
		return nil, err
	}
	return &productPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// PostDoubleHeadersFinalLocationGet - Long running post request, service returns a 202 to the initial request with both Location and Azure-Async header.
// Poll Azure-Async and it's success. Should poll Location to get the final object
func (client *LrOSClient) PostDoubleHeadersFinalLocationGet(ctx context.Context, options *LrOSPostDoubleHeadersFinalLocationGetOptions) (*azcore.Response, error) {
	req, err := client.PostDoubleHeadersFinalLocationGetCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, client.PostDoubleHeadersFinalLocationGetHandleError(resp)
	}
	return resp, nil
}

// PostDoubleHeadersFinalLocationGetCreateRequest creates the PostDoubleHeadersFinalLocationGet request.
func (client *LrOSClient) PostDoubleHeadersFinalLocationGetCreateRequest(ctx context.Context, options *LrOSPostDoubleHeadersFinalLocationGetOptions) (*azcore.Request, error) {
	urlPath := "/lro/LROPostDoubleHeadersFinalLocationGet"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// PostDoubleHeadersFinalLocationGetHandleResponse handles the PostDoubleHeadersFinalLocationGet response.
func (client *LrOSClient) PostDoubleHeadersFinalLocationGetHandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// PostDoubleHeadersFinalLocationGetHandleError handles the PostDoubleHeadersFinalLocationGet error response.
func (client *LrOSClient) PostDoubleHeadersFinalLocationGetHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *LrOSClient) BeginPut200Acceptedcanceled200(ctx context.Context, options *LrOSPut200Acceptedcanceled200Options) (*ProductPollerResponse, error) {
	resp, err := client.Put200Acceptedcanceled200(ctx, options)
	if err != nil {
		return nil, err
	}
	result := &ProductPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LrOSClient.Put200Acceptedcanceled200", "", resp, client.Put200Acceptedcanceled200HandleError)
	if err != nil {
		return nil, err
	}
	poller := &productPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *LrOSClient) ResumePut200Acceptedcanceled200(token string) (ProductPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("LrOSClient.Put200Acceptedcanceled200", token, client.Put200Acceptedcanceled200HandleError)
	if err != nil {
		return nil, err
	}
	return &productPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// Put200Acceptedcanceled200 - Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Creating’.
// Polls return this value until the last poll returns a ‘200’ with
// ProvisioningState=’Canceled’
func (client *LrOSClient) Put200Acceptedcanceled200(ctx context.Context, options *LrOSPut200Acceptedcanceled200Options) (*azcore.Response, error) {
	req, err := client.Put200Acceptedcanceled200CreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.Put200Acceptedcanceled200HandleError(resp)
	}
	return resp, nil
}

// Put200Acceptedcanceled200CreateRequest creates the Put200Acceptedcanceled200 request.
func (client *LrOSClient) Put200Acceptedcanceled200CreateRequest(ctx context.Context, options *LrOSPut200Acceptedcanceled200Options) (*azcore.Request, error) {
	urlPath := "/lro/put/200/accepted/canceled/200"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	if options != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// Put200Acceptedcanceled200HandleResponse handles the Put200Acceptedcanceled200 response.
func (client *LrOSClient) Put200Acceptedcanceled200HandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// Put200Acceptedcanceled200HandleError handles the Put200Acceptedcanceled200 error response.
func (client *LrOSClient) Put200Acceptedcanceled200HandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *LrOSClient) BeginPut200Succeeded(ctx context.Context, options *LrOSPut200SucceededOptions) (*ProductPollerResponse, error) {
	resp, err := client.Put200Succeeded(ctx, options)
	if err != nil {
		return nil, err
	}
	result := &ProductPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LrOSClient.Put200Succeeded", "", resp, client.Put200SucceededHandleError)
	if err != nil {
		return nil, err
	}
	poller := &productPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *LrOSClient) ResumePut200Succeeded(token string) (ProductPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("LrOSClient.Put200Succeeded", token, client.Put200SucceededHandleError)
	if err != nil {
		return nil, err
	}
	return &productPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// Put200Succeeded - Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Succeeded’.
func (client *LrOSClient) Put200Succeeded(ctx context.Context, options *LrOSPut200SucceededOptions) (*azcore.Response, error) {
	req, err := client.Put200SucceededCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusNoContent) {
		return nil, client.Put200SucceededHandleError(resp)
	}
	return resp, nil
}

// Put200SucceededCreateRequest creates the Put200Succeeded request.
func (client *LrOSClient) Put200SucceededCreateRequest(ctx context.Context, options *LrOSPut200SucceededOptions) (*azcore.Request, error) {
	urlPath := "/lro/put/200/succeeded"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	if options != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// Put200SucceededHandleResponse handles the Put200Succeeded response.
func (client *LrOSClient) Put200SucceededHandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// Put200SucceededHandleError handles the Put200Succeeded error response.
func (client *LrOSClient) Put200SucceededHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *LrOSClient) BeginPut200SucceededNoState(ctx context.Context, options *LrOSPut200SucceededNoStateOptions) (*ProductPollerResponse, error) {
	resp, err := client.Put200SucceededNoState(ctx, options)
	if err != nil {
		return nil, err
	}
	result := &ProductPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LrOSClient.Put200SucceededNoState", "", resp, client.Put200SucceededNoStateHandleError)
	if err != nil {
		return nil, err
	}
	poller := &productPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *LrOSClient) ResumePut200SucceededNoState(token string) (ProductPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("LrOSClient.Put200SucceededNoState", token, client.Put200SucceededNoStateHandleError)
	if err != nil {
		return nil, err
	}
	return &productPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// Put200SucceededNoState - Long running put request, service returns a 200 to the initial request, with an entity that does not contain ProvisioningState=’Succeeded’.
func (client *LrOSClient) Put200SucceededNoState(ctx context.Context, options *LrOSPut200SucceededNoStateOptions) (*azcore.Response, error) {
	req, err := client.Put200SucceededNoStateCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.Put200SucceededNoStateHandleError(resp)
	}
	return resp, nil
}

// Put200SucceededNoStateCreateRequest creates the Put200SucceededNoState request.
func (client *LrOSClient) Put200SucceededNoStateCreateRequest(ctx context.Context, options *LrOSPut200SucceededNoStateOptions) (*azcore.Request, error) {
	urlPath := "/lro/put/200/succeeded/nostate"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	if options != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// Put200SucceededNoStateHandleResponse handles the Put200SucceededNoState response.
func (client *LrOSClient) Put200SucceededNoStateHandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// Put200SucceededNoStateHandleError handles the Put200SucceededNoState error response.
func (client *LrOSClient) Put200SucceededNoStateHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *LrOSClient) BeginPut200UpdatingSucceeded204(ctx context.Context, options *LrOSPut200UpdatingSucceeded204Options) (*ProductPollerResponse, error) {
	resp, err := client.Put200UpdatingSucceeded204(ctx, options)
	if err != nil {
		return nil, err
	}
	result := &ProductPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LrOSClient.Put200UpdatingSucceeded204", "", resp, client.Put200UpdatingSucceeded204HandleError)
	if err != nil {
		return nil, err
	}
	poller := &productPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *LrOSClient) ResumePut200UpdatingSucceeded204(token string) (ProductPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("LrOSClient.Put200UpdatingSucceeded204", token, client.Put200UpdatingSucceeded204HandleError)
	if err != nil {
		return nil, err
	}
	return &productPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// Put200UpdatingSucceeded204 - Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Updating’.
// Polls return this value until the last poll returns a ‘200’ with
// ProvisioningState=’Succeeded’
func (client *LrOSClient) Put200UpdatingSucceeded204(ctx context.Context, options *LrOSPut200UpdatingSucceeded204Options) (*azcore.Response, error) {
	req, err := client.Put200UpdatingSucceeded204CreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.Put200UpdatingSucceeded204HandleError(resp)
	}
	return resp, nil
}

// Put200UpdatingSucceeded204CreateRequest creates the Put200UpdatingSucceeded204 request.
func (client *LrOSClient) Put200UpdatingSucceeded204CreateRequest(ctx context.Context, options *LrOSPut200UpdatingSucceeded204Options) (*azcore.Request, error) {
	urlPath := "/lro/put/200/updating/succeeded/200"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	if options != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// Put200UpdatingSucceeded204HandleResponse handles the Put200UpdatingSucceeded204 response.
func (client *LrOSClient) Put200UpdatingSucceeded204HandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// Put200UpdatingSucceeded204HandleError handles the Put200UpdatingSucceeded204 error response.
func (client *LrOSClient) Put200UpdatingSucceeded204HandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *LrOSClient) BeginPut201CreatingFailed200(ctx context.Context, options *LrOSPut201CreatingFailed200Options) (*ProductPollerResponse, error) {
	resp, err := client.Put201CreatingFailed200(ctx, options)
	if err != nil {
		return nil, err
	}
	result := &ProductPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LrOSClient.Put201CreatingFailed200", "", resp, client.Put201CreatingFailed200HandleError)
	if err != nil {
		return nil, err
	}
	poller := &productPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *LrOSClient) ResumePut201CreatingFailed200(token string) (ProductPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("LrOSClient.Put201CreatingFailed200", token, client.Put201CreatingFailed200HandleError)
	if err != nil {
		return nil, err
	}
	return &productPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// Put201CreatingFailed200 - Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Created’.
// Polls return this value until the last poll returns a ‘200’ with
// ProvisioningState=’Failed’
func (client *LrOSClient) Put201CreatingFailed200(ctx context.Context, options *LrOSPut201CreatingFailed200Options) (*azcore.Response, error) {
	req, err := client.Put201CreatingFailed200CreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusCreated) {
		return nil, client.Put201CreatingFailed200HandleError(resp)
	}
	return resp, nil
}

// Put201CreatingFailed200CreateRequest creates the Put201CreatingFailed200 request.
func (client *LrOSClient) Put201CreatingFailed200CreateRequest(ctx context.Context, options *LrOSPut201CreatingFailed200Options) (*azcore.Request, error) {
	urlPath := "/lro/put/201/created/failed/200"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	if options != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// Put201CreatingFailed200HandleResponse handles the Put201CreatingFailed200 response.
func (client *LrOSClient) Put201CreatingFailed200HandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// Put201CreatingFailed200HandleError handles the Put201CreatingFailed200 error response.
func (client *LrOSClient) Put201CreatingFailed200HandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *LrOSClient) BeginPut201CreatingSucceeded200(ctx context.Context, options *LrOSPut201CreatingSucceeded200Options) (*ProductPollerResponse, error) {
	resp, err := client.Put201CreatingSucceeded200(ctx, options)
	if err != nil {
		return nil, err
	}
	result := &ProductPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LrOSClient.Put201CreatingSucceeded200", "", resp, client.Put201CreatingSucceeded200HandleError)
	if err != nil {
		return nil, err
	}
	poller := &productPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *LrOSClient) ResumePut201CreatingSucceeded200(token string) (ProductPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("LrOSClient.Put201CreatingSucceeded200", token, client.Put201CreatingSucceeded200HandleError)
	if err != nil {
		return nil, err
	}
	return &productPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// Put201CreatingSucceeded200 - Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Creating’.
// Polls return this value until the last poll returns a ‘200’ with
// ProvisioningState=’Succeeded’
func (client *LrOSClient) Put201CreatingSucceeded200(ctx context.Context, options *LrOSPut201CreatingSucceeded200Options) (*azcore.Response, error) {
	req, err := client.Put201CreatingSucceeded200CreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusCreated) {
		return nil, client.Put201CreatingSucceeded200HandleError(resp)
	}
	return resp, nil
}

// Put201CreatingSucceeded200CreateRequest creates the Put201CreatingSucceeded200 request.
func (client *LrOSClient) Put201CreatingSucceeded200CreateRequest(ctx context.Context, options *LrOSPut201CreatingSucceeded200Options) (*azcore.Request, error) {
	urlPath := "/lro/put/201/creating/succeeded/200"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	if options != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// Put201CreatingSucceeded200HandleResponse handles the Put201CreatingSucceeded200 response.
func (client *LrOSClient) Put201CreatingSucceeded200HandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// Put201CreatingSucceeded200HandleError handles the Put201CreatingSucceeded200 error response.
func (client *LrOSClient) Put201CreatingSucceeded200HandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *LrOSClient) BeginPut201Succeeded(ctx context.Context, options *LrOSPut201SucceededOptions) (*ProductPollerResponse, error) {
	resp, err := client.Put201Succeeded(ctx, options)
	if err != nil {
		return nil, err
	}
	result := &ProductPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LrOSClient.Put201Succeeded", "", resp, client.Put201SucceededHandleError)
	if err != nil {
		return nil, err
	}
	poller := &productPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *LrOSClient) ResumePut201Succeeded(token string) (ProductPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("LrOSClient.Put201Succeeded", token, client.Put201SucceededHandleError)
	if err != nil {
		return nil, err
	}
	return &productPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// Put201Succeeded - Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Succeeded’.
func (client *LrOSClient) Put201Succeeded(ctx context.Context, options *LrOSPut201SucceededOptions) (*azcore.Response, error) {
	req, err := client.Put201SucceededCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, client.Put201SucceededHandleError(resp)
	}
	return resp, nil
}

// Put201SucceededCreateRequest creates the Put201Succeeded request.
func (client *LrOSClient) Put201SucceededCreateRequest(ctx context.Context, options *LrOSPut201SucceededOptions) (*azcore.Request, error) {
	urlPath := "/lro/put/201/succeeded"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	if options != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// Put201SucceededHandleResponse handles the Put201Succeeded response.
func (client *LrOSClient) Put201SucceededHandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// Put201SucceededHandleError handles the Put201Succeeded error response.
func (client *LrOSClient) Put201SucceededHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *LrOSClient) BeginPut202Retry200(ctx context.Context, options *LrOSPut202Retry200Options) (*ProductPollerResponse, error) {
	resp, err := client.Put202Retry200(ctx, options)
	if err != nil {
		return nil, err
	}
	result := &ProductPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LrOSClient.Put202Retry200", "", resp, client.Put202Retry200HandleError)
	if err != nil {
		return nil, err
	}
	poller := &productPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *LrOSClient) ResumePut202Retry200(token string) (ProductPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("LrOSClient.Put202Retry200", token, client.Put202Retry200HandleError)
	if err != nil {
		return nil, err
	}
	return &productPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// Put202Retry200 - Long running put request, service returns a 202 to the initial request, with a location header that points to a polling URL that returns
// a 200 and an entity that doesn't contains ProvisioningState
func (client *LrOSClient) Put202Retry200(ctx context.Context, options *LrOSPut202Retry200Options) (*azcore.Response, error) {
	req, err := client.Put202Retry200CreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, client.Put202Retry200HandleError(resp)
	}
	return resp, nil
}

// Put202Retry200CreateRequest creates the Put202Retry200 request.
func (client *LrOSClient) Put202Retry200CreateRequest(ctx context.Context, options *LrOSPut202Retry200Options) (*azcore.Request, error) {
	urlPath := "/lro/put/202/retry/200"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	if options != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// Put202Retry200HandleResponse handles the Put202Retry200 response.
func (client *LrOSClient) Put202Retry200HandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// Put202Retry200HandleError handles the Put202Retry200 error response.
func (client *LrOSClient) Put202Retry200HandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *LrOSClient) BeginPutAsyncNoHeaderInRetry(ctx context.Context, options *LrOSPutAsyncNoHeaderInRetryOptions) (*ProductPollerResponse, error) {
	resp, err := client.PutAsyncNoHeaderInRetry(ctx, options)
	if err != nil {
		return nil, err
	}
	result := &ProductPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LrOSClient.PutAsyncNoHeaderInRetry", "", resp, client.PutAsyncNoHeaderInRetryHandleError)
	if err != nil {
		return nil, err
	}
	poller := &productPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *LrOSClient) ResumePutAsyncNoHeaderInRetry(token string) (ProductPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("LrOSClient.PutAsyncNoHeaderInRetry", token, client.PutAsyncNoHeaderInRetryHandleError)
	if err != nil {
		return nil, err
	}
	return &productPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// PutAsyncNoHeaderInRetry - Long running put request, service returns a 202 to the initial request with Azure-AsyncOperation header. Subsequent calls to
// operation status do not contain Azure-AsyncOperation header.
func (client *LrOSClient) PutAsyncNoHeaderInRetry(ctx context.Context, options *LrOSPutAsyncNoHeaderInRetryOptions) (*azcore.Response, error) {
	req, err := client.PutAsyncNoHeaderInRetryCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, client.PutAsyncNoHeaderInRetryHandleError(resp)
	}
	return resp, nil
}

// PutAsyncNoHeaderInRetryCreateRequest creates the PutAsyncNoHeaderInRetry request.
func (client *LrOSClient) PutAsyncNoHeaderInRetryCreateRequest(ctx context.Context, options *LrOSPutAsyncNoHeaderInRetryOptions) (*azcore.Request, error) {
	urlPath := "/lro/putasync/noheader/201/200"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	if options != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// PutAsyncNoHeaderInRetryHandleResponse handles the PutAsyncNoHeaderInRetry response.
func (client *LrOSClient) PutAsyncNoHeaderInRetryHandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// PutAsyncNoHeaderInRetryHandleError handles the PutAsyncNoHeaderInRetry error response.
func (client *LrOSClient) PutAsyncNoHeaderInRetryHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *LrOSClient) BeginPutAsyncNoRetrySucceeded(ctx context.Context, options *LrOSPutAsyncNoRetrySucceededOptions) (*ProductPollerResponse, error) {
	resp, err := client.PutAsyncNoRetrySucceeded(ctx, options)
	if err != nil {
		return nil, err
	}
	result := &ProductPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LrOSClient.PutAsyncNoRetrySucceeded", "", resp, client.PutAsyncNoRetrySucceededHandleError)
	if err != nil {
		return nil, err
	}
	poller := &productPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *LrOSClient) ResumePutAsyncNoRetrySucceeded(token string) (ProductPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("LrOSClient.PutAsyncNoRetrySucceeded", token, client.PutAsyncNoRetrySucceededHandleError)
	if err != nil {
		return nil, err
	}
	return &productPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// PutAsyncNoRetrySucceeded - Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’.
// Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
func (client *LrOSClient) PutAsyncNoRetrySucceeded(ctx context.Context, options *LrOSPutAsyncNoRetrySucceededOptions) (*azcore.Response, error) {
	req, err := client.PutAsyncNoRetrySucceededCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.PutAsyncNoRetrySucceededHandleError(resp)
	}
	return resp, nil
}

// PutAsyncNoRetrySucceededCreateRequest creates the PutAsyncNoRetrySucceeded request.
func (client *LrOSClient) PutAsyncNoRetrySucceededCreateRequest(ctx context.Context, options *LrOSPutAsyncNoRetrySucceededOptions) (*azcore.Request, error) {
	urlPath := "/lro/putasync/noretry/succeeded"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	if options != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// PutAsyncNoRetrySucceededHandleResponse handles the PutAsyncNoRetrySucceeded response.
func (client *LrOSClient) PutAsyncNoRetrySucceededHandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// PutAsyncNoRetrySucceededHandleError handles the PutAsyncNoRetrySucceeded error response.
func (client *LrOSClient) PutAsyncNoRetrySucceededHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *LrOSClient) BeginPutAsyncNoRetrycanceled(ctx context.Context, options *LrOSPutAsyncNoRetrycanceledOptions) (*ProductPollerResponse, error) {
	resp, err := client.PutAsyncNoRetrycanceled(ctx, options)
	if err != nil {
		return nil, err
	}
	result := &ProductPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LrOSClient.PutAsyncNoRetrycanceled", "", resp, client.PutAsyncNoRetrycanceledHandleError)
	if err != nil {
		return nil, err
	}
	poller := &productPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *LrOSClient) ResumePutAsyncNoRetrycanceled(token string) (ProductPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("LrOSClient.PutAsyncNoRetrycanceled", token, client.PutAsyncNoRetrycanceledHandleError)
	if err != nil {
		return nil, err
	}
	return &productPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// PutAsyncNoRetrycanceled - Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’.
// Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
func (client *LrOSClient) PutAsyncNoRetrycanceled(ctx context.Context, options *LrOSPutAsyncNoRetrycanceledOptions) (*azcore.Response, error) {
	req, err := client.PutAsyncNoRetrycanceledCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.PutAsyncNoRetrycanceledHandleError(resp)
	}
	return resp, nil
}

// PutAsyncNoRetrycanceledCreateRequest creates the PutAsyncNoRetrycanceled request.
func (client *LrOSClient) PutAsyncNoRetrycanceledCreateRequest(ctx context.Context, options *LrOSPutAsyncNoRetrycanceledOptions) (*azcore.Request, error) {
	urlPath := "/lro/putasync/noretry/canceled"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	if options != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// PutAsyncNoRetrycanceledHandleResponse handles the PutAsyncNoRetrycanceled response.
func (client *LrOSClient) PutAsyncNoRetrycanceledHandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// PutAsyncNoRetrycanceledHandleError handles the PutAsyncNoRetrycanceled error response.
func (client *LrOSClient) PutAsyncNoRetrycanceledHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *LrOSClient) BeginPutAsyncNonResource(ctx context.Context, options *LrOSPutAsyncNonResourceOptions) (*SKUPollerResponse, error) {
	resp, err := client.PutAsyncNonResource(ctx, options)
	if err != nil {
		return nil, err
	}
	result := &SKUPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LrOSClient.PutAsyncNonResource", "", resp, client.PutAsyncNonResourceHandleError)
	if err != nil {
		return nil, err
	}
	poller := &skuPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*SKUResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *LrOSClient) ResumePutAsyncNonResource(token string) (SKUPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("LrOSClient.PutAsyncNonResource", token, client.PutAsyncNonResourceHandleError)
	if err != nil {
		return nil, err
	}
	return &skuPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// PutAsyncNonResource - Long running put request with non resource.
func (client *LrOSClient) PutAsyncNonResource(ctx context.Context, options *LrOSPutAsyncNonResourceOptions) (*azcore.Response, error) {
	req, err := client.PutAsyncNonResourceCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, client.PutAsyncNonResourceHandleError(resp)
	}
	return resp, nil
}

// PutAsyncNonResourceCreateRequest creates the PutAsyncNonResource request.
func (client *LrOSClient) PutAsyncNonResourceCreateRequest(ctx context.Context, options *LrOSPutAsyncNonResourceOptions) (*azcore.Request, error) {
	urlPath := "/lro/putnonresourceasync/202/200"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	if options != nil {
		return req, req.MarshalAsJSON(options.Sku)
	}
	return req, nil
}

// PutAsyncNonResourceHandleResponse handles the PutAsyncNonResource response.
func (client *LrOSClient) PutAsyncNonResourceHandleResponse(resp *azcore.Response) (*SKUResponse, error) {
	result := SKUResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.SKU)
}

// PutAsyncNonResourceHandleError handles the PutAsyncNonResource error response.
func (client *LrOSClient) PutAsyncNonResourceHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *LrOSClient) BeginPutAsyncRetryFailed(ctx context.Context, options *LrOSPutAsyncRetryFailedOptions) (*ProductPollerResponse, error) {
	resp, err := client.PutAsyncRetryFailed(ctx, options)
	if err != nil {
		return nil, err
	}
	result := &ProductPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LrOSClient.PutAsyncRetryFailed", "", resp, client.PutAsyncRetryFailedHandleError)
	if err != nil {
		return nil, err
	}
	poller := &productPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *LrOSClient) ResumePutAsyncRetryFailed(token string) (ProductPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("LrOSClient.PutAsyncRetryFailed", token, client.PutAsyncRetryFailedHandleError)
	if err != nil {
		return nil, err
	}
	return &productPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// PutAsyncRetryFailed - Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’.
// Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
func (client *LrOSClient) PutAsyncRetryFailed(ctx context.Context, options *LrOSPutAsyncRetryFailedOptions) (*azcore.Response, error) {
	req, err := client.PutAsyncRetryFailedCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.PutAsyncRetryFailedHandleError(resp)
	}
	return resp, nil
}

// PutAsyncRetryFailedCreateRequest creates the PutAsyncRetryFailed request.
func (client *LrOSClient) PutAsyncRetryFailedCreateRequest(ctx context.Context, options *LrOSPutAsyncRetryFailedOptions) (*azcore.Request, error) {
	urlPath := "/lro/putasync/retry/failed"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	if options != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// PutAsyncRetryFailedHandleResponse handles the PutAsyncRetryFailed response.
func (client *LrOSClient) PutAsyncRetryFailedHandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// PutAsyncRetryFailedHandleError handles the PutAsyncRetryFailed error response.
func (client *LrOSClient) PutAsyncRetryFailedHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *LrOSClient) BeginPutAsyncRetrySucceeded(ctx context.Context, options *LrOSPutAsyncRetrySucceededOptions) (*ProductPollerResponse, error) {
	resp, err := client.PutAsyncRetrySucceeded(ctx, options)
	if err != nil {
		return nil, err
	}
	result := &ProductPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LrOSClient.PutAsyncRetrySucceeded", "", resp, client.PutAsyncRetrySucceededHandleError)
	if err != nil {
		return nil, err
	}
	poller := &productPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *LrOSClient) ResumePutAsyncRetrySucceeded(token string) (ProductPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("LrOSClient.PutAsyncRetrySucceeded", token, client.PutAsyncRetrySucceededHandleError)
	if err != nil {
		return nil, err
	}
	return &productPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// PutAsyncRetrySucceeded - Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’.
// Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
func (client *LrOSClient) PutAsyncRetrySucceeded(ctx context.Context, options *LrOSPutAsyncRetrySucceededOptions) (*azcore.Response, error) {
	req, err := client.PutAsyncRetrySucceededCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.PutAsyncRetrySucceededHandleError(resp)
	}
	return resp, nil
}

// PutAsyncRetrySucceededCreateRequest creates the PutAsyncRetrySucceeded request.
func (client *LrOSClient) PutAsyncRetrySucceededCreateRequest(ctx context.Context, options *LrOSPutAsyncRetrySucceededOptions) (*azcore.Request, error) {
	urlPath := "/lro/putasync/retry/succeeded"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	if options != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// PutAsyncRetrySucceededHandleResponse handles the PutAsyncRetrySucceeded response.
func (client *LrOSClient) PutAsyncRetrySucceededHandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// PutAsyncRetrySucceededHandleError handles the PutAsyncRetrySucceeded error response.
func (client *LrOSClient) PutAsyncRetrySucceededHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *LrOSClient) BeginPutAsyncSubResource(ctx context.Context, options *LrOSPutAsyncSubResourceOptions) (*SubProductPollerResponse, error) {
	resp, err := client.PutAsyncSubResource(ctx, options)
	if err != nil {
		return nil, err
	}
	result := &SubProductPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LrOSClient.PutAsyncSubResource", "", resp, client.PutAsyncSubResourceHandleError)
	if err != nil {
		return nil, err
	}
	poller := &subProductPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*SubProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *LrOSClient) ResumePutAsyncSubResource(token string) (SubProductPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("LrOSClient.PutAsyncSubResource", token, client.PutAsyncSubResourceHandleError)
	if err != nil {
		return nil, err
	}
	return &subProductPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// PutAsyncSubResource - Long running put request with sub resource.
func (client *LrOSClient) PutAsyncSubResource(ctx context.Context, options *LrOSPutAsyncSubResourceOptions) (*azcore.Response, error) {
	req, err := client.PutAsyncSubResourceCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, client.PutAsyncSubResourceHandleError(resp)
	}
	return resp, nil
}

// PutAsyncSubResourceCreateRequest creates the PutAsyncSubResource request.
func (client *LrOSClient) PutAsyncSubResourceCreateRequest(ctx context.Context, options *LrOSPutAsyncSubResourceOptions) (*azcore.Request, error) {
	urlPath := "/lro/putsubresourceasync/202/200"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	if options != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// PutAsyncSubResourceHandleResponse handles the PutAsyncSubResource response.
func (client *LrOSClient) PutAsyncSubResourceHandleResponse(resp *azcore.Response) (*SubProductResponse, error) {
	result := SubProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.SubProduct)
}

// PutAsyncSubResourceHandleError handles the PutAsyncSubResource error response.
func (client *LrOSClient) PutAsyncSubResourceHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *LrOSClient) BeginPutNoHeaderInRetry(ctx context.Context, options *LrOSPutNoHeaderInRetryOptions) (*ProductPollerResponse, error) {
	resp, err := client.PutNoHeaderInRetry(ctx, options)
	if err != nil {
		return nil, err
	}
	result := &ProductPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LrOSClient.PutNoHeaderInRetry", "", resp, client.PutNoHeaderInRetryHandleError)
	if err != nil {
		return nil, err
	}
	poller := &productPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*ProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *LrOSClient) ResumePutNoHeaderInRetry(token string) (ProductPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("LrOSClient.PutNoHeaderInRetry", token, client.PutNoHeaderInRetryHandleError)
	if err != nil {
		return nil, err
	}
	return &productPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// PutNoHeaderInRetry - Long running put request, service returns a 202 to the initial request with location header. Subsequent calls to operation status
// do not contain location header.
func (client *LrOSClient) PutNoHeaderInRetry(ctx context.Context, options *LrOSPutNoHeaderInRetryOptions) (*azcore.Response, error) {
	req, err := client.PutNoHeaderInRetryCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, client.PutNoHeaderInRetryHandleError(resp)
	}
	return resp, nil
}

// PutNoHeaderInRetryCreateRequest creates the PutNoHeaderInRetry request.
func (client *LrOSClient) PutNoHeaderInRetryCreateRequest(ctx context.Context, options *LrOSPutNoHeaderInRetryOptions) (*azcore.Request, error) {
	urlPath := "/lro/put/noheader/202/200"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	if options != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// PutNoHeaderInRetryHandleResponse handles the PutNoHeaderInRetry response.
func (client *LrOSClient) PutNoHeaderInRetryHandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// PutNoHeaderInRetryHandleError handles the PutNoHeaderInRetry error response.
func (client *LrOSClient) PutNoHeaderInRetryHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *LrOSClient) BeginPutNonResource(ctx context.Context, options *LrOSPutNonResourceOptions) (*SKUPollerResponse, error) {
	resp, err := client.PutNonResource(ctx, options)
	if err != nil {
		return nil, err
	}
	result := &SKUPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LrOSClient.PutNonResource", "", resp, client.PutNonResourceHandleError)
	if err != nil {
		return nil, err
	}
	poller := &skuPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*SKUResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *LrOSClient) ResumePutNonResource(token string) (SKUPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("LrOSClient.PutNonResource", token, client.PutNonResourceHandleError)
	if err != nil {
		return nil, err
	}
	return &skuPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// PutNonResource - Long running put request with non resource.
func (client *LrOSClient) PutNonResource(ctx context.Context, options *LrOSPutNonResourceOptions) (*azcore.Response, error) {
	req, err := client.PutNonResourceCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, client.PutNonResourceHandleError(resp)
	}
	return resp, nil
}

// PutNonResourceCreateRequest creates the PutNonResource request.
func (client *LrOSClient) PutNonResourceCreateRequest(ctx context.Context, options *LrOSPutNonResourceOptions) (*azcore.Request, error) {
	urlPath := "/lro/putnonresource/202/200"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	if options != nil {
		return req, req.MarshalAsJSON(options.Sku)
	}
	return req, nil
}

// PutNonResourceHandleResponse handles the PutNonResource response.
func (client *LrOSClient) PutNonResourceHandleResponse(resp *azcore.Response) (*SKUResponse, error) {
	result := SKUResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.SKU)
}

// PutNonResourceHandleError handles the PutNonResource error response.
func (client *LrOSClient) PutNonResourceHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *LrOSClient) BeginPutSubResource(ctx context.Context, options *LrOSPutSubResourceOptions) (*SubProductPollerResponse, error) {
	resp, err := client.PutSubResource(ctx, options)
	if err != nil {
		return nil, err
	}
	result := &SubProductPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("LrOSClient.PutSubResource", "", resp, client.PutSubResourceHandleError)
	if err != nil {
		return nil, err
	}
	poller := &subProductPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*SubProductResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *LrOSClient) ResumePutSubResource(token string) (SubProductPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("LrOSClient.PutSubResource", token, client.PutSubResourceHandleError)
	if err != nil {
		return nil, err
	}
	return &subProductPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// PutSubResource - Long running put request with sub resource.
func (client *LrOSClient) PutSubResource(ctx context.Context, options *LrOSPutSubResourceOptions) (*azcore.Response, error) {
	req, err := client.PutSubResourceCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, client.PutSubResourceHandleError(resp)
	}
	return resp, nil
}

// PutSubResourceCreateRequest creates the PutSubResource request.
func (client *LrOSClient) PutSubResourceCreateRequest(ctx context.Context, options *LrOSPutSubResourceOptions) (*azcore.Request, error) {
	urlPath := "/lro/putsubresource/202/200"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	if options != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// PutSubResourceHandleResponse handles the PutSubResource response.
func (client *LrOSClient) PutSubResourceHandleResponse(resp *azcore.Response) (*SubProductResponse, error) {
	result := SubProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.SubProduct)
}

// PutSubResourceHandleError handles the PutSubResource error response.
func (client *LrOSClient) PutSubResourceHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}
