//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package lrogroup

import (
	"context"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"net/http"
	"time"
)

// LRORetrysDelete202Retry200PollerResponse contains the response from method LRORetrys.Delete202Retry200.
type LRORetrysDelete202Retry200PollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LRORetrysDelete202Retry200Poller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LRORetrysDelete202Retry200PollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LRORetrysDelete202Retry200Response, error) {
	respType := LRORetrysDelete202Retry200Response{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LRORetrysDelete202Retry200PollerResponse from the provided client and resume token.
func (l *LRORetrysDelete202Retry200PollerResponse) Resume(ctx context.Context, client *LRORetrysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LRORetrysClient.Delete202Retry200", token, client.pl, client.delete202Retry200HandleError)
	if err != nil {
		return err
	}
	poller := &LRORetrysDelete202Retry200Poller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LRORetrysDelete202Retry200Response contains the response from method LRORetrys.Delete202Retry200.
type LRORetrysDelete202Retry200Response struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LRORetrysDeleteAsyncRelativeRetrySucceededPollerResponse contains the response from method LRORetrys.DeleteAsyncRelativeRetrySucceeded.
type LRORetrysDeleteAsyncRelativeRetrySucceededPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LRORetrysDeleteAsyncRelativeRetrySucceededPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LRORetrysDeleteAsyncRelativeRetrySucceededPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LRORetrysDeleteAsyncRelativeRetrySucceededResponse, error) {
	respType := LRORetrysDeleteAsyncRelativeRetrySucceededResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LRORetrysDeleteAsyncRelativeRetrySucceededPollerResponse from the provided client and resume token.
func (l *LRORetrysDeleteAsyncRelativeRetrySucceededPollerResponse) Resume(ctx context.Context, client *LRORetrysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LRORetrysClient.DeleteAsyncRelativeRetrySucceeded", token, client.pl, client.deleteAsyncRelativeRetrySucceededHandleError)
	if err != nil {
		return err
	}
	poller := &LRORetrysDeleteAsyncRelativeRetrySucceededPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LRORetrysDeleteAsyncRelativeRetrySucceededResponse contains the response from method LRORetrys.DeleteAsyncRelativeRetrySucceeded.
type LRORetrysDeleteAsyncRelativeRetrySucceededResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LRORetrysDeleteProvisioning202Accepted200SucceededPollerResponse contains the response from method LRORetrys.DeleteProvisioning202Accepted200Succeeded.
type LRORetrysDeleteProvisioning202Accepted200SucceededPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LRORetrysDeleteProvisioning202Accepted200SucceededPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LRORetrysDeleteProvisioning202Accepted200SucceededPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LRORetrysDeleteProvisioning202Accepted200SucceededResponse, error) {
	respType := LRORetrysDeleteProvisioning202Accepted200SucceededResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Product)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LRORetrysDeleteProvisioning202Accepted200SucceededPollerResponse from the provided client and resume token.
func (l *LRORetrysDeleteProvisioning202Accepted200SucceededPollerResponse) Resume(ctx context.Context, client *LRORetrysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LRORetrysClient.DeleteProvisioning202Accepted200Succeeded", token, client.pl, client.deleteProvisioning202Accepted200SucceededHandleError)
	if err != nil {
		return err
	}
	poller := &LRORetrysDeleteProvisioning202Accepted200SucceededPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LRORetrysDeleteProvisioning202Accepted200SucceededResponse contains the response from method LRORetrys.DeleteProvisioning202Accepted200Succeeded.
type LRORetrysDeleteProvisioning202Accepted200SucceededResponse struct {
	LRORetrysDeleteProvisioning202Accepted200SucceededResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LRORetrysDeleteProvisioning202Accepted200SucceededResult contains the result from method LRORetrys.DeleteProvisioning202Accepted200Succeeded.
type LRORetrysDeleteProvisioning202Accepted200SucceededResult struct {
	Product
}

// LRORetrysPost202Retry200PollerResponse contains the response from method LRORetrys.Post202Retry200.
type LRORetrysPost202Retry200PollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LRORetrysPost202Retry200Poller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LRORetrysPost202Retry200PollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LRORetrysPost202Retry200Response, error) {
	respType := LRORetrysPost202Retry200Response{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LRORetrysPost202Retry200PollerResponse from the provided client and resume token.
func (l *LRORetrysPost202Retry200PollerResponse) Resume(ctx context.Context, client *LRORetrysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LRORetrysClient.Post202Retry200", token, client.pl, client.post202Retry200HandleError)
	if err != nil {
		return err
	}
	poller := &LRORetrysPost202Retry200Poller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LRORetrysPost202Retry200Response contains the response from method LRORetrys.Post202Retry200.
type LRORetrysPost202Retry200Response struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LRORetrysPostAsyncRelativeRetrySucceededPollerResponse contains the response from method LRORetrys.PostAsyncRelativeRetrySucceeded.
type LRORetrysPostAsyncRelativeRetrySucceededPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LRORetrysPostAsyncRelativeRetrySucceededPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LRORetrysPostAsyncRelativeRetrySucceededPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LRORetrysPostAsyncRelativeRetrySucceededResponse, error) {
	respType := LRORetrysPostAsyncRelativeRetrySucceededResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LRORetrysPostAsyncRelativeRetrySucceededPollerResponse from the provided client and resume token.
func (l *LRORetrysPostAsyncRelativeRetrySucceededPollerResponse) Resume(ctx context.Context, client *LRORetrysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LRORetrysClient.PostAsyncRelativeRetrySucceeded", token, client.pl, client.postAsyncRelativeRetrySucceededHandleError)
	if err != nil {
		return err
	}
	poller := &LRORetrysPostAsyncRelativeRetrySucceededPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LRORetrysPostAsyncRelativeRetrySucceededResponse contains the response from method LRORetrys.PostAsyncRelativeRetrySucceeded.
type LRORetrysPostAsyncRelativeRetrySucceededResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LRORetrysPut201CreatingSucceeded200PollerResponse contains the response from method LRORetrys.Put201CreatingSucceeded200.
type LRORetrysPut201CreatingSucceeded200PollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LRORetrysPut201CreatingSucceeded200Poller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LRORetrysPut201CreatingSucceeded200PollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LRORetrysPut201CreatingSucceeded200Response, error) {
	respType := LRORetrysPut201CreatingSucceeded200Response{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Product)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LRORetrysPut201CreatingSucceeded200PollerResponse from the provided client and resume token.
func (l *LRORetrysPut201CreatingSucceeded200PollerResponse) Resume(ctx context.Context, client *LRORetrysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LRORetrysClient.Put201CreatingSucceeded200", token, client.pl, client.put201CreatingSucceeded200HandleError)
	if err != nil {
		return err
	}
	poller := &LRORetrysPut201CreatingSucceeded200Poller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LRORetrysPut201CreatingSucceeded200Response contains the response from method LRORetrys.Put201CreatingSucceeded200.
type LRORetrysPut201CreatingSucceeded200Response struct {
	LRORetrysPut201CreatingSucceeded200Result
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LRORetrysPut201CreatingSucceeded200Result contains the result from method LRORetrys.Put201CreatingSucceeded200.
type LRORetrysPut201CreatingSucceeded200Result struct {
	Product
}

// LRORetrysPutAsyncRelativeRetrySucceededPollerResponse contains the response from method LRORetrys.PutAsyncRelativeRetrySucceeded.
type LRORetrysPutAsyncRelativeRetrySucceededPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LRORetrysPutAsyncRelativeRetrySucceededPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LRORetrysPutAsyncRelativeRetrySucceededPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LRORetrysPutAsyncRelativeRetrySucceededResponse, error) {
	respType := LRORetrysPutAsyncRelativeRetrySucceededResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Product)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LRORetrysPutAsyncRelativeRetrySucceededPollerResponse from the provided client and resume token.
func (l *LRORetrysPutAsyncRelativeRetrySucceededPollerResponse) Resume(ctx context.Context, client *LRORetrysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LRORetrysClient.PutAsyncRelativeRetrySucceeded", token, client.pl, client.putAsyncRelativeRetrySucceededHandleError)
	if err != nil {
		return err
	}
	poller := &LRORetrysPutAsyncRelativeRetrySucceededPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LRORetrysPutAsyncRelativeRetrySucceededResponse contains the response from method LRORetrys.PutAsyncRelativeRetrySucceeded.
type LRORetrysPutAsyncRelativeRetrySucceededResponse struct {
	LRORetrysPutAsyncRelativeRetrySucceededResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LRORetrysPutAsyncRelativeRetrySucceededResult contains the result from method LRORetrys.PutAsyncRelativeRetrySucceeded.
type LRORetrysPutAsyncRelativeRetrySucceededResult struct {
	Product
}

// LROSADsDelete202NonRetry400PollerResponse contains the response from method LROSADs.Delete202NonRetry400.
type LROSADsDelete202NonRetry400PollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROSADsDelete202NonRetry400Poller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROSADsDelete202NonRetry400PollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROSADsDelete202NonRetry400Response, error) {
	respType := LROSADsDelete202NonRetry400Response{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROSADsDelete202NonRetry400PollerResponse from the provided client and resume token.
func (l *LROSADsDelete202NonRetry400PollerResponse) Resume(ctx context.Context, client *LROSADsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROSADsClient.Delete202NonRetry400", token, client.pl, client.delete202NonRetry400HandleError)
	if err != nil {
		return err
	}
	poller := &LROSADsDelete202NonRetry400Poller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROSADsDelete202NonRetry400Response contains the response from method LROSADs.Delete202NonRetry400.
type LROSADsDelete202NonRetry400Response struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROSADsDelete202RetryInvalidHeaderPollerResponse contains the response from method LROSADs.Delete202RetryInvalidHeader.
type LROSADsDelete202RetryInvalidHeaderPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROSADsDelete202RetryInvalidHeaderPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROSADsDelete202RetryInvalidHeaderPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROSADsDelete202RetryInvalidHeaderResponse, error) {
	respType := LROSADsDelete202RetryInvalidHeaderResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROSADsDelete202RetryInvalidHeaderPollerResponse from the provided client and resume token.
func (l *LROSADsDelete202RetryInvalidHeaderPollerResponse) Resume(ctx context.Context, client *LROSADsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROSADsClient.Delete202RetryInvalidHeader", token, client.pl, client.delete202RetryInvalidHeaderHandleError)
	if err != nil {
		return err
	}
	poller := &LROSADsDelete202RetryInvalidHeaderPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROSADsDelete202RetryInvalidHeaderResponse contains the response from method LROSADs.Delete202RetryInvalidHeader.
type LROSADsDelete202RetryInvalidHeaderResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROSADsDelete204SucceededPollerResponse contains the response from method LROSADs.Delete204Succeeded.
type LROSADsDelete204SucceededPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROSADsDelete204SucceededPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROSADsDelete204SucceededPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROSADsDelete204SucceededResponse, error) {
	respType := LROSADsDelete204SucceededResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROSADsDelete204SucceededPollerResponse from the provided client and resume token.
func (l *LROSADsDelete204SucceededPollerResponse) Resume(ctx context.Context, client *LROSADsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROSADsClient.Delete204Succeeded", token, client.pl, client.delete204SucceededHandleError)
	if err != nil {
		return err
	}
	poller := &LROSADsDelete204SucceededPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROSADsDelete204SucceededResponse contains the response from method LROSADs.Delete204Succeeded.
type LROSADsDelete204SucceededResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROSADsDeleteAsyncRelativeRetry400PollerResponse contains the response from method LROSADs.DeleteAsyncRelativeRetry400.
type LROSADsDeleteAsyncRelativeRetry400PollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROSADsDeleteAsyncRelativeRetry400Poller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROSADsDeleteAsyncRelativeRetry400PollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROSADsDeleteAsyncRelativeRetry400Response, error) {
	respType := LROSADsDeleteAsyncRelativeRetry400Response{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROSADsDeleteAsyncRelativeRetry400PollerResponse from the provided client and resume token.
func (l *LROSADsDeleteAsyncRelativeRetry400PollerResponse) Resume(ctx context.Context, client *LROSADsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROSADsClient.DeleteAsyncRelativeRetry400", token, client.pl, client.deleteAsyncRelativeRetry400HandleError)
	if err != nil {
		return err
	}
	poller := &LROSADsDeleteAsyncRelativeRetry400Poller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROSADsDeleteAsyncRelativeRetry400Response contains the response from method LROSADs.DeleteAsyncRelativeRetry400.
type LROSADsDeleteAsyncRelativeRetry400Response struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROSADsDeleteAsyncRelativeRetryInvalidHeaderPollerResponse contains the response from method LROSADs.DeleteAsyncRelativeRetryInvalidHeader.
type LROSADsDeleteAsyncRelativeRetryInvalidHeaderPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROSADsDeleteAsyncRelativeRetryInvalidHeaderPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROSADsDeleteAsyncRelativeRetryInvalidHeaderPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROSADsDeleteAsyncRelativeRetryInvalidHeaderResponse, error) {
	respType := LROSADsDeleteAsyncRelativeRetryInvalidHeaderResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROSADsDeleteAsyncRelativeRetryInvalidHeaderPollerResponse from the provided client and resume token.
func (l *LROSADsDeleteAsyncRelativeRetryInvalidHeaderPollerResponse) Resume(ctx context.Context, client *LROSADsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROSADsClient.DeleteAsyncRelativeRetryInvalidHeader", token, client.pl, client.deleteAsyncRelativeRetryInvalidHeaderHandleError)
	if err != nil {
		return err
	}
	poller := &LROSADsDeleteAsyncRelativeRetryInvalidHeaderPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROSADsDeleteAsyncRelativeRetryInvalidHeaderResponse contains the response from method LROSADs.DeleteAsyncRelativeRetryInvalidHeader.
type LROSADsDeleteAsyncRelativeRetryInvalidHeaderResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROSADsDeleteAsyncRelativeRetryInvalidJSONPollingPollerResponse contains the response from method LROSADs.DeleteAsyncRelativeRetryInvalidJSONPolling.
type LROSADsDeleteAsyncRelativeRetryInvalidJSONPollingPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROSADsDeleteAsyncRelativeRetryInvalidJSONPollingPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROSADsDeleteAsyncRelativeRetryInvalidJSONPollingPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROSADsDeleteAsyncRelativeRetryInvalidJSONPollingResponse, error) {
	respType := LROSADsDeleteAsyncRelativeRetryInvalidJSONPollingResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROSADsDeleteAsyncRelativeRetryInvalidJSONPollingPollerResponse from the provided client and resume token.
func (l *LROSADsDeleteAsyncRelativeRetryInvalidJSONPollingPollerResponse) Resume(ctx context.Context, client *LROSADsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROSADsClient.DeleteAsyncRelativeRetryInvalidJSONPolling", token, client.pl, client.deleteAsyncRelativeRetryInvalidJSONPollingHandleError)
	if err != nil {
		return err
	}
	poller := &LROSADsDeleteAsyncRelativeRetryInvalidJSONPollingPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROSADsDeleteAsyncRelativeRetryInvalidJSONPollingResponse contains the response from method LROSADs.DeleteAsyncRelativeRetryInvalidJSONPolling.
type LROSADsDeleteAsyncRelativeRetryInvalidJSONPollingResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROSADsDeleteAsyncRelativeRetryNoStatusPollerResponse contains the response from method LROSADs.DeleteAsyncRelativeRetryNoStatus.
type LROSADsDeleteAsyncRelativeRetryNoStatusPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROSADsDeleteAsyncRelativeRetryNoStatusPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROSADsDeleteAsyncRelativeRetryNoStatusPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROSADsDeleteAsyncRelativeRetryNoStatusResponse, error) {
	respType := LROSADsDeleteAsyncRelativeRetryNoStatusResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROSADsDeleteAsyncRelativeRetryNoStatusPollerResponse from the provided client and resume token.
func (l *LROSADsDeleteAsyncRelativeRetryNoStatusPollerResponse) Resume(ctx context.Context, client *LROSADsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROSADsClient.DeleteAsyncRelativeRetryNoStatus", token, client.pl, client.deleteAsyncRelativeRetryNoStatusHandleError)
	if err != nil {
		return err
	}
	poller := &LROSADsDeleteAsyncRelativeRetryNoStatusPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROSADsDeleteAsyncRelativeRetryNoStatusResponse contains the response from method LROSADs.DeleteAsyncRelativeRetryNoStatus.
type LROSADsDeleteAsyncRelativeRetryNoStatusResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROSADsDeleteNonRetry400PollerResponse contains the response from method LROSADs.DeleteNonRetry400.
type LROSADsDeleteNonRetry400PollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROSADsDeleteNonRetry400Poller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROSADsDeleteNonRetry400PollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROSADsDeleteNonRetry400Response, error) {
	respType := LROSADsDeleteNonRetry400Response{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROSADsDeleteNonRetry400PollerResponse from the provided client and resume token.
func (l *LROSADsDeleteNonRetry400PollerResponse) Resume(ctx context.Context, client *LROSADsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROSADsClient.DeleteNonRetry400", token, client.pl, client.deleteNonRetry400HandleError)
	if err != nil {
		return err
	}
	poller := &LROSADsDeleteNonRetry400Poller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROSADsDeleteNonRetry400Response contains the response from method LROSADs.DeleteNonRetry400.
type LROSADsDeleteNonRetry400Response struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROSADsPost202NoLocationPollerResponse contains the response from method LROSADs.Post202NoLocation.
type LROSADsPost202NoLocationPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROSADsPost202NoLocationPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROSADsPost202NoLocationPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROSADsPost202NoLocationResponse, error) {
	respType := LROSADsPost202NoLocationResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROSADsPost202NoLocationPollerResponse from the provided client and resume token.
func (l *LROSADsPost202NoLocationPollerResponse) Resume(ctx context.Context, client *LROSADsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROSADsClient.Post202NoLocation", token, client.pl, client.post202NoLocationHandleError)
	if err != nil {
		return err
	}
	poller := &LROSADsPost202NoLocationPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROSADsPost202NoLocationResponse contains the response from method LROSADs.Post202NoLocation.
type LROSADsPost202NoLocationResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROSADsPost202NonRetry400PollerResponse contains the response from method LROSADs.Post202NonRetry400.
type LROSADsPost202NonRetry400PollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROSADsPost202NonRetry400Poller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROSADsPost202NonRetry400PollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROSADsPost202NonRetry400Response, error) {
	respType := LROSADsPost202NonRetry400Response{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROSADsPost202NonRetry400PollerResponse from the provided client and resume token.
func (l *LROSADsPost202NonRetry400PollerResponse) Resume(ctx context.Context, client *LROSADsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROSADsClient.Post202NonRetry400", token, client.pl, client.post202NonRetry400HandleError)
	if err != nil {
		return err
	}
	poller := &LROSADsPost202NonRetry400Poller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROSADsPost202NonRetry400Response contains the response from method LROSADs.Post202NonRetry400.
type LROSADsPost202NonRetry400Response struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROSADsPost202RetryInvalidHeaderPollerResponse contains the response from method LROSADs.Post202RetryInvalidHeader.
type LROSADsPost202RetryInvalidHeaderPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROSADsPost202RetryInvalidHeaderPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROSADsPost202RetryInvalidHeaderPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROSADsPost202RetryInvalidHeaderResponse, error) {
	respType := LROSADsPost202RetryInvalidHeaderResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROSADsPost202RetryInvalidHeaderPollerResponse from the provided client and resume token.
func (l *LROSADsPost202RetryInvalidHeaderPollerResponse) Resume(ctx context.Context, client *LROSADsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROSADsClient.Post202RetryInvalidHeader", token, client.pl, client.post202RetryInvalidHeaderHandleError)
	if err != nil {
		return err
	}
	poller := &LROSADsPost202RetryInvalidHeaderPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROSADsPost202RetryInvalidHeaderResponse contains the response from method LROSADs.Post202RetryInvalidHeader.
type LROSADsPost202RetryInvalidHeaderResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROSADsPostAsyncRelativeRetry400PollerResponse contains the response from method LROSADs.PostAsyncRelativeRetry400.
type LROSADsPostAsyncRelativeRetry400PollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROSADsPostAsyncRelativeRetry400Poller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROSADsPostAsyncRelativeRetry400PollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROSADsPostAsyncRelativeRetry400Response, error) {
	respType := LROSADsPostAsyncRelativeRetry400Response{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROSADsPostAsyncRelativeRetry400PollerResponse from the provided client and resume token.
func (l *LROSADsPostAsyncRelativeRetry400PollerResponse) Resume(ctx context.Context, client *LROSADsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROSADsClient.PostAsyncRelativeRetry400", token, client.pl, client.postAsyncRelativeRetry400HandleError)
	if err != nil {
		return err
	}
	poller := &LROSADsPostAsyncRelativeRetry400Poller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROSADsPostAsyncRelativeRetry400Response contains the response from method LROSADs.PostAsyncRelativeRetry400.
type LROSADsPostAsyncRelativeRetry400Response struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROSADsPostAsyncRelativeRetryInvalidHeaderPollerResponse contains the response from method LROSADs.PostAsyncRelativeRetryInvalidHeader.
type LROSADsPostAsyncRelativeRetryInvalidHeaderPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROSADsPostAsyncRelativeRetryInvalidHeaderPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROSADsPostAsyncRelativeRetryInvalidHeaderPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROSADsPostAsyncRelativeRetryInvalidHeaderResponse, error) {
	respType := LROSADsPostAsyncRelativeRetryInvalidHeaderResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROSADsPostAsyncRelativeRetryInvalidHeaderPollerResponse from the provided client and resume token.
func (l *LROSADsPostAsyncRelativeRetryInvalidHeaderPollerResponse) Resume(ctx context.Context, client *LROSADsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROSADsClient.PostAsyncRelativeRetryInvalidHeader", token, client.pl, client.postAsyncRelativeRetryInvalidHeaderHandleError)
	if err != nil {
		return err
	}
	poller := &LROSADsPostAsyncRelativeRetryInvalidHeaderPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROSADsPostAsyncRelativeRetryInvalidHeaderResponse contains the response from method LROSADs.PostAsyncRelativeRetryInvalidHeader.
type LROSADsPostAsyncRelativeRetryInvalidHeaderResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROSADsPostAsyncRelativeRetryInvalidJSONPollingPollerResponse contains the response from method LROSADs.PostAsyncRelativeRetryInvalidJSONPolling.
type LROSADsPostAsyncRelativeRetryInvalidJSONPollingPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROSADsPostAsyncRelativeRetryInvalidJSONPollingPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROSADsPostAsyncRelativeRetryInvalidJSONPollingPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROSADsPostAsyncRelativeRetryInvalidJSONPollingResponse, error) {
	respType := LROSADsPostAsyncRelativeRetryInvalidJSONPollingResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROSADsPostAsyncRelativeRetryInvalidJSONPollingPollerResponse from the provided client and resume token.
func (l *LROSADsPostAsyncRelativeRetryInvalidJSONPollingPollerResponse) Resume(ctx context.Context, client *LROSADsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROSADsClient.PostAsyncRelativeRetryInvalidJSONPolling", token, client.pl, client.postAsyncRelativeRetryInvalidJSONPollingHandleError)
	if err != nil {
		return err
	}
	poller := &LROSADsPostAsyncRelativeRetryInvalidJSONPollingPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROSADsPostAsyncRelativeRetryInvalidJSONPollingResponse contains the response from method LROSADs.PostAsyncRelativeRetryInvalidJSONPolling.
type LROSADsPostAsyncRelativeRetryInvalidJSONPollingResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROSADsPostAsyncRelativeRetryNoPayloadPollerResponse contains the response from method LROSADs.PostAsyncRelativeRetryNoPayload.
type LROSADsPostAsyncRelativeRetryNoPayloadPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROSADsPostAsyncRelativeRetryNoPayloadPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROSADsPostAsyncRelativeRetryNoPayloadPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROSADsPostAsyncRelativeRetryNoPayloadResponse, error) {
	respType := LROSADsPostAsyncRelativeRetryNoPayloadResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROSADsPostAsyncRelativeRetryNoPayloadPollerResponse from the provided client and resume token.
func (l *LROSADsPostAsyncRelativeRetryNoPayloadPollerResponse) Resume(ctx context.Context, client *LROSADsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROSADsClient.PostAsyncRelativeRetryNoPayload", token, client.pl, client.postAsyncRelativeRetryNoPayloadHandleError)
	if err != nil {
		return err
	}
	poller := &LROSADsPostAsyncRelativeRetryNoPayloadPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROSADsPostAsyncRelativeRetryNoPayloadResponse contains the response from method LROSADs.PostAsyncRelativeRetryNoPayload.
type LROSADsPostAsyncRelativeRetryNoPayloadResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROSADsPostNonRetry400PollerResponse contains the response from method LROSADs.PostNonRetry400.
type LROSADsPostNonRetry400PollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROSADsPostNonRetry400Poller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROSADsPostNonRetry400PollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROSADsPostNonRetry400Response, error) {
	respType := LROSADsPostNonRetry400Response{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROSADsPostNonRetry400PollerResponse from the provided client and resume token.
func (l *LROSADsPostNonRetry400PollerResponse) Resume(ctx context.Context, client *LROSADsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROSADsClient.PostNonRetry400", token, client.pl, client.postNonRetry400HandleError)
	if err != nil {
		return err
	}
	poller := &LROSADsPostNonRetry400Poller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROSADsPostNonRetry400Response contains the response from method LROSADs.PostNonRetry400.
type LROSADsPostNonRetry400Response struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROSADsPut200InvalidJSONPollerResponse contains the response from method LROSADs.Put200InvalidJSON.
type LROSADsPut200InvalidJSONPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROSADsPut200InvalidJSONPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROSADsPut200InvalidJSONPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROSADsPut200InvalidJSONResponse, error) {
	respType := LROSADsPut200InvalidJSONResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Product)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROSADsPut200InvalidJSONPollerResponse from the provided client and resume token.
func (l *LROSADsPut200InvalidJSONPollerResponse) Resume(ctx context.Context, client *LROSADsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROSADsClient.Put200InvalidJSON", token, client.pl, client.put200InvalidJSONHandleError)
	if err != nil {
		return err
	}
	poller := &LROSADsPut200InvalidJSONPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROSADsPut200InvalidJSONResponse contains the response from method LROSADs.Put200InvalidJSON.
type LROSADsPut200InvalidJSONResponse struct {
	LROSADsPut200InvalidJSONResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROSADsPut200InvalidJSONResult contains the result from method LROSADs.Put200InvalidJSON.
type LROSADsPut200InvalidJSONResult struct {
	Product
}

// LROSADsPutAsyncRelativeRetry400PollerResponse contains the response from method LROSADs.PutAsyncRelativeRetry400.
type LROSADsPutAsyncRelativeRetry400PollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROSADsPutAsyncRelativeRetry400Poller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROSADsPutAsyncRelativeRetry400PollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROSADsPutAsyncRelativeRetry400Response, error) {
	respType := LROSADsPutAsyncRelativeRetry400Response{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Product)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROSADsPutAsyncRelativeRetry400PollerResponse from the provided client and resume token.
func (l *LROSADsPutAsyncRelativeRetry400PollerResponse) Resume(ctx context.Context, client *LROSADsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROSADsClient.PutAsyncRelativeRetry400", token, client.pl, client.putAsyncRelativeRetry400HandleError)
	if err != nil {
		return err
	}
	poller := &LROSADsPutAsyncRelativeRetry400Poller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROSADsPutAsyncRelativeRetry400Response contains the response from method LROSADs.PutAsyncRelativeRetry400.
type LROSADsPutAsyncRelativeRetry400Response struct {
	LROSADsPutAsyncRelativeRetry400Result
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROSADsPutAsyncRelativeRetry400Result contains the result from method LROSADs.PutAsyncRelativeRetry400.
type LROSADsPutAsyncRelativeRetry400Result struct {
	Product
}

// LROSADsPutAsyncRelativeRetryInvalidHeaderPollerResponse contains the response from method LROSADs.PutAsyncRelativeRetryInvalidHeader.
type LROSADsPutAsyncRelativeRetryInvalidHeaderPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROSADsPutAsyncRelativeRetryInvalidHeaderPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROSADsPutAsyncRelativeRetryInvalidHeaderPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROSADsPutAsyncRelativeRetryInvalidHeaderResponse, error) {
	respType := LROSADsPutAsyncRelativeRetryInvalidHeaderResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Product)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROSADsPutAsyncRelativeRetryInvalidHeaderPollerResponse from the provided client and resume token.
func (l *LROSADsPutAsyncRelativeRetryInvalidHeaderPollerResponse) Resume(ctx context.Context, client *LROSADsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROSADsClient.PutAsyncRelativeRetryInvalidHeader", token, client.pl, client.putAsyncRelativeRetryInvalidHeaderHandleError)
	if err != nil {
		return err
	}
	poller := &LROSADsPutAsyncRelativeRetryInvalidHeaderPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROSADsPutAsyncRelativeRetryInvalidHeaderResponse contains the response from method LROSADs.PutAsyncRelativeRetryInvalidHeader.
type LROSADsPutAsyncRelativeRetryInvalidHeaderResponse struct {
	LROSADsPutAsyncRelativeRetryInvalidHeaderResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROSADsPutAsyncRelativeRetryInvalidHeaderResult contains the result from method LROSADs.PutAsyncRelativeRetryInvalidHeader.
type LROSADsPutAsyncRelativeRetryInvalidHeaderResult struct {
	Product
}

// LROSADsPutAsyncRelativeRetryInvalidJSONPollingPollerResponse contains the response from method LROSADs.PutAsyncRelativeRetryInvalidJSONPolling.
type LROSADsPutAsyncRelativeRetryInvalidJSONPollingPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROSADsPutAsyncRelativeRetryInvalidJSONPollingPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROSADsPutAsyncRelativeRetryInvalidJSONPollingPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROSADsPutAsyncRelativeRetryInvalidJSONPollingResponse, error) {
	respType := LROSADsPutAsyncRelativeRetryInvalidJSONPollingResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Product)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROSADsPutAsyncRelativeRetryInvalidJSONPollingPollerResponse from the provided client and resume token.
func (l *LROSADsPutAsyncRelativeRetryInvalidJSONPollingPollerResponse) Resume(ctx context.Context, client *LROSADsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROSADsClient.PutAsyncRelativeRetryInvalidJSONPolling", token, client.pl, client.putAsyncRelativeRetryInvalidJSONPollingHandleError)
	if err != nil {
		return err
	}
	poller := &LROSADsPutAsyncRelativeRetryInvalidJSONPollingPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROSADsPutAsyncRelativeRetryInvalidJSONPollingResponse contains the response from method LROSADs.PutAsyncRelativeRetryInvalidJSONPolling.
type LROSADsPutAsyncRelativeRetryInvalidJSONPollingResponse struct {
	LROSADsPutAsyncRelativeRetryInvalidJSONPollingResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROSADsPutAsyncRelativeRetryInvalidJSONPollingResult contains the result from method LROSADs.PutAsyncRelativeRetryInvalidJSONPolling.
type LROSADsPutAsyncRelativeRetryInvalidJSONPollingResult struct {
	Product
}

// LROSADsPutAsyncRelativeRetryNoStatusPayloadPollerResponse contains the response from method LROSADs.PutAsyncRelativeRetryNoStatusPayload.
type LROSADsPutAsyncRelativeRetryNoStatusPayloadPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROSADsPutAsyncRelativeRetryNoStatusPayloadPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROSADsPutAsyncRelativeRetryNoStatusPayloadPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROSADsPutAsyncRelativeRetryNoStatusPayloadResponse, error) {
	respType := LROSADsPutAsyncRelativeRetryNoStatusPayloadResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Product)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROSADsPutAsyncRelativeRetryNoStatusPayloadPollerResponse from the provided client and resume token.
func (l *LROSADsPutAsyncRelativeRetryNoStatusPayloadPollerResponse) Resume(ctx context.Context, client *LROSADsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROSADsClient.PutAsyncRelativeRetryNoStatusPayload", token, client.pl, client.putAsyncRelativeRetryNoStatusPayloadHandleError)
	if err != nil {
		return err
	}
	poller := &LROSADsPutAsyncRelativeRetryNoStatusPayloadPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROSADsPutAsyncRelativeRetryNoStatusPayloadResponse contains the response from method LROSADs.PutAsyncRelativeRetryNoStatusPayload.
type LROSADsPutAsyncRelativeRetryNoStatusPayloadResponse struct {
	LROSADsPutAsyncRelativeRetryNoStatusPayloadResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROSADsPutAsyncRelativeRetryNoStatusPayloadResult contains the result from method LROSADs.PutAsyncRelativeRetryNoStatusPayload.
type LROSADsPutAsyncRelativeRetryNoStatusPayloadResult struct {
	Product
}

// LROSADsPutAsyncRelativeRetryNoStatusPollerResponse contains the response from method LROSADs.PutAsyncRelativeRetryNoStatus.
type LROSADsPutAsyncRelativeRetryNoStatusPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROSADsPutAsyncRelativeRetryNoStatusPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROSADsPutAsyncRelativeRetryNoStatusPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROSADsPutAsyncRelativeRetryNoStatusResponse, error) {
	respType := LROSADsPutAsyncRelativeRetryNoStatusResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Product)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROSADsPutAsyncRelativeRetryNoStatusPollerResponse from the provided client and resume token.
func (l *LROSADsPutAsyncRelativeRetryNoStatusPollerResponse) Resume(ctx context.Context, client *LROSADsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROSADsClient.PutAsyncRelativeRetryNoStatus", token, client.pl, client.putAsyncRelativeRetryNoStatusHandleError)
	if err != nil {
		return err
	}
	poller := &LROSADsPutAsyncRelativeRetryNoStatusPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROSADsPutAsyncRelativeRetryNoStatusResponse contains the response from method LROSADs.PutAsyncRelativeRetryNoStatus.
type LROSADsPutAsyncRelativeRetryNoStatusResponse struct {
	LROSADsPutAsyncRelativeRetryNoStatusResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROSADsPutAsyncRelativeRetryNoStatusResult contains the result from method LROSADs.PutAsyncRelativeRetryNoStatus.
type LROSADsPutAsyncRelativeRetryNoStatusResult struct {
	Product
}

// LROSADsPutError201NoProvisioningStatePayloadPollerResponse contains the response from method LROSADs.PutError201NoProvisioningStatePayload.
type LROSADsPutError201NoProvisioningStatePayloadPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROSADsPutError201NoProvisioningStatePayloadPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROSADsPutError201NoProvisioningStatePayloadPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROSADsPutError201NoProvisioningStatePayloadResponse, error) {
	respType := LROSADsPutError201NoProvisioningStatePayloadResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Product)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROSADsPutError201NoProvisioningStatePayloadPollerResponse from the provided client and resume token.
func (l *LROSADsPutError201NoProvisioningStatePayloadPollerResponse) Resume(ctx context.Context, client *LROSADsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROSADsClient.PutError201NoProvisioningStatePayload", token, client.pl, client.putError201NoProvisioningStatePayloadHandleError)
	if err != nil {
		return err
	}
	poller := &LROSADsPutError201NoProvisioningStatePayloadPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROSADsPutError201NoProvisioningStatePayloadResponse contains the response from method LROSADs.PutError201NoProvisioningStatePayload.
type LROSADsPutError201NoProvisioningStatePayloadResponse struct {
	LROSADsPutError201NoProvisioningStatePayloadResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROSADsPutError201NoProvisioningStatePayloadResult contains the result from method LROSADs.PutError201NoProvisioningStatePayload.
type LROSADsPutError201NoProvisioningStatePayloadResult struct {
	Product
}

// LROSADsPutNonRetry201Creating400InvalidJSONPollerResponse contains the response from method LROSADs.PutNonRetry201Creating400InvalidJSON.
type LROSADsPutNonRetry201Creating400InvalidJSONPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROSADsPutNonRetry201Creating400InvalidJSONPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROSADsPutNonRetry201Creating400InvalidJSONPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROSADsPutNonRetry201Creating400InvalidJSONResponse, error) {
	respType := LROSADsPutNonRetry201Creating400InvalidJSONResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Product)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROSADsPutNonRetry201Creating400InvalidJSONPollerResponse from the provided client and resume token.
func (l *LROSADsPutNonRetry201Creating400InvalidJSONPollerResponse) Resume(ctx context.Context, client *LROSADsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROSADsClient.PutNonRetry201Creating400InvalidJSON", token, client.pl, client.putNonRetry201Creating400InvalidJSONHandleError)
	if err != nil {
		return err
	}
	poller := &LROSADsPutNonRetry201Creating400InvalidJSONPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROSADsPutNonRetry201Creating400InvalidJSONResponse contains the response from method LROSADs.PutNonRetry201Creating400InvalidJSON.
type LROSADsPutNonRetry201Creating400InvalidJSONResponse struct {
	LROSADsPutNonRetry201Creating400InvalidJSONResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROSADsPutNonRetry201Creating400InvalidJSONResult contains the result from method LROSADs.PutNonRetry201Creating400InvalidJSON.
type LROSADsPutNonRetry201Creating400InvalidJSONResult struct {
	Product
}

// LROSADsPutNonRetry201Creating400PollerResponse contains the response from method LROSADs.PutNonRetry201Creating400.
type LROSADsPutNonRetry201Creating400PollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROSADsPutNonRetry201Creating400Poller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROSADsPutNonRetry201Creating400PollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROSADsPutNonRetry201Creating400Response, error) {
	respType := LROSADsPutNonRetry201Creating400Response{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Product)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROSADsPutNonRetry201Creating400PollerResponse from the provided client and resume token.
func (l *LROSADsPutNonRetry201Creating400PollerResponse) Resume(ctx context.Context, client *LROSADsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROSADsClient.PutNonRetry201Creating400", token, client.pl, client.putNonRetry201Creating400HandleError)
	if err != nil {
		return err
	}
	poller := &LROSADsPutNonRetry201Creating400Poller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROSADsPutNonRetry201Creating400Response contains the response from method LROSADs.PutNonRetry201Creating400.
type LROSADsPutNonRetry201Creating400Response struct {
	LROSADsPutNonRetry201Creating400Result
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROSADsPutNonRetry201Creating400Result contains the result from method LROSADs.PutNonRetry201Creating400.
type LROSADsPutNonRetry201Creating400Result struct {
	Product
}

// LROSADsPutNonRetry400PollerResponse contains the response from method LROSADs.PutNonRetry400.
type LROSADsPutNonRetry400PollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROSADsPutNonRetry400Poller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROSADsPutNonRetry400PollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROSADsPutNonRetry400Response, error) {
	respType := LROSADsPutNonRetry400Response{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Product)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROSADsPutNonRetry400PollerResponse from the provided client and resume token.
func (l *LROSADsPutNonRetry400PollerResponse) Resume(ctx context.Context, client *LROSADsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROSADsClient.PutNonRetry400", token, client.pl, client.putNonRetry400HandleError)
	if err != nil {
		return err
	}
	poller := &LROSADsPutNonRetry400Poller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROSADsPutNonRetry400Response contains the response from method LROSADs.PutNonRetry400.
type LROSADsPutNonRetry400Response struct {
	LROSADsPutNonRetry400Result
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROSADsPutNonRetry400Result contains the result from method LROSADs.PutNonRetry400.
type LROSADsPutNonRetry400Result struct {
	Product
}

// LROsCustomHeaderPost202Retry200PollerResponse contains the response from method LROsCustomHeader.Post202Retry200.
type LROsCustomHeaderPost202Retry200PollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROsCustomHeaderPost202Retry200Poller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROsCustomHeaderPost202Retry200PollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROsCustomHeaderPost202Retry200Response, error) {
	respType := LROsCustomHeaderPost202Retry200Response{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROsCustomHeaderPost202Retry200PollerResponse from the provided client and resume token.
func (l *LROsCustomHeaderPost202Retry200PollerResponse) Resume(ctx context.Context, client *LROsCustomHeaderClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROsCustomHeaderClient.Post202Retry200", token, client.pl, client.post202Retry200HandleError)
	if err != nil {
		return err
	}
	poller := &LROsCustomHeaderPost202Retry200Poller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROsCustomHeaderPost202Retry200Response contains the response from method LROsCustomHeader.Post202Retry200.
type LROsCustomHeaderPost202Retry200Response struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROsCustomHeaderPostAsyncRetrySucceededPollerResponse contains the response from method LROsCustomHeader.PostAsyncRetrySucceeded.
type LROsCustomHeaderPostAsyncRetrySucceededPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROsCustomHeaderPostAsyncRetrySucceededPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROsCustomHeaderPostAsyncRetrySucceededPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROsCustomHeaderPostAsyncRetrySucceededResponse, error) {
	respType := LROsCustomHeaderPostAsyncRetrySucceededResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROsCustomHeaderPostAsyncRetrySucceededPollerResponse from the provided client and resume token.
func (l *LROsCustomHeaderPostAsyncRetrySucceededPollerResponse) Resume(ctx context.Context, client *LROsCustomHeaderClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROsCustomHeaderClient.PostAsyncRetrySucceeded", token, client.pl, client.postAsyncRetrySucceededHandleError)
	if err != nil {
		return err
	}
	poller := &LROsCustomHeaderPostAsyncRetrySucceededPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROsCustomHeaderPostAsyncRetrySucceededResponse contains the response from method LROsCustomHeader.PostAsyncRetrySucceeded.
type LROsCustomHeaderPostAsyncRetrySucceededResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROsCustomHeaderPut201CreatingSucceeded200PollerResponse contains the response from method LROsCustomHeader.Put201CreatingSucceeded200.
type LROsCustomHeaderPut201CreatingSucceeded200PollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROsCustomHeaderPut201CreatingSucceeded200Poller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROsCustomHeaderPut201CreatingSucceeded200PollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROsCustomHeaderPut201CreatingSucceeded200Response, error) {
	respType := LROsCustomHeaderPut201CreatingSucceeded200Response{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Product)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROsCustomHeaderPut201CreatingSucceeded200PollerResponse from the provided client and resume token.
func (l *LROsCustomHeaderPut201CreatingSucceeded200PollerResponse) Resume(ctx context.Context, client *LROsCustomHeaderClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROsCustomHeaderClient.Put201CreatingSucceeded200", token, client.pl, client.put201CreatingSucceeded200HandleError)
	if err != nil {
		return err
	}
	poller := &LROsCustomHeaderPut201CreatingSucceeded200Poller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROsCustomHeaderPut201CreatingSucceeded200Response contains the response from method LROsCustomHeader.Put201CreatingSucceeded200.
type LROsCustomHeaderPut201CreatingSucceeded200Response struct {
	LROsCustomHeaderPut201CreatingSucceeded200Result
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROsCustomHeaderPut201CreatingSucceeded200Result contains the result from method LROsCustomHeader.Put201CreatingSucceeded200.
type LROsCustomHeaderPut201CreatingSucceeded200Result struct {
	Product
}

// LROsCustomHeaderPutAsyncRetrySucceededPollerResponse contains the response from method LROsCustomHeader.PutAsyncRetrySucceeded.
type LROsCustomHeaderPutAsyncRetrySucceededPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROsCustomHeaderPutAsyncRetrySucceededPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROsCustomHeaderPutAsyncRetrySucceededPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROsCustomHeaderPutAsyncRetrySucceededResponse, error) {
	respType := LROsCustomHeaderPutAsyncRetrySucceededResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Product)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROsCustomHeaderPutAsyncRetrySucceededPollerResponse from the provided client and resume token.
func (l *LROsCustomHeaderPutAsyncRetrySucceededPollerResponse) Resume(ctx context.Context, client *LROsCustomHeaderClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROsCustomHeaderClient.PutAsyncRetrySucceeded", token, client.pl, client.putAsyncRetrySucceededHandleError)
	if err != nil {
		return err
	}
	poller := &LROsCustomHeaderPutAsyncRetrySucceededPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROsCustomHeaderPutAsyncRetrySucceededResponse contains the response from method LROsCustomHeader.PutAsyncRetrySucceeded.
type LROsCustomHeaderPutAsyncRetrySucceededResponse struct {
	LROsCustomHeaderPutAsyncRetrySucceededResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROsCustomHeaderPutAsyncRetrySucceededResult contains the result from method LROsCustomHeader.PutAsyncRetrySucceeded.
type LROsCustomHeaderPutAsyncRetrySucceededResult struct {
	Product
}

// LROsDelete202NoRetry204PollerResponse contains the response from method LROs.Delete202NoRetry204.
type LROsDelete202NoRetry204PollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROsDelete202NoRetry204Poller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROsDelete202NoRetry204PollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROsDelete202NoRetry204Response, error) {
	respType := LROsDelete202NoRetry204Response{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Product)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROsDelete202NoRetry204PollerResponse from the provided client and resume token.
func (l *LROsDelete202NoRetry204PollerResponse) Resume(ctx context.Context, client *LROsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROsClient.Delete202NoRetry204", token, client.pl, client.delete202NoRetry204HandleError)
	if err != nil {
		return err
	}
	poller := &LROsDelete202NoRetry204Poller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROsDelete202NoRetry204Response contains the response from method LROs.Delete202NoRetry204.
type LROsDelete202NoRetry204Response struct {
	LROsDelete202NoRetry204Result
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROsDelete202NoRetry204Result contains the result from method LROs.Delete202NoRetry204.
type LROsDelete202NoRetry204Result struct {
	Product
}

// LROsDelete202Retry200PollerResponse contains the response from method LROs.Delete202Retry200.
type LROsDelete202Retry200PollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROsDelete202Retry200Poller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROsDelete202Retry200PollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROsDelete202Retry200Response, error) {
	respType := LROsDelete202Retry200Response{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Product)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROsDelete202Retry200PollerResponse from the provided client and resume token.
func (l *LROsDelete202Retry200PollerResponse) Resume(ctx context.Context, client *LROsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROsClient.Delete202Retry200", token, client.pl, client.delete202Retry200HandleError)
	if err != nil {
		return err
	}
	poller := &LROsDelete202Retry200Poller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROsDelete202Retry200Response contains the response from method LROs.Delete202Retry200.
type LROsDelete202Retry200Response struct {
	LROsDelete202Retry200Result
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROsDelete202Retry200Result contains the result from method LROs.Delete202Retry200.
type LROsDelete202Retry200Result struct {
	Product
}

// LROsDelete204SucceededPollerResponse contains the response from method LROs.Delete204Succeeded.
type LROsDelete204SucceededPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROsDelete204SucceededPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROsDelete204SucceededPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROsDelete204SucceededResponse, error) {
	respType := LROsDelete204SucceededResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROsDelete204SucceededPollerResponse from the provided client and resume token.
func (l *LROsDelete204SucceededPollerResponse) Resume(ctx context.Context, client *LROsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROsClient.Delete204Succeeded", token, client.pl, client.delete204SucceededHandleError)
	if err != nil {
		return err
	}
	poller := &LROsDelete204SucceededPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROsDelete204SucceededResponse contains the response from method LROs.Delete204Succeeded.
type LROsDelete204SucceededResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROsDeleteAsyncNoHeaderInRetryPollerResponse contains the response from method LROs.DeleteAsyncNoHeaderInRetry.
type LROsDeleteAsyncNoHeaderInRetryPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROsDeleteAsyncNoHeaderInRetryPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROsDeleteAsyncNoHeaderInRetryPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROsDeleteAsyncNoHeaderInRetryResponse, error) {
	respType := LROsDeleteAsyncNoHeaderInRetryResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROsDeleteAsyncNoHeaderInRetryPollerResponse from the provided client and resume token.
func (l *LROsDeleteAsyncNoHeaderInRetryPollerResponse) Resume(ctx context.Context, client *LROsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROsClient.DeleteAsyncNoHeaderInRetry", token, client.pl, client.deleteAsyncNoHeaderInRetryHandleError)
	if err != nil {
		return err
	}
	poller := &LROsDeleteAsyncNoHeaderInRetryPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROsDeleteAsyncNoHeaderInRetryResponse contains the response from method LROs.DeleteAsyncNoHeaderInRetry.
type LROsDeleteAsyncNoHeaderInRetryResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROsDeleteAsyncNoRetrySucceededPollerResponse contains the response from method LROs.DeleteAsyncNoRetrySucceeded.
type LROsDeleteAsyncNoRetrySucceededPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROsDeleteAsyncNoRetrySucceededPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROsDeleteAsyncNoRetrySucceededPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROsDeleteAsyncNoRetrySucceededResponse, error) {
	respType := LROsDeleteAsyncNoRetrySucceededResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROsDeleteAsyncNoRetrySucceededPollerResponse from the provided client and resume token.
func (l *LROsDeleteAsyncNoRetrySucceededPollerResponse) Resume(ctx context.Context, client *LROsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROsClient.DeleteAsyncNoRetrySucceeded", token, client.pl, client.deleteAsyncNoRetrySucceededHandleError)
	if err != nil {
		return err
	}
	poller := &LROsDeleteAsyncNoRetrySucceededPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROsDeleteAsyncNoRetrySucceededResponse contains the response from method LROs.DeleteAsyncNoRetrySucceeded.
type LROsDeleteAsyncNoRetrySucceededResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROsDeleteAsyncRetryFailedPollerResponse contains the response from method LROs.DeleteAsyncRetryFailed.
type LROsDeleteAsyncRetryFailedPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROsDeleteAsyncRetryFailedPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROsDeleteAsyncRetryFailedPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROsDeleteAsyncRetryFailedResponse, error) {
	respType := LROsDeleteAsyncRetryFailedResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROsDeleteAsyncRetryFailedPollerResponse from the provided client and resume token.
func (l *LROsDeleteAsyncRetryFailedPollerResponse) Resume(ctx context.Context, client *LROsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROsClient.DeleteAsyncRetryFailed", token, client.pl, client.deleteAsyncRetryFailedHandleError)
	if err != nil {
		return err
	}
	poller := &LROsDeleteAsyncRetryFailedPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROsDeleteAsyncRetryFailedResponse contains the response from method LROs.DeleteAsyncRetryFailed.
type LROsDeleteAsyncRetryFailedResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROsDeleteAsyncRetrySucceededPollerResponse contains the response from method LROs.DeleteAsyncRetrySucceeded.
type LROsDeleteAsyncRetrySucceededPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROsDeleteAsyncRetrySucceededPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROsDeleteAsyncRetrySucceededPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROsDeleteAsyncRetrySucceededResponse, error) {
	respType := LROsDeleteAsyncRetrySucceededResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROsDeleteAsyncRetrySucceededPollerResponse from the provided client and resume token.
func (l *LROsDeleteAsyncRetrySucceededPollerResponse) Resume(ctx context.Context, client *LROsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROsClient.DeleteAsyncRetrySucceeded", token, client.pl, client.deleteAsyncRetrySucceededHandleError)
	if err != nil {
		return err
	}
	poller := &LROsDeleteAsyncRetrySucceededPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROsDeleteAsyncRetrySucceededResponse contains the response from method LROs.DeleteAsyncRetrySucceeded.
type LROsDeleteAsyncRetrySucceededResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROsDeleteAsyncRetrycanceledPollerResponse contains the response from method LROs.DeleteAsyncRetrycanceled.
type LROsDeleteAsyncRetrycanceledPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROsDeleteAsyncRetrycanceledPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROsDeleteAsyncRetrycanceledPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROsDeleteAsyncRetrycanceledResponse, error) {
	respType := LROsDeleteAsyncRetrycanceledResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROsDeleteAsyncRetrycanceledPollerResponse from the provided client and resume token.
func (l *LROsDeleteAsyncRetrycanceledPollerResponse) Resume(ctx context.Context, client *LROsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROsClient.DeleteAsyncRetrycanceled", token, client.pl, client.deleteAsyncRetrycanceledHandleError)
	if err != nil {
		return err
	}
	poller := &LROsDeleteAsyncRetrycanceledPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROsDeleteAsyncRetrycanceledResponse contains the response from method LROs.DeleteAsyncRetrycanceled.
type LROsDeleteAsyncRetrycanceledResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROsDeleteNoHeaderInRetryPollerResponse contains the response from method LROs.DeleteNoHeaderInRetry.
type LROsDeleteNoHeaderInRetryPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROsDeleteNoHeaderInRetryPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROsDeleteNoHeaderInRetryPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROsDeleteNoHeaderInRetryResponse, error) {
	respType := LROsDeleteNoHeaderInRetryResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROsDeleteNoHeaderInRetryPollerResponse from the provided client and resume token.
func (l *LROsDeleteNoHeaderInRetryPollerResponse) Resume(ctx context.Context, client *LROsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROsClient.DeleteNoHeaderInRetry", token, client.pl, client.deleteNoHeaderInRetryHandleError)
	if err != nil {
		return err
	}
	poller := &LROsDeleteNoHeaderInRetryPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROsDeleteNoHeaderInRetryResponse contains the response from method LROs.DeleteNoHeaderInRetry.
type LROsDeleteNoHeaderInRetryResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROsDeleteProvisioning202Accepted200SucceededPollerResponse contains the response from method LROs.DeleteProvisioning202Accepted200Succeeded.
type LROsDeleteProvisioning202Accepted200SucceededPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROsDeleteProvisioning202Accepted200SucceededPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROsDeleteProvisioning202Accepted200SucceededPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROsDeleteProvisioning202Accepted200SucceededResponse, error) {
	respType := LROsDeleteProvisioning202Accepted200SucceededResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Product)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROsDeleteProvisioning202Accepted200SucceededPollerResponse from the provided client and resume token.
func (l *LROsDeleteProvisioning202Accepted200SucceededPollerResponse) Resume(ctx context.Context, client *LROsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROsClient.DeleteProvisioning202Accepted200Succeeded", token, client.pl, client.deleteProvisioning202Accepted200SucceededHandleError)
	if err != nil {
		return err
	}
	poller := &LROsDeleteProvisioning202Accepted200SucceededPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROsDeleteProvisioning202Accepted200SucceededResponse contains the response from method LROs.DeleteProvisioning202Accepted200Succeeded.
type LROsDeleteProvisioning202Accepted200SucceededResponse struct {
	LROsDeleteProvisioning202Accepted200SucceededResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROsDeleteProvisioning202Accepted200SucceededResult contains the result from method LROs.DeleteProvisioning202Accepted200Succeeded.
type LROsDeleteProvisioning202Accepted200SucceededResult struct {
	Product
}

// LROsDeleteProvisioning202DeletingFailed200PollerResponse contains the response from method LROs.DeleteProvisioning202DeletingFailed200.
type LROsDeleteProvisioning202DeletingFailed200PollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROsDeleteProvisioning202DeletingFailed200Poller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROsDeleteProvisioning202DeletingFailed200PollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROsDeleteProvisioning202DeletingFailed200Response, error) {
	respType := LROsDeleteProvisioning202DeletingFailed200Response{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Product)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROsDeleteProvisioning202DeletingFailed200PollerResponse from the provided client and resume token.
func (l *LROsDeleteProvisioning202DeletingFailed200PollerResponse) Resume(ctx context.Context, client *LROsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROsClient.DeleteProvisioning202DeletingFailed200", token, client.pl, client.deleteProvisioning202DeletingFailed200HandleError)
	if err != nil {
		return err
	}
	poller := &LROsDeleteProvisioning202DeletingFailed200Poller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROsDeleteProvisioning202DeletingFailed200Response contains the response from method LROs.DeleteProvisioning202DeletingFailed200.
type LROsDeleteProvisioning202DeletingFailed200Response struct {
	LROsDeleteProvisioning202DeletingFailed200Result
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROsDeleteProvisioning202DeletingFailed200Result contains the result from method LROs.DeleteProvisioning202DeletingFailed200.
type LROsDeleteProvisioning202DeletingFailed200Result struct {
	Product
}

// LROsDeleteProvisioning202Deletingcanceled200PollerResponse contains the response from method LROs.DeleteProvisioning202Deletingcanceled200.
type LROsDeleteProvisioning202Deletingcanceled200PollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROsDeleteProvisioning202Deletingcanceled200Poller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROsDeleteProvisioning202Deletingcanceled200PollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROsDeleteProvisioning202Deletingcanceled200Response, error) {
	respType := LROsDeleteProvisioning202Deletingcanceled200Response{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Product)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROsDeleteProvisioning202Deletingcanceled200PollerResponse from the provided client and resume token.
func (l *LROsDeleteProvisioning202Deletingcanceled200PollerResponse) Resume(ctx context.Context, client *LROsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROsClient.DeleteProvisioning202Deletingcanceled200", token, client.pl, client.deleteProvisioning202Deletingcanceled200HandleError)
	if err != nil {
		return err
	}
	poller := &LROsDeleteProvisioning202Deletingcanceled200Poller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROsDeleteProvisioning202Deletingcanceled200Response contains the response from method LROs.DeleteProvisioning202Deletingcanceled200.
type LROsDeleteProvisioning202Deletingcanceled200Response struct {
	LROsDeleteProvisioning202Deletingcanceled200Result
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROsDeleteProvisioning202Deletingcanceled200Result contains the result from method LROs.DeleteProvisioning202Deletingcanceled200.
type LROsDeleteProvisioning202Deletingcanceled200Result struct {
	Product
}

// LROsPatch200SucceededIgnoreHeadersPollerResponse contains the response from method LROs.Patch200SucceededIgnoreHeaders.
type LROsPatch200SucceededIgnoreHeadersPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROsPatch200SucceededIgnoreHeadersPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROsPatch200SucceededIgnoreHeadersPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROsPatch200SucceededIgnoreHeadersResponse, error) {
	respType := LROsPatch200SucceededIgnoreHeadersResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Product)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROsPatch200SucceededIgnoreHeadersPollerResponse from the provided client and resume token.
func (l *LROsPatch200SucceededIgnoreHeadersPollerResponse) Resume(ctx context.Context, client *LROsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROsClient.Patch200SucceededIgnoreHeaders", token, client.pl, client.patch200SucceededIgnoreHeadersHandleError)
	if err != nil {
		return err
	}
	poller := &LROsPatch200SucceededIgnoreHeadersPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROsPatch200SucceededIgnoreHeadersResponse contains the response from method LROs.Patch200SucceededIgnoreHeaders.
type LROsPatch200SucceededIgnoreHeadersResponse struct {
	LROsPatch200SucceededIgnoreHeadersResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROsPatch200SucceededIgnoreHeadersResult contains the result from method LROs.Patch200SucceededIgnoreHeaders.
type LROsPatch200SucceededIgnoreHeadersResult struct {
	Product
}

// LROsPost200WithPayloadPollerResponse contains the response from method LROs.Post200WithPayload.
type LROsPost200WithPayloadPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROsPost200WithPayloadPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROsPost200WithPayloadPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROsPost200WithPayloadResponse, error) {
	respType := LROsPost200WithPayloadResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.SKU)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROsPost200WithPayloadPollerResponse from the provided client and resume token.
func (l *LROsPost200WithPayloadPollerResponse) Resume(ctx context.Context, client *LROsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROsClient.Post200WithPayload", token, client.pl, client.post200WithPayloadHandleError)
	if err != nil {
		return err
	}
	poller := &LROsPost200WithPayloadPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROsPost200WithPayloadResponse contains the response from method LROs.Post200WithPayload.
type LROsPost200WithPayloadResponse struct {
	LROsPost200WithPayloadResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROsPost200WithPayloadResult contains the result from method LROs.Post200WithPayload.
type LROsPost200WithPayloadResult struct {
	SKU
}

// LROsPost202ListPollerResponse contains the response from method LROs.Post202List.
type LROsPost202ListPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROsPost202ListPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROsPost202ListPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROsPost202ListResponse, error) {
	respType := LROsPost202ListResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ProductArray)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROsPost202ListPollerResponse from the provided client and resume token.
func (l *LROsPost202ListPollerResponse) Resume(ctx context.Context, client *LROsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROsClient.Post202List", token, client.pl, client.post202ListHandleError)
	if err != nil {
		return err
	}
	poller := &LROsPost202ListPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROsPost202ListResponse contains the response from method LROs.Post202List.
type LROsPost202ListResponse struct {
	LROsPost202ListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROsPost202ListResult contains the result from method LROs.Post202List.
type LROsPost202ListResult struct {
	// Array of Product
	ProductArray []*Product
}

// LROsPost202NoRetry204PollerResponse contains the response from method LROs.Post202NoRetry204.
type LROsPost202NoRetry204PollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROsPost202NoRetry204Poller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROsPost202NoRetry204PollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROsPost202NoRetry204Response, error) {
	respType := LROsPost202NoRetry204Response{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Product)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROsPost202NoRetry204PollerResponse from the provided client and resume token.
func (l *LROsPost202NoRetry204PollerResponse) Resume(ctx context.Context, client *LROsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROsClient.Post202NoRetry204", token, client.pl, client.post202NoRetry204HandleError)
	if err != nil {
		return err
	}
	poller := &LROsPost202NoRetry204Poller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROsPost202NoRetry204Response contains the response from method LROs.Post202NoRetry204.
type LROsPost202NoRetry204Response struct {
	LROsPost202NoRetry204Result
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROsPost202NoRetry204Result contains the result from method LROs.Post202NoRetry204.
type LROsPost202NoRetry204Result struct {
	Product
}

// LROsPost202Retry200PollerResponse contains the response from method LROs.Post202Retry200.
type LROsPost202Retry200PollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROsPost202Retry200Poller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROsPost202Retry200PollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROsPost202Retry200Response, error) {
	respType := LROsPost202Retry200Response{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROsPost202Retry200PollerResponse from the provided client and resume token.
func (l *LROsPost202Retry200PollerResponse) Resume(ctx context.Context, client *LROsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROsClient.Post202Retry200", token, client.pl, client.post202Retry200HandleError)
	if err != nil {
		return err
	}
	poller := &LROsPost202Retry200Poller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROsPost202Retry200Response contains the response from method LROs.Post202Retry200.
type LROsPost202Retry200Response struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROsPostAsyncNoRetrySucceededPollerResponse contains the response from method LROs.PostAsyncNoRetrySucceeded.
type LROsPostAsyncNoRetrySucceededPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROsPostAsyncNoRetrySucceededPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROsPostAsyncNoRetrySucceededPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROsPostAsyncNoRetrySucceededResponse, error) {
	respType := LROsPostAsyncNoRetrySucceededResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Product)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROsPostAsyncNoRetrySucceededPollerResponse from the provided client and resume token.
func (l *LROsPostAsyncNoRetrySucceededPollerResponse) Resume(ctx context.Context, client *LROsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROsClient.PostAsyncNoRetrySucceeded", token, client.pl, client.postAsyncNoRetrySucceededHandleError)
	if err != nil {
		return err
	}
	poller := &LROsPostAsyncNoRetrySucceededPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROsPostAsyncNoRetrySucceededResponse contains the response from method LROs.PostAsyncNoRetrySucceeded.
type LROsPostAsyncNoRetrySucceededResponse struct {
	LROsPostAsyncNoRetrySucceededResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROsPostAsyncNoRetrySucceededResult contains the result from method LROs.PostAsyncNoRetrySucceeded.
type LROsPostAsyncNoRetrySucceededResult struct {
	Product
}

// LROsPostAsyncRetryFailedPollerResponse contains the response from method LROs.PostAsyncRetryFailed.
type LROsPostAsyncRetryFailedPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROsPostAsyncRetryFailedPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROsPostAsyncRetryFailedPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROsPostAsyncRetryFailedResponse, error) {
	respType := LROsPostAsyncRetryFailedResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROsPostAsyncRetryFailedPollerResponse from the provided client and resume token.
func (l *LROsPostAsyncRetryFailedPollerResponse) Resume(ctx context.Context, client *LROsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROsClient.PostAsyncRetryFailed", token, client.pl, client.postAsyncRetryFailedHandleError)
	if err != nil {
		return err
	}
	poller := &LROsPostAsyncRetryFailedPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROsPostAsyncRetryFailedResponse contains the response from method LROs.PostAsyncRetryFailed.
type LROsPostAsyncRetryFailedResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROsPostAsyncRetrySucceededPollerResponse contains the response from method LROs.PostAsyncRetrySucceeded.
type LROsPostAsyncRetrySucceededPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROsPostAsyncRetrySucceededPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROsPostAsyncRetrySucceededPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROsPostAsyncRetrySucceededResponse, error) {
	respType := LROsPostAsyncRetrySucceededResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Product)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROsPostAsyncRetrySucceededPollerResponse from the provided client and resume token.
func (l *LROsPostAsyncRetrySucceededPollerResponse) Resume(ctx context.Context, client *LROsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROsClient.PostAsyncRetrySucceeded", token, client.pl, client.postAsyncRetrySucceededHandleError)
	if err != nil {
		return err
	}
	poller := &LROsPostAsyncRetrySucceededPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROsPostAsyncRetrySucceededResponse contains the response from method LROs.PostAsyncRetrySucceeded.
type LROsPostAsyncRetrySucceededResponse struct {
	LROsPostAsyncRetrySucceededResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROsPostAsyncRetrySucceededResult contains the result from method LROs.PostAsyncRetrySucceeded.
type LROsPostAsyncRetrySucceededResult struct {
	Product
}

// LROsPostAsyncRetrycanceledPollerResponse contains the response from method LROs.PostAsyncRetrycanceled.
type LROsPostAsyncRetrycanceledPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROsPostAsyncRetrycanceledPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROsPostAsyncRetrycanceledPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROsPostAsyncRetrycanceledResponse, error) {
	respType := LROsPostAsyncRetrycanceledResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROsPostAsyncRetrycanceledPollerResponse from the provided client and resume token.
func (l *LROsPostAsyncRetrycanceledPollerResponse) Resume(ctx context.Context, client *LROsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROsClient.PostAsyncRetrycanceled", token, client.pl, client.postAsyncRetrycanceledHandleError)
	if err != nil {
		return err
	}
	poller := &LROsPostAsyncRetrycanceledPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROsPostAsyncRetrycanceledResponse contains the response from method LROs.PostAsyncRetrycanceled.
type LROsPostAsyncRetrycanceledResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROsPostDoubleHeadersFinalAzureHeaderGetDefaultPollerResponse contains the response from method LROs.PostDoubleHeadersFinalAzureHeaderGetDefault.
type LROsPostDoubleHeadersFinalAzureHeaderGetDefaultPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROsPostDoubleHeadersFinalAzureHeaderGetDefaultPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROsPostDoubleHeadersFinalAzureHeaderGetDefaultPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROsPostDoubleHeadersFinalAzureHeaderGetDefaultResponse, error) {
	respType := LROsPostDoubleHeadersFinalAzureHeaderGetDefaultResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Product)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROsPostDoubleHeadersFinalAzureHeaderGetDefaultPollerResponse from the provided client and resume token.
func (l *LROsPostDoubleHeadersFinalAzureHeaderGetDefaultPollerResponse) Resume(ctx context.Context, client *LROsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROsClient.PostDoubleHeadersFinalAzureHeaderGetDefault", token, client.pl, client.postDoubleHeadersFinalAzureHeaderGetDefaultHandleError)
	if err != nil {
		return err
	}
	poller := &LROsPostDoubleHeadersFinalAzureHeaderGetDefaultPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROsPostDoubleHeadersFinalAzureHeaderGetDefaultResponse contains the response from method LROs.PostDoubleHeadersFinalAzureHeaderGetDefault.
type LROsPostDoubleHeadersFinalAzureHeaderGetDefaultResponse struct {
	LROsPostDoubleHeadersFinalAzureHeaderGetDefaultResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROsPostDoubleHeadersFinalAzureHeaderGetDefaultResult contains the result from method LROs.PostDoubleHeadersFinalAzureHeaderGetDefault.
type LROsPostDoubleHeadersFinalAzureHeaderGetDefaultResult struct {
	Product
}

// LROsPostDoubleHeadersFinalAzureHeaderGetPollerResponse contains the response from method LROs.PostDoubleHeadersFinalAzureHeaderGet.
type LROsPostDoubleHeadersFinalAzureHeaderGetPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROsPostDoubleHeadersFinalAzureHeaderGetPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROsPostDoubleHeadersFinalAzureHeaderGetPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROsPostDoubleHeadersFinalAzureHeaderGetResponse, error) {
	respType := LROsPostDoubleHeadersFinalAzureHeaderGetResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Product)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROsPostDoubleHeadersFinalAzureHeaderGetPollerResponse from the provided client and resume token.
func (l *LROsPostDoubleHeadersFinalAzureHeaderGetPollerResponse) Resume(ctx context.Context, client *LROsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROsClient.PostDoubleHeadersFinalAzureHeaderGet", token, client.pl, client.postDoubleHeadersFinalAzureHeaderGetHandleError)
	if err != nil {
		return err
	}
	poller := &LROsPostDoubleHeadersFinalAzureHeaderGetPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROsPostDoubleHeadersFinalAzureHeaderGetResponse contains the response from method LROs.PostDoubleHeadersFinalAzureHeaderGet.
type LROsPostDoubleHeadersFinalAzureHeaderGetResponse struct {
	LROsPostDoubleHeadersFinalAzureHeaderGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROsPostDoubleHeadersFinalAzureHeaderGetResult contains the result from method LROs.PostDoubleHeadersFinalAzureHeaderGet.
type LROsPostDoubleHeadersFinalAzureHeaderGetResult struct {
	Product
}

// LROsPostDoubleHeadersFinalLocationGetPollerResponse contains the response from method LROs.PostDoubleHeadersFinalLocationGet.
type LROsPostDoubleHeadersFinalLocationGetPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROsPostDoubleHeadersFinalLocationGetPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROsPostDoubleHeadersFinalLocationGetPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROsPostDoubleHeadersFinalLocationGetResponse, error) {
	respType := LROsPostDoubleHeadersFinalLocationGetResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Product)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROsPostDoubleHeadersFinalLocationGetPollerResponse from the provided client and resume token.
func (l *LROsPostDoubleHeadersFinalLocationGetPollerResponse) Resume(ctx context.Context, client *LROsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROsClient.PostDoubleHeadersFinalLocationGet", token, client.pl, client.postDoubleHeadersFinalLocationGetHandleError)
	if err != nil {
		return err
	}
	poller := &LROsPostDoubleHeadersFinalLocationGetPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROsPostDoubleHeadersFinalLocationGetResponse contains the response from method LROs.PostDoubleHeadersFinalLocationGet.
type LROsPostDoubleHeadersFinalLocationGetResponse struct {
	LROsPostDoubleHeadersFinalLocationGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROsPostDoubleHeadersFinalLocationGetResult contains the result from method LROs.PostDoubleHeadersFinalLocationGet.
type LROsPostDoubleHeadersFinalLocationGetResult struct {
	Product
}

// LROsPut200Acceptedcanceled200PollerResponse contains the response from method LROs.Put200Acceptedcanceled200.
type LROsPut200Acceptedcanceled200PollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROsPut200Acceptedcanceled200Poller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROsPut200Acceptedcanceled200PollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROsPut200Acceptedcanceled200Response, error) {
	respType := LROsPut200Acceptedcanceled200Response{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Product)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROsPut200Acceptedcanceled200PollerResponse from the provided client and resume token.
func (l *LROsPut200Acceptedcanceled200PollerResponse) Resume(ctx context.Context, client *LROsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROsClient.Put200Acceptedcanceled200", token, client.pl, client.put200Acceptedcanceled200HandleError)
	if err != nil {
		return err
	}
	poller := &LROsPut200Acceptedcanceled200Poller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROsPut200Acceptedcanceled200Response contains the response from method LROs.Put200Acceptedcanceled200.
type LROsPut200Acceptedcanceled200Response struct {
	LROsPut200Acceptedcanceled200Result
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROsPut200Acceptedcanceled200Result contains the result from method LROs.Put200Acceptedcanceled200.
type LROsPut200Acceptedcanceled200Result struct {
	Product
}

// LROsPut200SucceededNoStatePollerResponse contains the response from method LROs.Put200SucceededNoState.
type LROsPut200SucceededNoStatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROsPut200SucceededNoStatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROsPut200SucceededNoStatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROsPut200SucceededNoStateResponse, error) {
	respType := LROsPut200SucceededNoStateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Product)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROsPut200SucceededNoStatePollerResponse from the provided client and resume token.
func (l *LROsPut200SucceededNoStatePollerResponse) Resume(ctx context.Context, client *LROsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROsClient.Put200SucceededNoState", token, client.pl, client.put200SucceededNoStateHandleError)
	if err != nil {
		return err
	}
	poller := &LROsPut200SucceededNoStatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROsPut200SucceededNoStateResponse contains the response from method LROs.Put200SucceededNoState.
type LROsPut200SucceededNoStateResponse struct {
	LROsPut200SucceededNoStateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROsPut200SucceededNoStateResult contains the result from method LROs.Put200SucceededNoState.
type LROsPut200SucceededNoStateResult struct {
	Product
}

// LROsPut200SucceededPollerResponse contains the response from method LROs.Put200Succeeded.
type LROsPut200SucceededPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROsPut200SucceededPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROsPut200SucceededPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROsPut200SucceededResponse, error) {
	respType := LROsPut200SucceededResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Product)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROsPut200SucceededPollerResponse from the provided client and resume token.
func (l *LROsPut200SucceededPollerResponse) Resume(ctx context.Context, client *LROsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROsClient.Put200Succeeded", token, client.pl, client.put200SucceededHandleError)
	if err != nil {
		return err
	}
	poller := &LROsPut200SucceededPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROsPut200SucceededResponse contains the response from method LROs.Put200Succeeded.
type LROsPut200SucceededResponse struct {
	LROsPut200SucceededResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROsPut200SucceededResult contains the result from method LROs.Put200Succeeded.
type LROsPut200SucceededResult struct {
	Product
}

// LROsPut200UpdatingSucceeded204PollerResponse contains the response from method LROs.Put200UpdatingSucceeded204.
type LROsPut200UpdatingSucceeded204PollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROsPut200UpdatingSucceeded204Poller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROsPut200UpdatingSucceeded204PollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROsPut200UpdatingSucceeded204Response, error) {
	respType := LROsPut200UpdatingSucceeded204Response{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Product)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROsPut200UpdatingSucceeded204PollerResponse from the provided client and resume token.
func (l *LROsPut200UpdatingSucceeded204PollerResponse) Resume(ctx context.Context, client *LROsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROsClient.Put200UpdatingSucceeded204", token, client.pl, client.put200UpdatingSucceeded204HandleError)
	if err != nil {
		return err
	}
	poller := &LROsPut200UpdatingSucceeded204Poller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROsPut200UpdatingSucceeded204Response contains the response from method LROs.Put200UpdatingSucceeded204.
type LROsPut200UpdatingSucceeded204Response struct {
	LROsPut200UpdatingSucceeded204Result
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROsPut200UpdatingSucceeded204Result contains the result from method LROs.Put200UpdatingSucceeded204.
type LROsPut200UpdatingSucceeded204Result struct {
	Product
}

// LROsPut201CreatingFailed200PollerResponse contains the response from method LROs.Put201CreatingFailed200.
type LROsPut201CreatingFailed200PollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROsPut201CreatingFailed200Poller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROsPut201CreatingFailed200PollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROsPut201CreatingFailed200Response, error) {
	respType := LROsPut201CreatingFailed200Response{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Product)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROsPut201CreatingFailed200PollerResponse from the provided client and resume token.
func (l *LROsPut201CreatingFailed200PollerResponse) Resume(ctx context.Context, client *LROsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROsClient.Put201CreatingFailed200", token, client.pl, client.put201CreatingFailed200HandleError)
	if err != nil {
		return err
	}
	poller := &LROsPut201CreatingFailed200Poller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROsPut201CreatingFailed200Response contains the response from method LROs.Put201CreatingFailed200.
type LROsPut201CreatingFailed200Response struct {
	LROsPut201CreatingFailed200Result
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROsPut201CreatingFailed200Result contains the result from method LROs.Put201CreatingFailed200.
type LROsPut201CreatingFailed200Result struct {
	Product
}

// LROsPut201CreatingSucceeded200PollerResponse contains the response from method LROs.Put201CreatingSucceeded200.
type LROsPut201CreatingSucceeded200PollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROsPut201CreatingSucceeded200Poller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROsPut201CreatingSucceeded200PollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROsPut201CreatingSucceeded200Response, error) {
	respType := LROsPut201CreatingSucceeded200Response{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Product)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROsPut201CreatingSucceeded200PollerResponse from the provided client and resume token.
func (l *LROsPut201CreatingSucceeded200PollerResponse) Resume(ctx context.Context, client *LROsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROsClient.Put201CreatingSucceeded200", token, client.pl, client.put201CreatingSucceeded200HandleError)
	if err != nil {
		return err
	}
	poller := &LROsPut201CreatingSucceeded200Poller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROsPut201CreatingSucceeded200Response contains the response from method LROs.Put201CreatingSucceeded200.
type LROsPut201CreatingSucceeded200Response struct {
	LROsPut201CreatingSucceeded200Result
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROsPut201CreatingSucceeded200Result contains the result from method LROs.Put201CreatingSucceeded200.
type LROsPut201CreatingSucceeded200Result struct {
	Product
}

// LROsPut201SucceededPollerResponse contains the response from method LROs.Put201Succeeded.
type LROsPut201SucceededPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROsPut201SucceededPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROsPut201SucceededPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROsPut201SucceededResponse, error) {
	respType := LROsPut201SucceededResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Product)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROsPut201SucceededPollerResponse from the provided client and resume token.
func (l *LROsPut201SucceededPollerResponse) Resume(ctx context.Context, client *LROsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROsClient.Put201Succeeded", token, client.pl, client.put201SucceededHandleError)
	if err != nil {
		return err
	}
	poller := &LROsPut201SucceededPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROsPut201SucceededResponse contains the response from method LROs.Put201Succeeded.
type LROsPut201SucceededResponse struct {
	LROsPut201SucceededResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROsPut201SucceededResult contains the result from method LROs.Put201Succeeded.
type LROsPut201SucceededResult struct {
	Product
}

// LROsPut202Retry200PollerResponse contains the response from method LROs.Put202Retry200.
type LROsPut202Retry200PollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROsPut202Retry200Poller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROsPut202Retry200PollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROsPut202Retry200Response, error) {
	respType := LROsPut202Retry200Response{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Product)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROsPut202Retry200PollerResponse from the provided client and resume token.
func (l *LROsPut202Retry200PollerResponse) Resume(ctx context.Context, client *LROsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROsClient.Put202Retry200", token, client.pl, client.put202Retry200HandleError)
	if err != nil {
		return err
	}
	poller := &LROsPut202Retry200Poller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROsPut202Retry200Response contains the response from method LROs.Put202Retry200.
type LROsPut202Retry200Response struct {
	LROsPut202Retry200Result
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROsPut202Retry200Result contains the result from method LROs.Put202Retry200.
type LROsPut202Retry200Result struct {
	Product
}

// LROsPutAsyncNoHeaderInRetryPollerResponse contains the response from method LROs.PutAsyncNoHeaderInRetry.
type LROsPutAsyncNoHeaderInRetryPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROsPutAsyncNoHeaderInRetryPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROsPutAsyncNoHeaderInRetryPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROsPutAsyncNoHeaderInRetryResponse, error) {
	respType := LROsPutAsyncNoHeaderInRetryResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Product)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROsPutAsyncNoHeaderInRetryPollerResponse from the provided client and resume token.
func (l *LROsPutAsyncNoHeaderInRetryPollerResponse) Resume(ctx context.Context, client *LROsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROsClient.PutAsyncNoHeaderInRetry", token, client.pl, client.putAsyncNoHeaderInRetryHandleError)
	if err != nil {
		return err
	}
	poller := &LROsPutAsyncNoHeaderInRetryPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROsPutAsyncNoHeaderInRetryResponse contains the response from method LROs.PutAsyncNoHeaderInRetry.
type LROsPutAsyncNoHeaderInRetryResponse struct {
	LROsPutAsyncNoHeaderInRetryResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROsPutAsyncNoHeaderInRetryResult contains the result from method LROs.PutAsyncNoHeaderInRetry.
type LROsPutAsyncNoHeaderInRetryResult struct {
	Product
}

// LROsPutAsyncNoRetrySucceededPollerResponse contains the response from method LROs.PutAsyncNoRetrySucceeded.
type LROsPutAsyncNoRetrySucceededPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROsPutAsyncNoRetrySucceededPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROsPutAsyncNoRetrySucceededPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROsPutAsyncNoRetrySucceededResponse, error) {
	respType := LROsPutAsyncNoRetrySucceededResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Product)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROsPutAsyncNoRetrySucceededPollerResponse from the provided client and resume token.
func (l *LROsPutAsyncNoRetrySucceededPollerResponse) Resume(ctx context.Context, client *LROsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROsClient.PutAsyncNoRetrySucceeded", token, client.pl, client.putAsyncNoRetrySucceededHandleError)
	if err != nil {
		return err
	}
	poller := &LROsPutAsyncNoRetrySucceededPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROsPutAsyncNoRetrySucceededResponse contains the response from method LROs.PutAsyncNoRetrySucceeded.
type LROsPutAsyncNoRetrySucceededResponse struct {
	LROsPutAsyncNoRetrySucceededResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROsPutAsyncNoRetrySucceededResult contains the result from method LROs.PutAsyncNoRetrySucceeded.
type LROsPutAsyncNoRetrySucceededResult struct {
	Product
}

// LROsPutAsyncNoRetrycanceledPollerResponse contains the response from method LROs.PutAsyncNoRetrycanceled.
type LROsPutAsyncNoRetrycanceledPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROsPutAsyncNoRetrycanceledPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROsPutAsyncNoRetrycanceledPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROsPutAsyncNoRetrycanceledResponse, error) {
	respType := LROsPutAsyncNoRetrycanceledResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Product)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROsPutAsyncNoRetrycanceledPollerResponse from the provided client and resume token.
func (l *LROsPutAsyncNoRetrycanceledPollerResponse) Resume(ctx context.Context, client *LROsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROsClient.PutAsyncNoRetrycanceled", token, client.pl, client.putAsyncNoRetrycanceledHandleError)
	if err != nil {
		return err
	}
	poller := &LROsPutAsyncNoRetrycanceledPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROsPutAsyncNoRetrycanceledResponse contains the response from method LROs.PutAsyncNoRetrycanceled.
type LROsPutAsyncNoRetrycanceledResponse struct {
	LROsPutAsyncNoRetrycanceledResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROsPutAsyncNoRetrycanceledResult contains the result from method LROs.PutAsyncNoRetrycanceled.
type LROsPutAsyncNoRetrycanceledResult struct {
	Product
}

// LROsPutAsyncNonResourcePollerResponse contains the response from method LROs.PutAsyncNonResource.
type LROsPutAsyncNonResourcePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROsPutAsyncNonResourcePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROsPutAsyncNonResourcePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROsPutAsyncNonResourceResponse, error) {
	respType := LROsPutAsyncNonResourceResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.SKU)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROsPutAsyncNonResourcePollerResponse from the provided client and resume token.
func (l *LROsPutAsyncNonResourcePollerResponse) Resume(ctx context.Context, client *LROsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROsClient.PutAsyncNonResource", token, client.pl, client.putAsyncNonResourceHandleError)
	if err != nil {
		return err
	}
	poller := &LROsPutAsyncNonResourcePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROsPutAsyncNonResourceResponse contains the response from method LROs.PutAsyncNonResource.
type LROsPutAsyncNonResourceResponse struct {
	LROsPutAsyncNonResourceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROsPutAsyncNonResourceResult contains the result from method LROs.PutAsyncNonResource.
type LROsPutAsyncNonResourceResult struct {
	SKU
}

// LROsPutAsyncRetryFailedPollerResponse contains the response from method LROs.PutAsyncRetryFailed.
type LROsPutAsyncRetryFailedPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROsPutAsyncRetryFailedPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROsPutAsyncRetryFailedPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROsPutAsyncRetryFailedResponse, error) {
	respType := LROsPutAsyncRetryFailedResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Product)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROsPutAsyncRetryFailedPollerResponse from the provided client and resume token.
func (l *LROsPutAsyncRetryFailedPollerResponse) Resume(ctx context.Context, client *LROsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROsClient.PutAsyncRetryFailed", token, client.pl, client.putAsyncRetryFailedHandleError)
	if err != nil {
		return err
	}
	poller := &LROsPutAsyncRetryFailedPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROsPutAsyncRetryFailedResponse contains the response from method LROs.PutAsyncRetryFailed.
type LROsPutAsyncRetryFailedResponse struct {
	LROsPutAsyncRetryFailedResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROsPutAsyncRetryFailedResult contains the result from method LROs.PutAsyncRetryFailed.
type LROsPutAsyncRetryFailedResult struct {
	Product
}

// LROsPutAsyncRetrySucceededPollerResponse contains the response from method LROs.PutAsyncRetrySucceeded.
type LROsPutAsyncRetrySucceededPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROsPutAsyncRetrySucceededPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROsPutAsyncRetrySucceededPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROsPutAsyncRetrySucceededResponse, error) {
	respType := LROsPutAsyncRetrySucceededResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Product)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROsPutAsyncRetrySucceededPollerResponse from the provided client and resume token.
func (l *LROsPutAsyncRetrySucceededPollerResponse) Resume(ctx context.Context, client *LROsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROsClient.PutAsyncRetrySucceeded", token, client.pl, client.putAsyncRetrySucceededHandleError)
	if err != nil {
		return err
	}
	poller := &LROsPutAsyncRetrySucceededPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROsPutAsyncRetrySucceededResponse contains the response from method LROs.PutAsyncRetrySucceeded.
type LROsPutAsyncRetrySucceededResponse struct {
	LROsPutAsyncRetrySucceededResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROsPutAsyncRetrySucceededResult contains the result from method LROs.PutAsyncRetrySucceeded.
type LROsPutAsyncRetrySucceededResult struct {
	Product
}

// LROsPutAsyncSubResourcePollerResponse contains the response from method LROs.PutAsyncSubResource.
type LROsPutAsyncSubResourcePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROsPutAsyncSubResourcePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROsPutAsyncSubResourcePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROsPutAsyncSubResourceResponse, error) {
	respType := LROsPutAsyncSubResourceResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.SubProduct)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROsPutAsyncSubResourcePollerResponse from the provided client and resume token.
func (l *LROsPutAsyncSubResourcePollerResponse) Resume(ctx context.Context, client *LROsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROsClient.PutAsyncSubResource", token, client.pl, client.putAsyncSubResourceHandleError)
	if err != nil {
		return err
	}
	poller := &LROsPutAsyncSubResourcePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROsPutAsyncSubResourceResponse contains the response from method LROs.PutAsyncSubResource.
type LROsPutAsyncSubResourceResponse struct {
	LROsPutAsyncSubResourceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROsPutAsyncSubResourceResult contains the result from method LROs.PutAsyncSubResource.
type LROsPutAsyncSubResourceResult struct {
	SubProduct
}

// LROsPutNoHeaderInRetryPollerResponse contains the response from method LROs.PutNoHeaderInRetry.
type LROsPutNoHeaderInRetryPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROsPutNoHeaderInRetryPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROsPutNoHeaderInRetryPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROsPutNoHeaderInRetryResponse, error) {
	respType := LROsPutNoHeaderInRetryResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Product)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROsPutNoHeaderInRetryPollerResponse from the provided client and resume token.
func (l *LROsPutNoHeaderInRetryPollerResponse) Resume(ctx context.Context, client *LROsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROsClient.PutNoHeaderInRetry", token, client.pl, client.putNoHeaderInRetryHandleError)
	if err != nil {
		return err
	}
	poller := &LROsPutNoHeaderInRetryPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROsPutNoHeaderInRetryResponse contains the response from method LROs.PutNoHeaderInRetry.
type LROsPutNoHeaderInRetryResponse struct {
	LROsPutNoHeaderInRetryResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROsPutNoHeaderInRetryResult contains the result from method LROs.PutNoHeaderInRetry.
type LROsPutNoHeaderInRetryResult struct {
	Product
}

// LROsPutNonResourcePollerResponse contains the response from method LROs.PutNonResource.
type LROsPutNonResourcePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROsPutNonResourcePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROsPutNonResourcePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROsPutNonResourceResponse, error) {
	respType := LROsPutNonResourceResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.SKU)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROsPutNonResourcePollerResponse from the provided client and resume token.
func (l *LROsPutNonResourcePollerResponse) Resume(ctx context.Context, client *LROsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROsClient.PutNonResource", token, client.pl, client.putNonResourceHandleError)
	if err != nil {
		return err
	}
	poller := &LROsPutNonResourcePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROsPutNonResourceResponse contains the response from method LROs.PutNonResource.
type LROsPutNonResourceResponse struct {
	LROsPutNonResourceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROsPutNonResourceResult contains the result from method LROs.PutNonResource.
type LROsPutNonResourceResult struct {
	SKU
}

// LROsPutSubResourcePollerResponse contains the response from method LROs.PutSubResource.
type LROsPutSubResourcePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LROsPutSubResourcePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l LROsPutSubResourcePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LROsPutSubResourceResponse, error) {
	respType := LROsPutSubResourceResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.SubProduct)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LROsPutSubResourcePollerResponse from the provided client and resume token.
func (l *LROsPutSubResourcePollerResponse) Resume(ctx context.Context, client *LROsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LROsClient.PutSubResource", token, client.pl, client.putSubResourceHandleError)
	if err != nil {
		return err
	}
	poller := &LROsPutSubResourcePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LROsPutSubResourceResponse contains the response from method LROs.PutSubResource.
type LROsPutSubResourceResponse struct {
	LROsPutSubResourceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LROsPutSubResourceResult contains the result from method LROs.PutSubResource.
type LROsPutSubResourceResult struct {
	SubProduct
}
