//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package lrogroup

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
)

// LROSADsClient contains the methods for the LROSADs group.
// Don't use this type directly, use NewLROSADsClient() instead.
type LROSADsClient struct {
	pl runtime.Pipeline
}

// NewLROSADsClient creates a new instance of LROSADsClient with the specified values.
// options - pass nil to accept the default values.
func NewLROSADsClient(options *azcore.ClientOptions) *LROSADsClient {
	if options == nil {
		options = &azcore.ClientOptions{}
	}
	client := &LROSADsClient{
		pl: runtime.NewPipeline(moduleName, moduleVersion, runtime.PipelineOptions{}, options),
	}
	return client
}

// BeginDelete202NonRetry400 - Long running delete request, service returns a 202 with a location header
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROSADsClientBeginDelete202NonRetry400Options contains the optional parameters for the LROSADsClient.BeginDelete202NonRetry400
// method.
func (client *LROSADsClient) BeginDelete202NonRetry400(ctx context.Context, options *LROSADsClientBeginDelete202NonRetry400Options) (LROSADsClientDelete202NonRetry400PollerResponse, error) {
	resp, err := client.delete202NonRetry400(ctx, options)
	if err != nil {
		return LROSADsClientDelete202NonRetry400PollerResponse{}, err
	}
	result := LROSADsClientDelete202NonRetry400PollerResponse{}
	pt, err := armruntime.NewPoller("LROSADsClient.Delete202NonRetry400", "", resp, client.pl)
	if err != nil {
		return LROSADsClientDelete202NonRetry400PollerResponse{}, err
	}
	result.Poller = &LROSADsClientDelete202NonRetry400Poller{
		pt: pt,
	}
	return result, nil
}

// Delete202NonRetry400 - Long running delete request, service returns a 202 with a location header
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROSADsClient) delete202NonRetry400(ctx context.Context, options *LROSADsClientBeginDelete202NonRetry400Options) (*http.Response, error) {
	req, err := client.delete202NonRetry400CreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// delete202NonRetry400CreateRequest creates the Delete202NonRetry400 request.
func (client *LROSADsClient) delete202NonRetry400CreateRequest(ctx context.Context, options *LROSADsClientBeginDelete202NonRetry400Options) (*policy.Request, error) {
	urlPath := "/lro/nonretryerror/delete/202/retry/400"
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// BeginDelete202RetryInvalidHeader - Long running delete request, service returns a 202 to the initial request receing a
// reponse with an invalid 'Location' and 'Retry-After' headers
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROSADsClientBeginDelete202RetryInvalidHeaderOptions contains the optional parameters for the LROSADsClient.BeginDelete202RetryInvalidHeader
// method.
func (client *LROSADsClient) BeginDelete202RetryInvalidHeader(ctx context.Context, options *LROSADsClientBeginDelete202RetryInvalidHeaderOptions) (LROSADsClientDelete202RetryInvalidHeaderPollerResponse, error) {
	resp, err := client.delete202RetryInvalidHeader(ctx, options)
	if err != nil {
		return LROSADsClientDelete202RetryInvalidHeaderPollerResponse{}, err
	}
	result := LROSADsClientDelete202RetryInvalidHeaderPollerResponse{}
	pt, err := armruntime.NewPoller("LROSADsClient.Delete202RetryInvalidHeader", "", resp, client.pl)
	if err != nil {
		return LROSADsClientDelete202RetryInvalidHeaderPollerResponse{}, err
	}
	result.Poller = &LROSADsClientDelete202RetryInvalidHeaderPoller{
		pt: pt,
	}
	return result, nil
}

// Delete202RetryInvalidHeader - Long running delete request, service returns a 202 to the initial request receing a reponse
// with an invalid 'Location' and 'Retry-After' headers
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROSADsClient) delete202RetryInvalidHeader(ctx context.Context, options *LROSADsClientBeginDelete202RetryInvalidHeaderOptions) (*http.Response, error) {
	req, err := client.delete202RetryInvalidHeaderCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// delete202RetryInvalidHeaderCreateRequest creates the Delete202RetryInvalidHeader request.
func (client *LROSADsClient) delete202RetryInvalidHeaderCreateRequest(ctx context.Context, options *LROSADsClientBeginDelete202RetryInvalidHeaderOptions) (*policy.Request, error) {
	urlPath := "/lro/error/delete/202/retry/invalidheader"
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// BeginDelete204Succeeded - Long running delete request, service returns a 204 to the initial request, indicating success.
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROSADsClientBeginDelete204SucceededOptions contains the optional parameters for the LROSADsClient.BeginDelete204Succeeded
// method.
func (client *LROSADsClient) BeginDelete204Succeeded(ctx context.Context, options *LROSADsClientBeginDelete204SucceededOptions) (LROSADsClientDelete204SucceededPollerResponse, error) {
	resp, err := client.delete204Succeeded(ctx, options)
	if err != nil {
		return LROSADsClientDelete204SucceededPollerResponse{}, err
	}
	result := LROSADsClientDelete204SucceededPollerResponse{}
	pt, err := armruntime.NewPoller("LROSADsClient.Delete204Succeeded", "", resp, client.pl)
	if err != nil {
		return LROSADsClientDelete204SucceededPollerResponse{}, err
	}
	result.Poller = &LROSADsClientDelete204SucceededPoller{
		pt: pt,
	}
	return result, nil
}

// Delete204Succeeded - Long running delete request, service returns a 204 to the initial request, indicating success.
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROSADsClient) delete204Succeeded(ctx context.Context, options *LROSADsClientBeginDelete204SucceededOptions) (*http.Response, error) {
	req, err := client.delete204SucceededCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// delete204SucceededCreateRequest creates the Delete204Succeeded request.
func (client *LROSADsClient) delete204SucceededCreateRequest(ctx context.Context, options *LROSADsClientBeginDelete204SucceededOptions) (*policy.Request, error) {
	urlPath := "/lro/error/delete/204/nolocation"
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// BeginDeleteAsyncRelativeRetry400 - Long running delete request, service returns a 202 to the initial request. Poll the
// endpoint indicated in the Azure-AsyncOperation header for operation status
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROSADsClientBeginDeleteAsyncRelativeRetry400Options contains the optional parameters for the LROSADsClient.BeginDeleteAsyncRelativeRetry400
// method.
func (client *LROSADsClient) BeginDeleteAsyncRelativeRetry400(ctx context.Context, options *LROSADsClientBeginDeleteAsyncRelativeRetry400Options) (LROSADsClientDeleteAsyncRelativeRetry400PollerResponse, error) {
	resp, err := client.deleteAsyncRelativeRetry400(ctx, options)
	if err != nil {
		return LROSADsClientDeleteAsyncRelativeRetry400PollerResponse{}, err
	}
	result := LROSADsClientDeleteAsyncRelativeRetry400PollerResponse{}
	pt, err := armruntime.NewPoller("LROSADsClient.DeleteAsyncRelativeRetry400", "", resp, client.pl)
	if err != nil {
		return LROSADsClientDeleteAsyncRelativeRetry400PollerResponse{}, err
	}
	result.Poller = &LROSADsClientDeleteAsyncRelativeRetry400Poller{
		pt: pt,
	}
	return result, nil
}

// DeleteAsyncRelativeRetry400 - Long running delete request, service returns a 202 to the initial request. Poll the endpoint
// indicated in the Azure-AsyncOperation header for operation status
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROSADsClient) deleteAsyncRelativeRetry400(ctx context.Context, options *LROSADsClientBeginDeleteAsyncRelativeRetry400Options) (*http.Response, error) {
	req, err := client.deleteAsyncRelativeRetry400CreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// deleteAsyncRelativeRetry400CreateRequest creates the DeleteAsyncRelativeRetry400 request.
func (client *LROSADsClient) deleteAsyncRelativeRetry400CreateRequest(ctx context.Context, options *LROSADsClientBeginDeleteAsyncRelativeRetry400Options) (*policy.Request, error) {
	urlPath := "/lro/nonretryerror/deleteasync/retry/400"
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// BeginDeleteAsyncRelativeRetryInvalidHeader - Long running delete request, service returns a 202 to the initial request.
// The endpoint indicated in the Azure-AsyncOperation header is invalid
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROSADsClientBeginDeleteAsyncRelativeRetryInvalidHeaderOptions contains the optional parameters for the LROSADsClient.BeginDeleteAsyncRelativeRetryInvalidHeader
// method.
func (client *LROSADsClient) BeginDeleteAsyncRelativeRetryInvalidHeader(ctx context.Context, options *LROSADsClientBeginDeleteAsyncRelativeRetryInvalidHeaderOptions) (LROSADsClientDeleteAsyncRelativeRetryInvalidHeaderPollerResponse, error) {
	resp, err := client.deleteAsyncRelativeRetryInvalidHeader(ctx, options)
	if err != nil {
		return LROSADsClientDeleteAsyncRelativeRetryInvalidHeaderPollerResponse{}, err
	}
	result := LROSADsClientDeleteAsyncRelativeRetryInvalidHeaderPollerResponse{}
	pt, err := armruntime.NewPoller("LROSADsClient.DeleteAsyncRelativeRetryInvalidHeader", "", resp, client.pl)
	if err != nil {
		return LROSADsClientDeleteAsyncRelativeRetryInvalidHeaderPollerResponse{}, err
	}
	result.Poller = &LROSADsClientDeleteAsyncRelativeRetryInvalidHeaderPoller{
		pt: pt,
	}
	return result, nil
}

// DeleteAsyncRelativeRetryInvalidHeader - Long running delete request, service returns a 202 to the initial request. The
// endpoint indicated in the Azure-AsyncOperation header is invalid
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROSADsClient) deleteAsyncRelativeRetryInvalidHeader(ctx context.Context, options *LROSADsClientBeginDeleteAsyncRelativeRetryInvalidHeaderOptions) (*http.Response, error) {
	req, err := client.deleteAsyncRelativeRetryInvalidHeaderCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// deleteAsyncRelativeRetryInvalidHeaderCreateRequest creates the DeleteAsyncRelativeRetryInvalidHeader request.
func (client *LROSADsClient) deleteAsyncRelativeRetryInvalidHeaderCreateRequest(ctx context.Context, options *LROSADsClientBeginDeleteAsyncRelativeRetryInvalidHeaderOptions) (*policy.Request, error) {
	urlPath := "/lro/error/deleteasync/retry/invalidheader"
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// BeginDeleteAsyncRelativeRetryInvalidJSONPolling - Long running delete request, service returns a 202 to the initial request.
// Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROSADsClientBeginDeleteAsyncRelativeRetryInvalidJSONPollingOptions contains the optional parameters for the
// LROSADsClient.BeginDeleteAsyncRelativeRetryInvalidJSONPolling method.
func (client *LROSADsClient) BeginDeleteAsyncRelativeRetryInvalidJSONPolling(ctx context.Context, options *LROSADsClientBeginDeleteAsyncRelativeRetryInvalidJSONPollingOptions) (LROSADsClientDeleteAsyncRelativeRetryInvalidJSONPollingPollerResponse, error) {
	resp, err := client.deleteAsyncRelativeRetryInvalidJSONPolling(ctx, options)
	if err != nil {
		return LROSADsClientDeleteAsyncRelativeRetryInvalidJSONPollingPollerResponse{}, err
	}
	result := LROSADsClientDeleteAsyncRelativeRetryInvalidJSONPollingPollerResponse{}
	pt, err := armruntime.NewPoller("LROSADsClient.DeleteAsyncRelativeRetryInvalidJSONPolling", "", resp, client.pl)
	if err != nil {
		return LROSADsClientDeleteAsyncRelativeRetryInvalidJSONPollingPollerResponse{}, err
	}
	result.Poller = &LROSADsClientDeleteAsyncRelativeRetryInvalidJSONPollingPoller{
		pt: pt,
	}
	return result, nil
}

// DeleteAsyncRelativeRetryInvalidJSONPolling - Long running delete request, service returns a 202 to the initial request.
// Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROSADsClient) deleteAsyncRelativeRetryInvalidJSONPolling(ctx context.Context, options *LROSADsClientBeginDeleteAsyncRelativeRetryInvalidJSONPollingOptions) (*http.Response, error) {
	req, err := client.deleteAsyncRelativeRetryInvalidJSONPollingCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// deleteAsyncRelativeRetryInvalidJSONPollingCreateRequest creates the DeleteAsyncRelativeRetryInvalidJSONPolling request.
func (client *LROSADsClient) deleteAsyncRelativeRetryInvalidJSONPollingCreateRequest(ctx context.Context, options *LROSADsClientBeginDeleteAsyncRelativeRetryInvalidJSONPollingOptions) (*policy.Request, error) {
	urlPath := "/lro/error/deleteasync/retry/invalidjsonpolling"
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// BeginDeleteAsyncRelativeRetryNoStatus - Long running delete request, service returns a 202 to the initial request. Poll
// the endpoint indicated in the Azure-AsyncOperation header for operation status
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROSADsClientBeginDeleteAsyncRelativeRetryNoStatusOptions contains the optional parameters for the LROSADsClient.BeginDeleteAsyncRelativeRetryNoStatus
// method.
func (client *LROSADsClient) BeginDeleteAsyncRelativeRetryNoStatus(ctx context.Context, options *LROSADsClientBeginDeleteAsyncRelativeRetryNoStatusOptions) (LROSADsClientDeleteAsyncRelativeRetryNoStatusPollerResponse, error) {
	resp, err := client.deleteAsyncRelativeRetryNoStatus(ctx, options)
	if err != nil {
		return LROSADsClientDeleteAsyncRelativeRetryNoStatusPollerResponse{}, err
	}
	result := LROSADsClientDeleteAsyncRelativeRetryNoStatusPollerResponse{}
	pt, err := armruntime.NewPoller("LROSADsClient.DeleteAsyncRelativeRetryNoStatus", "", resp, client.pl)
	if err != nil {
		return LROSADsClientDeleteAsyncRelativeRetryNoStatusPollerResponse{}, err
	}
	result.Poller = &LROSADsClientDeleteAsyncRelativeRetryNoStatusPoller{
		pt: pt,
	}
	return result, nil
}

// DeleteAsyncRelativeRetryNoStatus - Long running delete request, service returns a 202 to the initial request. Poll the
// endpoint indicated in the Azure-AsyncOperation header for operation status
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROSADsClient) deleteAsyncRelativeRetryNoStatus(ctx context.Context, options *LROSADsClientBeginDeleteAsyncRelativeRetryNoStatusOptions) (*http.Response, error) {
	req, err := client.deleteAsyncRelativeRetryNoStatusCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// deleteAsyncRelativeRetryNoStatusCreateRequest creates the DeleteAsyncRelativeRetryNoStatus request.
func (client *LROSADsClient) deleteAsyncRelativeRetryNoStatusCreateRequest(ctx context.Context, options *LROSADsClientBeginDeleteAsyncRelativeRetryNoStatusOptions) (*policy.Request, error) {
	urlPath := "/lro/error/deleteasync/retry/nostatus"
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// BeginDeleteNonRetry400 - Long running delete request, service returns a 400 with an error body
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROSADsClientBeginDeleteNonRetry400Options contains the optional parameters for the LROSADsClient.BeginDeleteNonRetry400
// method.
func (client *LROSADsClient) BeginDeleteNonRetry400(ctx context.Context, options *LROSADsClientBeginDeleteNonRetry400Options) (LROSADsClientDeleteNonRetry400PollerResponse, error) {
	resp, err := client.deleteNonRetry400(ctx, options)
	if err != nil {
		return LROSADsClientDeleteNonRetry400PollerResponse{}, err
	}
	result := LROSADsClientDeleteNonRetry400PollerResponse{}
	pt, err := armruntime.NewPoller("LROSADsClient.DeleteNonRetry400", "", resp, client.pl)
	if err != nil {
		return LROSADsClientDeleteNonRetry400PollerResponse{}, err
	}
	result.Poller = &LROSADsClientDeleteNonRetry400Poller{
		pt: pt,
	}
	return result, nil
}

// DeleteNonRetry400 - Long running delete request, service returns a 400 with an error body
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROSADsClient) deleteNonRetry400(ctx context.Context, options *LROSADsClientBeginDeleteNonRetry400Options) (*http.Response, error) {
	req, err := client.deleteNonRetry400CreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// deleteNonRetry400CreateRequest creates the DeleteNonRetry400 request.
func (client *LROSADsClient) deleteNonRetry400CreateRequest(ctx context.Context, options *LROSADsClientBeginDeleteNonRetry400Options) (*policy.Request, error) {
	urlPath := "/lro/nonretryerror/delete/400"
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// BeginPost202NoLocation - Long running post request, service returns a 202 to the initial request, without a location header.
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROSADsClientBeginPost202NoLocationOptions contains the optional parameters for the LROSADsClient.BeginPost202NoLocation
// method.
func (client *LROSADsClient) BeginPost202NoLocation(ctx context.Context, options *LROSADsClientBeginPost202NoLocationOptions) (LROSADsClientPost202NoLocationPollerResponse, error) {
	resp, err := client.post202NoLocation(ctx, options)
	if err != nil {
		return LROSADsClientPost202NoLocationPollerResponse{}, err
	}
	result := LROSADsClientPost202NoLocationPollerResponse{}
	pt, err := armruntime.NewPoller("LROSADsClient.Post202NoLocation", "", resp, client.pl)
	if err != nil {
		return LROSADsClientPost202NoLocationPollerResponse{}, err
	}
	result.Poller = &LROSADsClientPost202NoLocationPoller{
		pt: pt,
	}
	return result, nil
}

// Post202NoLocation - Long running post request, service returns a 202 to the initial request, without a location header.
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROSADsClient) post202NoLocation(ctx context.Context, options *LROSADsClientBeginPost202NoLocationOptions) (*http.Response, error) {
	req, err := client.post202NoLocationCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// post202NoLocationCreateRequest creates the Post202NoLocation request.
func (client *LROSADsClient) post202NoLocationCreateRequest(ctx context.Context, options *LROSADsClientBeginPost202NoLocationOptions) (*policy.Request, error) {
	urlPath := "/lro/error/post/202/nolocation"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, runtime.MarshalAsJSON(req, *options.Product)
	}
	return req, nil
}

// BeginPost202NonRetry400 - Long running post request, service returns a 202 with a location header
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROSADsClientBeginPost202NonRetry400Options contains the optional parameters for the LROSADsClient.BeginPost202NonRetry400
// method.
func (client *LROSADsClient) BeginPost202NonRetry400(ctx context.Context, options *LROSADsClientBeginPost202NonRetry400Options) (LROSADsClientPost202NonRetry400PollerResponse, error) {
	resp, err := client.post202NonRetry400(ctx, options)
	if err != nil {
		return LROSADsClientPost202NonRetry400PollerResponse{}, err
	}
	result := LROSADsClientPost202NonRetry400PollerResponse{}
	pt, err := armruntime.NewPoller("LROSADsClient.Post202NonRetry400", "", resp, client.pl)
	if err != nil {
		return LROSADsClientPost202NonRetry400PollerResponse{}, err
	}
	result.Poller = &LROSADsClientPost202NonRetry400Poller{
		pt: pt,
	}
	return result, nil
}

// Post202NonRetry400 - Long running post request, service returns a 202 with a location header
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROSADsClient) post202NonRetry400(ctx context.Context, options *LROSADsClientBeginPost202NonRetry400Options) (*http.Response, error) {
	req, err := client.post202NonRetry400CreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// post202NonRetry400CreateRequest creates the Post202NonRetry400 request.
func (client *LROSADsClient) post202NonRetry400CreateRequest(ctx context.Context, options *LROSADsClientBeginPost202NonRetry400Options) (*policy.Request, error) {
	urlPath := "/lro/nonretryerror/post/202/retry/400"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, runtime.MarshalAsJSON(req, *options.Product)
	}
	return req, nil
}

// BeginPost202RetryInvalidHeader - Long running post request, service returns a 202 to the initial request, with invalid
// 'Location' and 'Retry-After' headers.
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROSADsClientBeginPost202RetryInvalidHeaderOptions contains the optional parameters for the LROSADsClient.BeginPost202RetryInvalidHeader
// method.
func (client *LROSADsClient) BeginPost202RetryInvalidHeader(ctx context.Context, options *LROSADsClientBeginPost202RetryInvalidHeaderOptions) (LROSADsClientPost202RetryInvalidHeaderPollerResponse, error) {
	resp, err := client.post202RetryInvalidHeader(ctx, options)
	if err != nil {
		return LROSADsClientPost202RetryInvalidHeaderPollerResponse{}, err
	}
	result := LROSADsClientPost202RetryInvalidHeaderPollerResponse{}
	pt, err := armruntime.NewPoller("LROSADsClient.Post202RetryInvalidHeader", "", resp, client.pl)
	if err != nil {
		return LROSADsClientPost202RetryInvalidHeaderPollerResponse{}, err
	}
	result.Poller = &LROSADsClientPost202RetryInvalidHeaderPoller{
		pt: pt,
	}
	return result, nil
}

// Post202RetryInvalidHeader - Long running post request, service returns a 202 to the initial request, with invalid 'Location'
// and 'Retry-After' headers.
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROSADsClient) post202RetryInvalidHeader(ctx context.Context, options *LROSADsClientBeginPost202RetryInvalidHeaderOptions) (*http.Response, error) {
	req, err := client.post202RetryInvalidHeaderCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// post202RetryInvalidHeaderCreateRequest creates the Post202RetryInvalidHeader request.
func (client *LROSADsClient) post202RetryInvalidHeaderCreateRequest(ctx context.Context, options *LROSADsClientBeginPost202RetryInvalidHeaderOptions) (*policy.Request, error) {
	urlPath := "/lro/error/post/202/retry/invalidheader"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, runtime.MarshalAsJSON(req, *options.Product)
	}
	return req, nil
}

// BeginPostAsyncRelativeRetry400 - Long running post request, service returns a 202 to the initial request Poll the endpoint
// indicated in the Azure-AsyncOperation header for operation status
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROSADsClientBeginPostAsyncRelativeRetry400Options contains the optional parameters for the LROSADsClient.BeginPostAsyncRelativeRetry400
// method.
func (client *LROSADsClient) BeginPostAsyncRelativeRetry400(ctx context.Context, options *LROSADsClientBeginPostAsyncRelativeRetry400Options) (LROSADsClientPostAsyncRelativeRetry400PollerResponse, error) {
	resp, err := client.postAsyncRelativeRetry400(ctx, options)
	if err != nil {
		return LROSADsClientPostAsyncRelativeRetry400PollerResponse{}, err
	}
	result := LROSADsClientPostAsyncRelativeRetry400PollerResponse{}
	pt, err := armruntime.NewPoller("LROSADsClient.PostAsyncRelativeRetry400", "", resp, client.pl)
	if err != nil {
		return LROSADsClientPostAsyncRelativeRetry400PollerResponse{}, err
	}
	result.Poller = &LROSADsClientPostAsyncRelativeRetry400Poller{
		pt: pt,
	}
	return result, nil
}

// PostAsyncRelativeRetry400 - Long running post request, service returns a 202 to the initial request Poll the endpoint indicated
// in the Azure-AsyncOperation header for operation status
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROSADsClient) postAsyncRelativeRetry400(ctx context.Context, options *LROSADsClientBeginPostAsyncRelativeRetry400Options) (*http.Response, error) {
	req, err := client.postAsyncRelativeRetry400CreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// postAsyncRelativeRetry400CreateRequest creates the PostAsyncRelativeRetry400 request.
func (client *LROSADsClient) postAsyncRelativeRetry400CreateRequest(ctx context.Context, options *LROSADsClientBeginPostAsyncRelativeRetry400Options) (*policy.Request, error) {
	urlPath := "/lro/nonretryerror/postasync/retry/400"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, runtime.MarshalAsJSON(req, *options.Product)
	}
	return req, nil
}

// BeginPostAsyncRelativeRetryInvalidHeader - Long running post request, service returns a 202 to the initial request, with
// an entity that contains ProvisioningState=’Creating’. The endpoint indicated in the Azure-AsyncOperation header is
// invalid.
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROSADsClientBeginPostAsyncRelativeRetryInvalidHeaderOptions contains the optional parameters for the LROSADsClient.BeginPostAsyncRelativeRetryInvalidHeader
// method.
func (client *LROSADsClient) BeginPostAsyncRelativeRetryInvalidHeader(ctx context.Context, options *LROSADsClientBeginPostAsyncRelativeRetryInvalidHeaderOptions) (LROSADsClientPostAsyncRelativeRetryInvalidHeaderPollerResponse, error) {
	resp, err := client.postAsyncRelativeRetryInvalidHeader(ctx, options)
	if err != nil {
		return LROSADsClientPostAsyncRelativeRetryInvalidHeaderPollerResponse{}, err
	}
	result := LROSADsClientPostAsyncRelativeRetryInvalidHeaderPollerResponse{}
	pt, err := armruntime.NewPoller("LROSADsClient.PostAsyncRelativeRetryInvalidHeader", "", resp, client.pl)
	if err != nil {
		return LROSADsClientPostAsyncRelativeRetryInvalidHeaderPollerResponse{}, err
	}
	result.Poller = &LROSADsClientPostAsyncRelativeRetryInvalidHeaderPoller{
		pt: pt,
	}
	return result, nil
}

// PostAsyncRelativeRetryInvalidHeader - Long running post request, service returns a 202 to the initial request, with an
// entity that contains ProvisioningState=’Creating’. The endpoint indicated in the Azure-AsyncOperation header is
// invalid.
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROSADsClient) postAsyncRelativeRetryInvalidHeader(ctx context.Context, options *LROSADsClientBeginPostAsyncRelativeRetryInvalidHeaderOptions) (*http.Response, error) {
	req, err := client.postAsyncRelativeRetryInvalidHeaderCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// postAsyncRelativeRetryInvalidHeaderCreateRequest creates the PostAsyncRelativeRetryInvalidHeader request.
func (client *LROSADsClient) postAsyncRelativeRetryInvalidHeaderCreateRequest(ctx context.Context, options *LROSADsClientBeginPostAsyncRelativeRetryInvalidHeaderOptions) (*policy.Request, error) {
	urlPath := "/lro/error/postasync/retry/invalidheader"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, runtime.MarshalAsJSON(req, *options.Product)
	}
	return req, nil
}

// BeginPostAsyncRelativeRetryInvalidJSONPolling - Long running post request, service returns a 202 to the initial request,
// with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header
// for
// operation status
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROSADsClientBeginPostAsyncRelativeRetryInvalidJSONPollingOptions contains the optional parameters for the LROSADsClient.BeginPostAsyncRelativeRetryInvalidJSONPolling
// method.
func (client *LROSADsClient) BeginPostAsyncRelativeRetryInvalidJSONPolling(ctx context.Context, options *LROSADsClientBeginPostAsyncRelativeRetryInvalidJSONPollingOptions) (LROSADsClientPostAsyncRelativeRetryInvalidJSONPollingPollerResponse, error) {
	resp, err := client.postAsyncRelativeRetryInvalidJSONPolling(ctx, options)
	if err != nil {
		return LROSADsClientPostAsyncRelativeRetryInvalidJSONPollingPollerResponse{}, err
	}
	result := LROSADsClientPostAsyncRelativeRetryInvalidJSONPollingPollerResponse{}
	pt, err := armruntime.NewPoller("LROSADsClient.PostAsyncRelativeRetryInvalidJSONPolling", "", resp, client.pl)
	if err != nil {
		return LROSADsClientPostAsyncRelativeRetryInvalidJSONPollingPollerResponse{}, err
	}
	result.Poller = &LROSADsClientPostAsyncRelativeRetryInvalidJSONPollingPoller{
		pt: pt,
	}
	return result, nil
}

// PostAsyncRelativeRetryInvalidJSONPolling - Long running post request, service returns a 202 to the initial request, with
// an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROSADsClient) postAsyncRelativeRetryInvalidJSONPolling(ctx context.Context, options *LROSADsClientBeginPostAsyncRelativeRetryInvalidJSONPollingOptions) (*http.Response, error) {
	req, err := client.postAsyncRelativeRetryInvalidJSONPollingCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// postAsyncRelativeRetryInvalidJSONPollingCreateRequest creates the PostAsyncRelativeRetryInvalidJSONPolling request.
func (client *LROSADsClient) postAsyncRelativeRetryInvalidJSONPollingCreateRequest(ctx context.Context, options *LROSADsClientBeginPostAsyncRelativeRetryInvalidJSONPollingOptions) (*policy.Request, error) {
	urlPath := "/lro/error/postasync/retry/invalidjsonpolling"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, runtime.MarshalAsJSON(req, *options.Product)
	}
	return req, nil
}

// BeginPostAsyncRelativeRetryNoPayload - Long running post request, service returns a 202 to the initial request, with an
// entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROSADsClientBeginPostAsyncRelativeRetryNoPayloadOptions contains the optional parameters for the LROSADsClient.BeginPostAsyncRelativeRetryNoPayload
// method.
func (client *LROSADsClient) BeginPostAsyncRelativeRetryNoPayload(ctx context.Context, options *LROSADsClientBeginPostAsyncRelativeRetryNoPayloadOptions) (LROSADsClientPostAsyncRelativeRetryNoPayloadPollerResponse, error) {
	resp, err := client.postAsyncRelativeRetryNoPayload(ctx, options)
	if err != nil {
		return LROSADsClientPostAsyncRelativeRetryNoPayloadPollerResponse{}, err
	}
	result := LROSADsClientPostAsyncRelativeRetryNoPayloadPollerResponse{}
	pt, err := armruntime.NewPoller("LROSADsClient.PostAsyncRelativeRetryNoPayload", "", resp, client.pl)
	if err != nil {
		return LROSADsClientPostAsyncRelativeRetryNoPayloadPollerResponse{}, err
	}
	result.Poller = &LROSADsClientPostAsyncRelativeRetryNoPayloadPoller{
		pt: pt,
	}
	return result, nil
}

// PostAsyncRelativeRetryNoPayload - Long running post request, service returns a 202 to the initial request, with an entity
// that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROSADsClient) postAsyncRelativeRetryNoPayload(ctx context.Context, options *LROSADsClientBeginPostAsyncRelativeRetryNoPayloadOptions) (*http.Response, error) {
	req, err := client.postAsyncRelativeRetryNoPayloadCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// postAsyncRelativeRetryNoPayloadCreateRequest creates the PostAsyncRelativeRetryNoPayload request.
func (client *LROSADsClient) postAsyncRelativeRetryNoPayloadCreateRequest(ctx context.Context, options *LROSADsClientBeginPostAsyncRelativeRetryNoPayloadOptions) (*policy.Request, error) {
	urlPath := "/lro/error/postasync/retry/nopayload"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, runtime.MarshalAsJSON(req, *options.Product)
	}
	return req, nil
}

// BeginPostNonRetry400 - Long running post request, service returns a 400 with no error body
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROSADsClientBeginPostNonRetry400Options contains the optional parameters for the LROSADsClient.BeginPostNonRetry400
// method.
func (client *LROSADsClient) BeginPostNonRetry400(ctx context.Context, options *LROSADsClientBeginPostNonRetry400Options) (LROSADsClientPostNonRetry400PollerResponse, error) {
	resp, err := client.postNonRetry400(ctx, options)
	if err != nil {
		return LROSADsClientPostNonRetry400PollerResponse{}, err
	}
	result := LROSADsClientPostNonRetry400PollerResponse{}
	pt, err := armruntime.NewPoller("LROSADsClient.PostNonRetry400", "", resp, client.pl)
	if err != nil {
		return LROSADsClientPostNonRetry400PollerResponse{}, err
	}
	result.Poller = &LROSADsClientPostNonRetry400Poller{
		pt: pt,
	}
	return result, nil
}

// PostNonRetry400 - Long running post request, service returns a 400 with no error body
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROSADsClient) postNonRetry400(ctx context.Context, options *LROSADsClientBeginPostNonRetry400Options) (*http.Response, error) {
	req, err := client.postNonRetry400CreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// postNonRetry400CreateRequest creates the PostNonRetry400 request.
func (client *LROSADsClient) postNonRetry400CreateRequest(ctx context.Context, options *LROSADsClientBeginPostNonRetry400Options) (*policy.Request, error) {
	urlPath := "/lro/nonretryerror/post/400"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, runtime.MarshalAsJSON(req, *options.Product)
	}
	return req, nil
}

// BeginPut200InvalidJSON - Long running put request, service returns a 200 to the initial request, with an entity that is
// not a valid json
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROSADsClientBeginPut200InvalidJSONOptions contains the optional parameters for the LROSADsClient.BeginPut200InvalidJSON
// method.
func (client *LROSADsClient) BeginPut200InvalidJSON(ctx context.Context, options *LROSADsClientBeginPut200InvalidJSONOptions) (LROSADsClientPut200InvalidJSONPollerResponse, error) {
	resp, err := client.put200InvalidJSON(ctx, options)
	if err != nil {
		return LROSADsClientPut200InvalidJSONPollerResponse{}, err
	}
	result := LROSADsClientPut200InvalidJSONPollerResponse{}
	pt, err := armruntime.NewPoller("LROSADsClient.Put200InvalidJSON", "", resp, client.pl)
	if err != nil {
		return LROSADsClientPut200InvalidJSONPollerResponse{}, err
	}
	result.Poller = &LROSADsClientPut200InvalidJSONPoller{
		pt: pt,
	}
	return result, nil
}

// Put200InvalidJSON - Long running put request, service returns a 200 to the initial request, with an entity that is not
// a valid json
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROSADsClient) put200InvalidJSON(ctx context.Context, options *LROSADsClientBeginPut200InvalidJSONOptions) (*http.Response, error) {
	req, err := client.put200InvalidJSONCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// put200InvalidJSONCreateRequest creates the Put200InvalidJSON request.
func (client *LROSADsClient) put200InvalidJSONCreateRequest(ctx context.Context, options *LROSADsClientBeginPut200InvalidJSONOptions) (*policy.Request, error) {
	urlPath := "/lro/error/put/200/invalidjson"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, runtime.MarshalAsJSON(req, *options.Product)
	}
	return req, nil
}

// BeginPutAsyncRelativeRetry400 - Long running put request, service returns a 200 with ProvisioningState=’Creating’. Poll
// the endpoint indicated in the Azure-AsyncOperation header for operation status
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROSADsClientBeginPutAsyncRelativeRetry400Options contains the optional parameters for the LROSADsClient.BeginPutAsyncRelativeRetry400
// method.
func (client *LROSADsClient) BeginPutAsyncRelativeRetry400(ctx context.Context, options *LROSADsClientBeginPutAsyncRelativeRetry400Options) (LROSADsClientPutAsyncRelativeRetry400PollerResponse, error) {
	resp, err := client.putAsyncRelativeRetry400(ctx, options)
	if err != nil {
		return LROSADsClientPutAsyncRelativeRetry400PollerResponse{}, err
	}
	result := LROSADsClientPutAsyncRelativeRetry400PollerResponse{}
	pt, err := armruntime.NewPoller("LROSADsClient.PutAsyncRelativeRetry400", "", resp, client.pl)
	if err != nil {
		return LROSADsClientPutAsyncRelativeRetry400PollerResponse{}, err
	}
	result.Poller = &LROSADsClientPutAsyncRelativeRetry400Poller{
		pt: pt,
	}
	return result, nil
}

// PutAsyncRelativeRetry400 - Long running put request, service returns a 200 with ProvisioningState=’Creating’. Poll the
// endpoint indicated in the Azure-AsyncOperation header for operation status
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROSADsClient) putAsyncRelativeRetry400(ctx context.Context, options *LROSADsClientBeginPutAsyncRelativeRetry400Options) (*http.Response, error) {
	req, err := client.putAsyncRelativeRetry400CreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// putAsyncRelativeRetry400CreateRequest creates the PutAsyncRelativeRetry400 request.
func (client *LROSADsClient) putAsyncRelativeRetry400CreateRequest(ctx context.Context, options *LROSADsClientBeginPutAsyncRelativeRetry400Options) (*policy.Request, error) {
	urlPath := "/lro/nonretryerror/putasync/retry/400"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, runtime.MarshalAsJSON(req, *options.Product)
	}
	return req, nil
}

// BeginPutAsyncRelativeRetryInvalidHeader - Long running put request, service returns a 200 to the initial request, with
// an entity that contains ProvisioningState=’Creating’. The endpoint indicated in the Azure-AsyncOperation header is invalid.
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROSADsClientBeginPutAsyncRelativeRetryInvalidHeaderOptions contains the optional parameters for the LROSADsClient.BeginPutAsyncRelativeRetryInvalidHeader
// method.
func (client *LROSADsClient) BeginPutAsyncRelativeRetryInvalidHeader(ctx context.Context, options *LROSADsClientBeginPutAsyncRelativeRetryInvalidHeaderOptions) (LROSADsClientPutAsyncRelativeRetryInvalidHeaderPollerResponse, error) {
	resp, err := client.putAsyncRelativeRetryInvalidHeader(ctx, options)
	if err != nil {
		return LROSADsClientPutAsyncRelativeRetryInvalidHeaderPollerResponse{}, err
	}
	result := LROSADsClientPutAsyncRelativeRetryInvalidHeaderPollerResponse{}
	pt, err := armruntime.NewPoller("LROSADsClient.PutAsyncRelativeRetryInvalidHeader", "", resp, client.pl)
	if err != nil {
		return LROSADsClientPutAsyncRelativeRetryInvalidHeaderPollerResponse{}, err
	}
	result.Poller = &LROSADsClientPutAsyncRelativeRetryInvalidHeaderPoller{
		pt: pt,
	}
	return result, nil
}

// PutAsyncRelativeRetryInvalidHeader - Long running put request, service returns a 200 to the initial request, with an entity
// that contains ProvisioningState=’Creating’. The endpoint indicated in the Azure-AsyncOperation header is invalid.
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROSADsClient) putAsyncRelativeRetryInvalidHeader(ctx context.Context, options *LROSADsClientBeginPutAsyncRelativeRetryInvalidHeaderOptions) (*http.Response, error) {
	req, err := client.putAsyncRelativeRetryInvalidHeaderCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// putAsyncRelativeRetryInvalidHeaderCreateRequest creates the PutAsyncRelativeRetryInvalidHeader request.
func (client *LROSADsClient) putAsyncRelativeRetryInvalidHeaderCreateRequest(ctx context.Context, options *LROSADsClientBeginPutAsyncRelativeRetryInvalidHeaderOptions) (*policy.Request, error) {
	urlPath := "/lro/error/putasync/retry/invalidheader"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, runtime.MarshalAsJSON(req, *options.Product)
	}
	return req, nil
}

// BeginPutAsyncRelativeRetryInvalidJSONPolling - Long running put request, service returns a 200 to the initial request,
// with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header
// for
// operation status
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROSADsClientBeginPutAsyncRelativeRetryInvalidJSONPollingOptions contains the optional parameters for the LROSADsClient.BeginPutAsyncRelativeRetryInvalidJSONPolling
// method.
func (client *LROSADsClient) BeginPutAsyncRelativeRetryInvalidJSONPolling(ctx context.Context, options *LROSADsClientBeginPutAsyncRelativeRetryInvalidJSONPollingOptions) (LROSADsClientPutAsyncRelativeRetryInvalidJSONPollingPollerResponse, error) {
	resp, err := client.putAsyncRelativeRetryInvalidJSONPolling(ctx, options)
	if err != nil {
		return LROSADsClientPutAsyncRelativeRetryInvalidJSONPollingPollerResponse{}, err
	}
	result := LROSADsClientPutAsyncRelativeRetryInvalidJSONPollingPollerResponse{}
	pt, err := armruntime.NewPoller("LROSADsClient.PutAsyncRelativeRetryInvalidJSONPolling", "", resp, client.pl)
	if err != nil {
		return LROSADsClientPutAsyncRelativeRetryInvalidJSONPollingPollerResponse{}, err
	}
	result.Poller = &LROSADsClientPutAsyncRelativeRetryInvalidJSONPollingPoller{
		pt: pt,
	}
	return result, nil
}

// PutAsyncRelativeRetryInvalidJSONPolling - Long running put request, service returns a 200 to the initial request, with
// an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROSADsClient) putAsyncRelativeRetryInvalidJSONPolling(ctx context.Context, options *LROSADsClientBeginPutAsyncRelativeRetryInvalidJSONPollingOptions) (*http.Response, error) {
	req, err := client.putAsyncRelativeRetryInvalidJSONPollingCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// putAsyncRelativeRetryInvalidJSONPollingCreateRequest creates the PutAsyncRelativeRetryInvalidJSONPolling request.
func (client *LROSADsClient) putAsyncRelativeRetryInvalidJSONPollingCreateRequest(ctx context.Context, options *LROSADsClientBeginPutAsyncRelativeRetryInvalidJSONPollingOptions) (*policy.Request, error) {
	urlPath := "/lro/error/putasync/retry/invalidjsonpolling"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, runtime.MarshalAsJSON(req, *options.Product)
	}
	return req, nil
}

// BeginPutAsyncRelativeRetryNoStatus - Long running put request, service returns a 200 to the initial request, with an entity
// that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROSADsClientBeginPutAsyncRelativeRetryNoStatusOptions contains the optional parameters for the LROSADsClient.BeginPutAsyncRelativeRetryNoStatus
// method.
func (client *LROSADsClient) BeginPutAsyncRelativeRetryNoStatus(ctx context.Context, options *LROSADsClientBeginPutAsyncRelativeRetryNoStatusOptions) (LROSADsClientPutAsyncRelativeRetryNoStatusPollerResponse, error) {
	resp, err := client.putAsyncRelativeRetryNoStatus(ctx, options)
	if err != nil {
		return LROSADsClientPutAsyncRelativeRetryNoStatusPollerResponse{}, err
	}
	result := LROSADsClientPutAsyncRelativeRetryNoStatusPollerResponse{}
	pt, err := armruntime.NewPoller("LROSADsClient.PutAsyncRelativeRetryNoStatus", "", resp, client.pl)
	if err != nil {
		return LROSADsClientPutAsyncRelativeRetryNoStatusPollerResponse{}, err
	}
	result.Poller = &LROSADsClientPutAsyncRelativeRetryNoStatusPoller{
		pt: pt,
	}
	return result, nil
}

// PutAsyncRelativeRetryNoStatus - Long running put request, service returns a 200 to the initial request, with an entity
// that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROSADsClient) putAsyncRelativeRetryNoStatus(ctx context.Context, options *LROSADsClientBeginPutAsyncRelativeRetryNoStatusOptions) (*http.Response, error) {
	req, err := client.putAsyncRelativeRetryNoStatusCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// putAsyncRelativeRetryNoStatusCreateRequest creates the PutAsyncRelativeRetryNoStatus request.
func (client *LROSADsClient) putAsyncRelativeRetryNoStatusCreateRequest(ctx context.Context, options *LROSADsClientBeginPutAsyncRelativeRetryNoStatusOptions) (*policy.Request, error) {
	urlPath := "/lro/error/putasync/retry/nostatus"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, runtime.MarshalAsJSON(req, *options.Product)
	}
	return req, nil
}

// BeginPutAsyncRelativeRetryNoStatusPayload - Long running put request, service returns a 200 to the initial request, with
// an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROSADsClientBeginPutAsyncRelativeRetryNoStatusPayloadOptions contains the optional parameters for the LROSADsClient.BeginPutAsyncRelativeRetryNoStatusPayload
// method.
func (client *LROSADsClient) BeginPutAsyncRelativeRetryNoStatusPayload(ctx context.Context, options *LROSADsClientBeginPutAsyncRelativeRetryNoStatusPayloadOptions) (LROSADsClientPutAsyncRelativeRetryNoStatusPayloadPollerResponse, error) {
	resp, err := client.putAsyncRelativeRetryNoStatusPayload(ctx, options)
	if err != nil {
		return LROSADsClientPutAsyncRelativeRetryNoStatusPayloadPollerResponse{}, err
	}
	result := LROSADsClientPutAsyncRelativeRetryNoStatusPayloadPollerResponse{}
	pt, err := armruntime.NewPoller("LROSADsClient.PutAsyncRelativeRetryNoStatusPayload", "", resp, client.pl)
	if err != nil {
		return LROSADsClientPutAsyncRelativeRetryNoStatusPayloadPollerResponse{}, err
	}
	result.Poller = &LROSADsClientPutAsyncRelativeRetryNoStatusPayloadPoller{
		pt: pt,
	}
	return result, nil
}

// PutAsyncRelativeRetryNoStatusPayload - Long running put request, service returns a 200 to the initial request, with an
// entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROSADsClient) putAsyncRelativeRetryNoStatusPayload(ctx context.Context, options *LROSADsClientBeginPutAsyncRelativeRetryNoStatusPayloadOptions) (*http.Response, error) {
	req, err := client.putAsyncRelativeRetryNoStatusPayloadCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// putAsyncRelativeRetryNoStatusPayloadCreateRequest creates the PutAsyncRelativeRetryNoStatusPayload request.
func (client *LROSADsClient) putAsyncRelativeRetryNoStatusPayloadCreateRequest(ctx context.Context, options *LROSADsClientBeginPutAsyncRelativeRetryNoStatusPayloadOptions) (*policy.Request, error) {
	urlPath := "/lro/error/putasync/retry/nostatuspayload"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, runtime.MarshalAsJSON(req, *options.Product)
	}
	return req, nil
}

// BeginPutError201NoProvisioningStatePayload - Long running put request, service returns a 201 to the initial request with
// no payload
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROSADsClientBeginPutError201NoProvisioningStatePayloadOptions contains the optional parameters for the LROSADsClient.BeginPutError201NoProvisioningStatePayload
// method.
func (client *LROSADsClient) BeginPutError201NoProvisioningStatePayload(ctx context.Context, options *LROSADsClientBeginPutError201NoProvisioningStatePayloadOptions) (LROSADsClientPutError201NoProvisioningStatePayloadPollerResponse, error) {
	resp, err := client.putError201NoProvisioningStatePayload(ctx, options)
	if err != nil {
		return LROSADsClientPutError201NoProvisioningStatePayloadPollerResponse{}, err
	}
	result := LROSADsClientPutError201NoProvisioningStatePayloadPollerResponse{}
	pt, err := armruntime.NewPoller("LROSADsClient.PutError201NoProvisioningStatePayload", "", resp, client.pl)
	if err != nil {
		return LROSADsClientPutError201NoProvisioningStatePayloadPollerResponse{}, err
	}
	result.Poller = &LROSADsClientPutError201NoProvisioningStatePayloadPoller{
		pt: pt,
	}
	return result, nil
}

// PutError201NoProvisioningStatePayload - Long running put request, service returns a 201 to the initial request with no
// payload
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROSADsClient) putError201NoProvisioningStatePayload(ctx context.Context, options *LROSADsClientBeginPutError201NoProvisioningStatePayloadOptions) (*http.Response, error) {
	req, err := client.putError201NoProvisioningStatePayloadCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// putError201NoProvisioningStatePayloadCreateRequest creates the PutError201NoProvisioningStatePayload request.
func (client *LROSADsClient) putError201NoProvisioningStatePayloadCreateRequest(ctx context.Context, options *LROSADsClientBeginPutError201NoProvisioningStatePayloadOptions) (*policy.Request, error) {
	urlPath := "/lro/error/put/201/noprovisioningstatepayload"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, runtime.MarshalAsJSON(req, *options.Product)
	}
	return req, nil
}

// BeginPutNonRetry201Creating400 - Long running put request, service returns a Product with 'ProvisioningState' = 'Creating'
// and 201 response code
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROSADsClientBeginPutNonRetry201Creating400Options contains the optional parameters for the LROSADsClient.BeginPutNonRetry201Creating400
// method.
func (client *LROSADsClient) BeginPutNonRetry201Creating400(ctx context.Context, options *LROSADsClientBeginPutNonRetry201Creating400Options) (LROSADsClientPutNonRetry201Creating400PollerResponse, error) {
	resp, err := client.putNonRetry201Creating400(ctx, options)
	if err != nil {
		return LROSADsClientPutNonRetry201Creating400PollerResponse{}, err
	}
	result := LROSADsClientPutNonRetry201Creating400PollerResponse{}
	pt, err := armruntime.NewPoller("LROSADsClient.PutNonRetry201Creating400", "", resp, client.pl)
	if err != nil {
		return LROSADsClientPutNonRetry201Creating400PollerResponse{}, err
	}
	result.Poller = &LROSADsClientPutNonRetry201Creating400Poller{
		pt: pt,
	}
	return result, nil
}

// PutNonRetry201Creating400 - Long running put request, service returns a Product with 'ProvisioningState' = 'Creating' and
// 201 response code
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROSADsClient) putNonRetry201Creating400(ctx context.Context, options *LROSADsClientBeginPutNonRetry201Creating400Options) (*http.Response, error) {
	req, err := client.putNonRetry201Creating400CreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// putNonRetry201Creating400CreateRequest creates the PutNonRetry201Creating400 request.
func (client *LROSADsClient) putNonRetry201Creating400CreateRequest(ctx context.Context, options *LROSADsClientBeginPutNonRetry201Creating400Options) (*policy.Request, error) {
	urlPath := "/lro/nonretryerror/put/201/creating/400"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, runtime.MarshalAsJSON(req, *options.Product)
	}
	return req, nil
}

// BeginPutNonRetry201Creating400InvalidJSON - Long running put request, service returns a Product with 'ProvisioningState'
// = 'Creating' and 201 response code
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROSADsClientBeginPutNonRetry201Creating400InvalidJSONOptions contains the optional parameters for the LROSADsClient.BeginPutNonRetry201Creating400InvalidJSON
// method.
func (client *LROSADsClient) BeginPutNonRetry201Creating400InvalidJSON(ctx context.Context, options *LROSADsClientBeginPutNonRetry201Creating400InvalidJSONOptions) (LROSADsClientPutNonRetry201Creating400InvalidJSONPollerResponse, error) {
	resp, err := client.putNonRetry201Creating400InvalidJSON(ctx, options)
	if err != nil {
		return LROSADsClientPutNonRetry201Creating400InvalidJSONPollerResponse{}, err
	}
	result := LROSADsClientPutNonRetry201Creating400InvalidJSONPollerResponse{}
	pt, err := armruntime.NewPoller("LROSADsClient.PutNonRetry201Creating400InvalidJSON", "", resp, client.pl)
	if err != nil {
		return LROSADsClientPutNonRetry201Creating400InvalidJSONPollerResponse{}, err
	}
	result.Poller = &LROSADsClientPutNonRetry201Creating400InvalidJSONPoller{
		pt: pt,
	}
	return result, nil
}

// PutNonRetry201Creating400InvalidJSON - Long running put request, service returns a Product with 'ProvisioningState' = 'Creating'
// and 201 response code
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROSADsClient) putNonRetry201Creating400InvalidJSON(ctx context.Context, options *LROSADsClientBeginPutNonRetry201Creating400InvalidJSONOptions) (*http.Response, error) {
	req, err := client.putNonRetry201Creating400InvalidJSONCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// putNonRetry201Creating400InvalidJSONCreateRequest creates the PutNonRetry201Creating400InvalidJSON request.
func (client *LROSADsClient) putNonRetry201Creating400InvalidJSONCreateRequest(ctx context.Context, options *LROSADsClientBeginPutNonRetry201Creating400InvalidJSONOptions) (*policy.Request, error) {
	urlPath := "/lro/nonretryerror/put/201/creating/400/invalidjson"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, runtime.MarshalAsJSON(req, *options.Product)
	}
	return req, nil
}

// BeginPutNonRetry400 - Long running put request, service returns a 400 to the initial request
// If the operation fails it returns an *azcore.ResponseError type.
// options - LROSADsClientBeginPutNonRetry400Options contains the optional parameters for the LROSADsClient.BeginPutNonRetry400
// method.
func (client *LROSADsClient) BeginPutNonRetry400(ctx context.Context, options *LROSADsClientBeginPutNonRetry400Options) (LROSADsClientPutNonRetry400PollerResponse, error) {
	resp, err := client.putNonRetry400(ctx, options)
	if err != nil {
		return LROSADsClientPutNonRetry400PollerResponse{}, err
	}
	result := LROSADsClientPutNonRetry400PollerResponse{}
	pt, err := armruntime.NewPoller("LROSADsClient.PutNonRetry400", "", resp, client.pl)
	if err != nil {
		return LROSADsClientPutNonRetry400PollerResponse{}, err
	}
	result.Poller = &LROSADsClientPutNonRetry400Poller{
		pt: pt,
	}
	return result, nil
}

// PutNonRetry400 - Long running put request, service returns a 400 to the initial request
// If the operation fails it returns an *azcore.ResponseError type.
func (client *LROSADsClient) putNonRetry400(ctx context.Context, options *LROSADsClientBeginPutNonRetry400Options) (*http.Response, error) {
	req, err := client.putNonRetry400CreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// putNonRetry400CreateRequest creates the PutNonRetry400 request.
func (client *LROSADsClient) putNonRetry400CreateRequest(ctx context.Context, options *LROSADsClientBeginPutNonRetry400Options) (*policy.Request, error) {
	urlPath := "/lro/nonretryerror/put/400"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Product != nil {
		return req, runtime.MarshalAsJSON(req, *options.Product)
	}
	return req, nil
}
