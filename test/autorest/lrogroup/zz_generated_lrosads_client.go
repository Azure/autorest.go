//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.
// DO NOT EDIT.

package lrogroup

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
)

// LROSADsClient contains the methods for the LROSADs group.
// Don't use this type directly, use NewLROSADsClient() instead.
type LROSADsClient struct {
	pl runtime.Pipeline
}

// NewLROSADsClient creates a new instance of LROSADsClient with the specified values.
// pl - the pipeline used for sending requests and handling responses.
func NewLROSADsClient(pl runtime.Pipeline) *LROSADsClient {
	client := &LROSADsClient{
		pl: pl,
	}
	return client
}

// BeginDelete202NonRetry400 - Long running delete request, service returns a 202 with a location header
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - LROSADsClientBeginDelete202NonRetry400Options contains the optional parameters for the LROSADsClient.BeginDelete202NonRetry400
// method.
func (client *LROSADsClient) BeginDelete202NonRetry400(ctx context.Context, options *LROSADsClientBeginDelete202NonRetry400Options) (*runtime.Poller[LROSADsClientDelete202NonRetry400Response], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.delete202NonRetry400(ctx, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[LROSADsClientDelete202NonRetry400Response](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[LROSADsClientDelete202NonRetry400Response](options.ResumeToken, client.pl, nil)
	}
}

// Delete202NonRetry400 - Long running delete request, service returns a 202 with a location header
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
func (client *LROSADsClient) delete202NonRetry400(ctx context.Context, options *LROSADsClientBeginDelete202NonRetry400Options) (*http.Response, error) {
	req, err := client.delete202NonRetry400CreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// delete202NonRetry400CreateRequest creates the Delete202NonRetry400 request.
func (client *LROSADsClient) delete202NonRetry400CreateRequest(ctx context.Context, options *LROSADsClientBeginDelete202NonRetry400Options) (*policy.Request, error) {
	urlPath := "/lro/nonretryerror/delete/202/retry/400"
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// BeginDelete202RetryInvalidHeader - Long running delete request, service returns a 202 to the initial request receing a
// reponse with an invalid 'Location' and 'Retry-After' headers
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - LROSADsClientBeginDelete202RetryInvalidHeaderOptions contains the optional parameters for the LROSADsClient.BeginDelete202RetryInvalidHeader
// method.
func (client *LROSADsClient) BeginDelete202RetryInvalidHeader(ctx context.Context, options *LROSADsClientBeginDelete202RetryInvalidHeaderOptions) (*runtime.Poller[LROSADsClientDelete202RetryInvalidHeaderResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.delete202RetryInvalidHeader(ctx, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[LROSADsClientDelete202RetryInvalidHeaderResponse](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[LROSADsClientDelete202RetryInvalidHeaderResponse](options.ResumeToken, client.pl, nil)
	}
}

// Delete202RetryInvalidHeader - Long running delete request, service returns a 202 to the initial request receing a reponse
// with an invalid 'Location' and 'Retry-After' headers
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
func (client *LROSADsClient) delete202RetryInvalidHeader(ctx context.Context, options *LROSADsClientBeginDelete202RetryInvalidHeaderOptions) (*http.Response, error) {
	req, err := client.delete202RetryInvalidHeaderCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// delete202RetryInvalidHeaderCreateRequest creates the Delete202RetryInvalidHeader request.
func (client *LROSADsClient) delete202RetryInvalidHeaderCreateRequest(ctx context.Context, options *LROSADsClientBeginDelete202RetryInvalidHeaderOptions) (*policy.Request, error) {
	urlPath := "/lro/error/delete/202/retry/invalidheader"
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// BeginDelete204Succeeded - Long running delete request, service returns a 204 to the initial request, indicating success.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - LROSADsClientBeginDelete204SucceededOptions contains the optional parameters for the LROSADsClient.BeginDelete204Succeeded
// method.
func (client *LROSADsClient) BeginDelete204Succeeded(ctx context.Context, options *LROSADsClientBeginDelete204SucceededOptions) (*runtime.Poller[LROSADsClientDelete204SucceededResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.delete204Succeeded(ctx, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[LROSADsClientDelete204SucceededResponse](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[LROSADsClientDelete204SucceededResponse](options.ResumeToken, client.pl, nil)
	}
}

// Delete204Succeeded - Long running delete request, service returns a 204 to the initial request, indicating success.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
func (client *LROSADsClient) delete204Succeeded(ctx context.Context, options *LROSADsClientBeginDelete204SucceededOptions) (*http.Response, error) {
	req, err := client.delete204SucceededCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// delete204SucceededCreateRequest creates the Delete204Succeeded request.
func (client *LROSADsClient) delete204SucceededCreateRequest(ctx context.Context, options *LROSADsClientBeginDelete204SucceededOptions) (*policy.Request, error) {
	urlPath := "/lro/error/delete/204/nolocation"
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// BeginDeleteAsyncRelativeRetry400 - Long running delete request, service returns a 202 to the initial request. Poll the
// endpoint indicated in the Azure-AsyncOperation header for operation status
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - LROSADsClientBeginDeleteAsyncRelativeRetry400Options contains the optional parameters for the LROSADsClient.BeginDeleteAsyncRelativeRetry400
// method.
func (client *LROSADsClient) BeginDeleteAsyncRelativeRetry400(ctx context.Context, options *LROSADsClientBeginDeleteAsyncRelativeRetry400Options) (*runtime.Poller[LROSADsClientDeleteAsyncRelativeRetry400Response], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.deleteAsyncRelativeRetry400(ctx, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[LROSADsClientDeleteAsyncRelativeRetry400Response](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[LROSADsClientDeleteAsyncRelativeRetry400Response](options.ResumeToken, client.pl, nil)
	}
}

// DeleteAsyncRelativeRetry400 - Long running delete request, service returns a 202 to the initial request. Poll the endpoint
// indicated in the Azure-AsyncOperation header for operation status
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
func (client *LROSADsClient) deleteAsyncRelativeRetry400(ctx context.Context, options *LROSADsClientBeginDeleteAsyncRelativeRetry400Options) (*http.Response, error) {
	req, err := client.deleteAsyncRelativeRetry400CreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// deleteAsyncRelativeRetry400CreateRequest creates the DeleteAsyncRelativeRetry400 request.
func (client *LROSADsClient) deleteAsyncRelativeRetry400CreateRequest(ctx context.Context, options *LROSADsClientBeginDeleteAsyncRelativeRetry400Options) (*policy.Request, error) {
	urlPath := "/lro/nonretryerror/deleteasync/retry/400"
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// BeginDeleteAsyncRelativeRetryInvalidHeader - Long running delete request, service returns a 202 to the initial request.
// The endpoint indicated in the Azure-AsyncOperation header is invalid
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - LROSADsClientBeginDeleteAsyncRelativeRetryInvalidHeaderOptions contains the optional parameters for the LROSADsClient.BeginDeleteAsyncRelativeRetryInvalidHeader
// method.
func (client *LROSADsClient) BeginDeleteAsyncRelativeRetryInvalidHeader(ctx context.Context, options *LROSADsClientBeginDeleteAsyncRelativeRetryInvalidHeaderOptions) (*runtime.Poller[LROSADsClientDeleteAsyncRelativeRetryInvalidHeaderResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.deleteAsyncRelativeRetryInvalidHeader(ctx, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[LROSADsClientDeleteAsyncRelativeRetryInvalidHeaderResponse](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[LROSADsClientDeleteAsyncRelativeRetryInvalidHeaderResponse](options.ResumeToken, client.pl, nil)
	}
}

// DeleteAsyncRelativeRetryInvalidHeader - Long running delete request, service returns a 202 to the initial request. The
// endpoint indicated in the Azure-AsyncOperation header is invalid
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
func (client *LROSADsClient) deleteAsyncRelativeRetryInvalidHeader(ctx context.Context, options *LROSADsClientBeginDeleteAsyncRelativeRetryInvalidHeaderOptions) (*http.Response, error) {
	req, err := client.deleteAsyncRelativeRetryInvalidHeaderCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// deleteAsyncRelativeRetryInvalidHeaderCreateRequest creates the DeleteAsyncRelativeRetryInvalidHeader request.
func (client *LROSADsClient) deleteAsyncRelativeRetryInvalidHeaderCreateRequest(ctx context.Context, options *LROSADsClientBeginDeleteAsyncRelativeRetryInvalidHeaderOptions) (*policy.Request, error) {
	urlPath := "/lro/error/deleteasync/retry/invalidheader"
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// BeginDeleteAsyncRelativeRetryInvalidJSONPolling - Long running delete request, service returns a 202 to the initial request.
// Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - LROSADsClientBeginDeleteAsyncRelativeRetryInvalidJSONPollingOptions contains the optional parameters for the
// LROSADsClient.BeginDeleteAsyncRelativeRetryInvalidJSONPolling method.
func (client *LROSADsClient) BeginDeleteAsyncRelativeRetryInvalidJSONPolling(ctx context.Context, options *LROSADsClientBeginDeleteAsyncRelativeRetryInvalidJSONPollingOptions) (*runtime.Poller[LROSADsClientDeleteAsyncRelativeRetryInvalidJSONPollingResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.deleteAsyncRelativeRetryInvalidJSONPolling(ctx, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[LROSADsClientDeleteAsyncRelativeRetryInvalidJSONPollingResponse](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[LROSADsClientDeleteAsyncRelativeRetryInvalidJSONPollingResponse](options.ResumeToken, client.pl, nil)
	}
}

// DeleteAsyncRelativeRetryInvalidJSONPolling - Long running delete request, service returns a 202 to the initial request.
// Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
func (client *LROSADsClient) deleteAsyncRelativeRetryInvalidJSONPolling(ctx context.Context, options *LROSADsClientBeginDeleteAsyncRelativeRetryInvalidJSONPollingOptions) (*http.Response, error) {
	req, err := client.deleteAsyncRelativeRetryInvalidJSONPollingCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// deleteAsyncRelativeRetryInvalidJSONPollingCreateRequest creates the DeleteAsyncRelativeRetryInvalidJSONPolling request.
func (client *LROSADsClient) deleteAsyncRelativeRetryInvalidJSONPollingCreateRequest(ctx context.Context, options *LROSADsClientBeginDeleteAsyncRelativeRetryInvalidJSONPollingOptions) (*policy.Request, error) {
	urlPath := "/lro/error/deleteasync/retry/invalidjsonpolling"
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// BeginDeleteAsyncRelativeRetryNoStatus - Long running delete request, service returns a 202 to the initial request. Poll
// the endpoint indicated in the Azure-AsyncOperation header for operation status
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - LROSADsClientBeginDeleteAsyncRelativeRetryNoStatusOptions contains the optional parameters for the LROSADsClient.BeginDeleteAsyncRelativeRetryNoStatus
// method.
func (client *LROSADsClient) BeginDeleteAsyncRelativeRetryNoStatus(ctx context.Context, options *LROSADsClientBeginDeleteAsyncRelativeRetryNoStatusOptions) (*runtime.Poller[LROSADsClientDeleteAsyncRelativeRetryNoStatusResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.deleteAsyncRelativeRetryNoStatus(ctx, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[LROSADsClientDeleteAsyncRelativeRetryNoStatusResponse](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[LROSADsClientDeleteAsyncRelativeRetryNoStatusResponse](options.ResumeToken, client.pl, nil)
	}
}

// DeleteAsyncRelativeRetryNoStatus - Long running delete request, service returns a 202 to the initial request. Poll the
// endpoint indicated in the Azure-AsyncOperation header for operation status
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
func (client *LROSADsClient) deleteAsyncRelativeRetryNoStatus(ctx context.Context, options *LROSADsClientBeginDeleteAsyncRelativeRetryNoStatusOptions) (*http.Response, error) {
	req, err := client.deleteAsyncRelativeRetryNoStatusCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// deleteAsyncRelativeRetryNoStatusCreateRequest creates the DeleteAsyncRelativeRetryNoStatus request.
func (client *LROSADsClient) deleteAsyncRelativeRetryNoStatusCreateRequest(ctx context.Context, options *LROSADsClientBeginDeleteAsyncRelativeRetryNoStatusOptions) (*policy.Request, error) {
	urlPath := "/lro/error/deleteasync/retry/nostatus"
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// BeginDeleteNonRetry400 - Long running delete request, service returns a 400 with an error body
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - LROSADsClientBeginDeleteNonRetry400Options contains the optional parameters for the LROSADsClient.BeginDeleteNonRetry400
// method.
func (client *LROSADsClient) BeginDeleteNonRetry400(ctx context.Context, options *LROSADsClientBeginDeleteNonRetry400Options) (*runtime.Poller[LROSADsClientDeleteNonRetry400Response], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.deleteNonRetry400(ctx, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[LROSADsClientDeleteNonRetry400Response](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[LROSADsClientDeleteNonRetry400Response](options.ResumeToken, client.pl, nil)
	}
}

// DeleteNonRetry400 - Long running delete request, service returns a 400 with an error body
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
func (client *LROSADsClient) deleteNonRetry400(ctx context.Context, options *LROSADsClientBeginDeleteNonRetry400Options) (*http.Response, error) {
	req, err := client.deleteNonRetry400CreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// deleteNonRetry400CreateRequest creates the DeleteNonRetry400 request.
func (client *LROSADsClient) deleteNonRetry400CreateRequest(ctx context.Context, options *LROSADsClientBeginDeleteNonRetry400Options) (*policy.Request, error) {
	urlPath := "/lro/nonretryerror/delete/400"
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// BeginPost202NoLocation - Long running post request, service returns a 202 to the initial request, without a location header.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - LROSADsClientBeginPost202NoLocationOptions contains the optional parameters for the LROSADsClient.BeginPost202NoLocation
// method.
func (client *LROSADsClient) BeginPost202NoLocation(ctx context.Context, options *LROSADsClientBeginPost202NoLocationOptions) (*runtime.Poller[LROSADsClientPost202NoLocationResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.post202NoLocation(ctx, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[LROSADsClientPost202NoLocationResponse](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[LROSADsClientPost202NoLocationResponse](options.ResumeToken, client.pl, nil)
	}
}

// Post202NoLocation - Long running post request, service returns a 202 to the initial request, without a location header.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
func (client *LROSADsClient) post202NoLocation(ctx context.Context, options *LROSADsClientBeginPost202NoLocationOptions) (*http.Response, error) {
	req, err := client.post202NoLocationCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// post202NoLocationCreateRequest creates the Post202NoLocation request.
func (client *LROSADsClient) post202NoLocationCreateRequest(ctx context.Context, options *LROSADsClientBeginPost202NoLocationOptions) (*policy.Request, error) {
	urlPath := "/lro/error/post/202/nolocation"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.Product != nil {
		return req, runtime.MarshalAsJSON(req, *options.Product)
	}
	return req, nil
}

// BeginPost202NonRetry400 - Long running post request, service returns a 202 with a location header
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - LROSADsClientBeginPost202NonRetry400Options contains the optional parameters for the LROSADsClient.BeginPost202NonRetry400
// method.
func (client *LROSADsClient) BeginPost202NonRetry400(ctx context.Context, options *LROSADsClientBeginPost202NonRetry400Options) (*runtime.Poller[LROSADsClientPost202NonRetry400Response], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.post202NonRetry400(ctx, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[LROSADsClientPost202NonRetry400Response](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[LROSADsClientPost202NonRetry400Response](options.ResumeToken, client.pl, nil)
	}
}

// Post202NonRetry400 - Long running post request, service returns a 202 with a location header
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
func (client *LROSADsClient) post202NonRetry400(ctx context.Context, options *LROSADsClientBeginPost202NonRetry400Options) (*http.Response, error) {
	req, err := client.post202NonRetry400CreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// post202NonRetry400CreateRequest creates the Post202NonRetry400 request.
func (client *LROSADsClient) post202NonRetry400CreateRequest(ctx context.Context, options *LROSADsClientBeginPost202NonRetry400Options) (*policy.Request, error) {
	urlPath := "/lro/nonretryerror/post/202/retry/400"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.Product != nil {
		return req, runtime.MarshalAsJSON(req, *options.Product)
	}
	return req, nil
}

// BeginPost202RetryInvalidHeader - Long running post request, service returns a 202 to the initial request, with invalid
// 'Location' and 'Retry-After' headers.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - LROSADsClientBeginPost202RetryInvalidHeaderOptions contains the optional parameters for the LROSADsClient.BeginPost202RetryInvalidHeader
// method.
func (client *LROSADsClient) BeginPost202RetryInvalidHeader(ctx context.Context, options *LROSADsClientBeginPost202RetryInvalidHeaderOptions) (*runtime.Poller[LROSADsClientPost202RetryInvalidHeaderResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.post202RetryInvalidHeader(ctx, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[LROSADsClientPost202RetryInvalidHeaderResponse](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[LROSADsClientPost202RetryInvalidHeaderResponse](options.ResumeToken, client.pl, nil)
	}
}

// Post202RetryInvalidHeader - Long running post request, service returns a 202 to the initial request, with invalid 'Location'
// and 'Retry-After' headers.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
func (client *LROSADsClient) post202RetryInvalidHeader(ctx context.Context, options *LROSADsClientBeginPost202RetryInvalidHeaderOptions) (*http.Response, error) {
	req, err := client.post202RetryInvalidHeaderCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// post202RetryInvalidHeaderCreateRequest creates the Post202RetryInvalidHeader request.
func (client *LROSADsClient) post202RetryInvalidHeaderCreateRequest(ctx context.Context, options *LROSADsClientBeginPost202RetryInvalidHeaderOptions) (*policy.Request, error) {
	urlPath := "/lro/error/post/202/retry/invalidheader"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.Product != nil {
		return req, runtime.MarshalAsJSON(req, *options.Product)
	}
	return req, nil
}

// BeginPostAsyncRelativeRetry400 - Long running post request, service returns a 202 to the initial request Poll the endpoint
// indicated in the Azure-AsyncOperation header for operation status
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - LROSADsClientBeginPostAsyncRelativeRetry400Options contains the optional parameters for the LROSADsClient.BeginPostAsyncRelativeRetry400
// method.
func (client *LROSADsClient) BeginPostAsyncRelativeRetry400(ctx context.Context, options *LROSADsClientBeginPostAsyncRelativeRetry400Options) (*runtime.Poller[LROSADsClientPostAsyncRelativeRetry400Response], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.postAsyncRelativeRetry400(ctx, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[LROSADsClientPostAsyncRelativeRetry400Response](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[LROSADsClientPostAsyncRelativeRetry400Response](options.ResumeToken, client.pl, nil)
	}
}

// PostAsyncRelativeRetry400 - Long running post request, service returns a 202 to the initial request Poll the endpoint indicated
// in the Azure-AsyncOperation header for operation status
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
func (client *LROSADsClient) postAsyncRelativeRetry400(ctx context.Context, options *LROSADsClientBeginPostAsyncRelativeRetry400Options) (*http.Response, error) {
	req, err := client.postAsyncRelativeRetry400CreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// postAsyncRelativeRetry400CreateRequest creates the PostAsyncRelativeRetry400 request.
func (client *LROSADsClient) postAsyncRelativeRetry400CreateRequest(ctx context.Context, options *LROSADsClientBeginPostAsyncRelativeRetry400Options) (*policy.Request, error) {
	urlPath := "/lro/nonretryerror/postasync/retry/400"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.Product != nil {
		return req, runtime.MarshalAsJSON(req, *options.Product)
	}
	return req, nil
}

// BeginPostAsyncRelativeRetryInvalidHeader - Long running post request, service returns a 202 to the initial request, with
// an entity that contains ProvisioningState=’Creating’. The endpoint indicated in the Azure-AsyncOperation header is
// invalid.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - LROSADsClientBeginPostAsyncRelativeRetryInvalidHeaderOptions contains the optional parameters for the LROSADsClient.BeginPostAsyncRelativeRetryInvalidHeader
// method.
func (client *LROSADsClient) BeginPostAsyncRelativeRetryInvalidHeader(ctx context.Context, options *LROSADsClientBeginPostAsyncRelativeRetryInvalidHeaderOptions) (*runtime.Poller[LROSADsClientPostAsyncRelativeRetryInvalidHeaderResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.postAsyncRelativeRetryInvalidHeader(ctx, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[LROSADsClientPostAsyncRelativeRetryInvalidHeaderResponse](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[LROSADsClientPostAsyncRelativeRetryInvalidHeaderResponse](options.ResumeToken, client.pl, nil)
	}
}

// PostAsyncRelativeRetryInvalidHeader - Long running post request, service returns a 202 to the initial request, with an
// entity that contains ProvisioningState=’Creating’. The endpoint indicated in the Azure-AsyncOperation header is
// invalid.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
func (client *LROSADsClient) postAsyncRelativeRetryInvalidHeader(ctx context.Context, options *LROSADsClientBeginPostAsyncRelativeRetryInvalidHeaderOptions) (*http.Response, error) {
	req, err := client.postAsyncRelativeRetryInvalidHeaderCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// postAsyncRelativeRetryInvalidHeaderCreateRequest creates the PostAsyncRelativeRetryInvalidHeader request.
func (client *LROSADsClient) postAsyncRelativeRetryInvalidHeaderCreateRequest(ctx context.Context, options *LROSADsClientBeginPostAsyncRelativeRetryInvalidHeaderOptions) (*policy.Request, error) {
	urlPath := "/lro/error/postasync/retry/invalidheader"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.Product != nil {
		return req, runtime.MarshalAsJSON(req, *options.Product)
	}
	return req, nil
}

// BeginPostAsyncRelativeRetryInvalidJSONPolling - Long running post request, service returns a 202 to the initial request,
// with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header
// for
// operation status
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - LROSADsClientBeginPostAsyncRelativeRetryInvalidJSONPollingOptions contains the optional parameters for the LROSADsClient.BeginPostAsyncRelativeRetryInvalidJSONPolling
// method.
func (client *LROSADsClient) BeginPostAsyncRelativeRetryInvalidJSONPolling(ctx context.Context, options *LROSADsClientBeginPostAsyncRelativeRetryInvalidJSONPollingOptions) (*runtime.Poller[LROSADsClientPostAsyncRelativeRetryInvalidJSONPollingResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.postAsyncRelativeRetryInvalidJSONPolling(ctx, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[LROSADsClientPostAsyncRelativeRetryInvalidJSONPollingResponse](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[LROSADsClientPostAsyncRelativeRetryInvalidJSONPollingResponse](options.ResumeToken, client.pl, nil)
	}
}

// PostAsyncRelativeRetryInvalidJSONPolling - Long running post request, service returns a 202 to the initial request, with
// an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
func (client *LROSADsClient) postAsyncRelativeRetryInvalidJSONPolling(ctx context.Context, options *LROSADsClientBeginPostAsyncRelativeRetryInvalidJSONPollingOptions) (*http.Response, error) {
	req, err := client.postAsyncRelativeRetryInvalidJSONPollingCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// postAsyncRelativeRetryInvalidJSONPollingCreateRequest creates the PostAsyncRelativeRetryInvalidJSONPolling request.
func (client *LROSADsClient) postAsyncRelativeRetryInvalidJSONPollingCreateRequest(ctx context.Context, options *LROSADsClientBeginPostAsyncRelativeRetryInvalidJSONPollingOptions) (*policy.Request, error) {
	urlPath := "/lro/error/postasync/retry/invalidjsonpolling"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.Product != nil {
		return req, runtime.MarshalAsJSON(req, *options.Product)
	}
	return req, nil
}

// BeginPostAsyncRelativeRetryNoPayload - Long running post request, service returns a 202 to the initial request, with an
// entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - LROSADsClientBeginPostAsyncRelativeRetryNoPayloadOptions contains the optional parameters for the LROSADsClient.BeginPostAsyncRelativeRetryNoPayload
// method.
func (client *LROSADsClient) BeginPostAsyncRelativeRetryNoPayload(ctx context.Context, options *LROSADsClientBeginPostAsyncRelativeRetryNoPayloadOptions) (*runtime.Poller[LROSADsClientPostAsyncRelativeRetryNoPayloadResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.postAsyncRelativeRetryNoPayload(ctx, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[LROSADsClientPostAsyncRelativeRetryNoPayloadResponse](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[LROSADsClientPostAsyncRelativeRetryNoPayloadResponse](options.ResumeToken, client.pl, nil)
	}
}

// PostAsyncRelativeRetryNoPayload - Long running post request, service returns a 202 to the initial request, with an entity
// that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
func (client *LROSADsClient) postAsyncRelativeRetryNoPayload(ctx context.Context, options *LROSADsClientBeginPostAsyncRelativeRetryNoPayloadOptions) (*http.Response, error) {
	req, err := client.postAsyncRelativeRetryNoPayloadCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// postAsyncRelativeRetryNoPayloadCreateRequest creates the PostAsyncRelativeRetryNoPayload request.
func (client *LROSADsClient) postAsyncRelativeRetryNoPayloadCreateRequest(ctx context.Context, options *LROSADsClientBeginPostAsyncRelativeRetryNoPayloadOptions) (*policy.Request, error) {
	urlPath := "/lro/error/postasync/retry/nopayload"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.Product != nil {
		return req, runtime.MarshalAsJSON(req, *options.Product)
	}
	return req, nil
}

// BeginPostNonRetry400 - Long running post request, service returns a 400 with no error body
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - LROSADsClientBeginPostNonRetry400Options contains the optional parameters for the LROSADsClient.BeginPostNonRetry400
// method.
func (client *LROSADsClient) BeginPostNonRetry400(ctx context.Context, options *LROSADsClientBeginPostNonRetry400Options) (*runtime.Poller[LROSADsClientPostNonRetry400Response], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.postNonRetry400(ctx, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[LROSADsClientPostNonRetry400Response](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[LROSADsClientPostNonRetry400Response](options.ResumeToken, client.pl, nil)
	}
}

// PostNonRetry400 - Long running post request, service returns a 400 with no error body
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
func (client *LROSADsClient) postNonRetry400(ctx context.Context, options *LROSADsClientBeginPostNonRetry400Options) (*http.Response, error) {
	req, err := client.postNonRetry400CreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// postNonRetry400CreateRequest creates the PostNonRetry400 request.
func (client *LROSADsClient) postNonRetry400CreateRequest(ctx context.Context, options *LROSADsClientBeginPostNonRetry400Options) (*policy.Request, error) {
	urlPath := "/lro/nonretryerror/post/400"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.Product != nil {
		return req, runtime.MarshalAsJSON(req, *options.Product)
	}
	return req, nil
}

// BeginPut200InvalidJSON - Long running put request, service returns a 200 to the initial request, with an entity that is
// not a valid json
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// product - Product to put
// options - LROSADsClientBeginPut200InvalidJSONOptions contains the optional parameters for the LROSADsClient.BeginPut200InvalidJSON
// method.
func (client *LROSADsClient) BeginPut200InvalidJSON(ctx context.Context, product Product, options *LROSADsClientBeginPut200InvalidJSONOptions) (*runtime.Poller[LROSADsClientPut200InvalidJSONResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.put200InvalidJSON(ctx, product, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[LROSADsClientPut200InvalidJSONResponse](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[LROSADsClientPut200InvalidJSONResponse](options.ResumeToken, client.pl, nil)
	}
}

// Put200InvalidJSON - Long running put request, service returns a 200 to the initial request, with an entity that is not
// a valid json
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
func (client *LROSADsClient) put200InvalidJSON(ctx context.Context, product Product, options *LROSADsClientBeginPut200InvalidJSONOptions) (*http.Response, error) {
	req, err := client.put200InvalidJSONCreateRequest(ctx, product, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// put200InvalidJSONCreateRequest creates the Put200InvalidJSON request.
func (client *LROSADsClient) put200InvalidJSONCreateRequest(ctx context.Context, product Product, options *LROSADsClientBeginPut200InvalidJSONOptions) (*policy.Request, error) {
	urlPath := "/lro/error/put/200/invalidjson"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, product)
}

// BeginPutAsyncRelativeRetry400 - Long running put request, service returns a 200 with ProvisioningState=’Creating’. Poll
// the endpoint indicated in the Azure-AsyncOperation header for operation status
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// product - Product to put
// options - LROSADsClientBeginPutAsyncRelativeRetry400Options contains the optional parameters for the LROSADsClient.BeginPutAsyncRelativeRetry400
// method.
func (client *LROSADsClient) BeginPutAsyncRelativeRetry400(ctx context.Context, product Product, options *LROSADsClientBeginPutAsyncRelativeRetry400Options) (*runtime.Poller[LROSADsClientPutAsyncRelativeRetry400Response], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.putAsyncRelativeRetry400(ctx, product, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[LROSADsClientPutAsyncRelativeRetry400Response](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[LROSADsClientPutAsyncRelativeRetry400Response](options.ResumeToken, client.pl, nil)
	}
}

// PutAsyncRelativeRetry400 - Long running put request, service returns a 200 with ProvisioningState=’Creating’. Poll the
// endpoint indicated in the Azure-AsyncOperation header for operation status
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
func (client *LROSADsClient) putAsyncRelativeRetry400(ctx context.Context, product Product, options *LROSADsClientBeginPutAsyncRelativeRetry400Options) (*http.Response, error) {
	req, err := client.putAsyncRelativeRetry400CreateRequest(ctx, product, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// putAsyncRelativeRetry400CreateRequest creates the PutAsyncRelativeRetry400 request.
func (client *LROSADsClient) putAsyncRelativeRetry400CreateRequest(ctx context.Context, product Product, options *LROSADsClientBeginPutAsyncRelativeRetry400Options) (*policy.Request, error) {
	urlPath := "/lro/nonretryerror/putasync/retry/400"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, product)
}

// BeginPutAsyncRelativeRetryInvalidHeader - Long running put request, service returns a 200 to the initial request, with
// an entity that contains ProvisioningState=’Creating’. The endpoint indicated in the Azure-AsyncOperation header is invalid.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// product - Product to put
// options - LROSADsClientBeginPutAsyncRelativeRetryInvalidHeaderOptions contains the optional parameters for the LROSADsClient.BeginPutAsyncRelativeRetryInvalidHeader
// method.
func (client *LROSADsClient) BeginPutAsyncRelativeRetryInvalidHeader(ctx context.Context, product Product, options *LROSADsClientBeginPutAsyncRelativeRetryInvalidHeaderOptions) (*runtime.Poller[LROSADsClientPutAsyncRelativeRetryInvalidHeaderResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.putAsyncRelativeRetryInvalidHeader(ctx, product, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[LROSADsClientPutAsyncRelativeRetryInvalidHeaderResponse](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[LROSADsClientPutAsyncRelativeRetryInvalidHeaderResponse](options.ResumeToken, client.pl, nil)
	}
}

// PutAsyncRelativeRetryInvalidHeader - Long running put request, service returns a 200 to the initial request, with an entity
// that contains ProvisioningState=’Creating’. The endpoint indicated in the Azure-AsyncOperation header is invalid.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
func (client *LROSADsClient) putAsyncRelativeRetryInvalidHeader(ctx context.Context, product Product, options *LROSADsClientBeginPutAsyncRelativeRetryInvalidHeaderOptions) (*http.Response, error) {
	req, err := client.putAsyncRelativeRetryInvalidHeaderCreateRequest(ctx, product, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// putAsyncRelativeRetryInvalidHeaderCreateRequest creates the PutAsyncRelativeRetryInvalidHeader request.
func (client *LROSADsClient) putAsyncRelativeRetryInvalidHeaderCreateRequest(ctx context.Context, product Product, options *LROSADsClientBeginPutAsyncRelativeRetryInvalidHeaderOptions) (*policy.Request, error) {
	urlPath := "/lro/error/putasync/retry/invalidheader"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, product)
}

// BeginPutAsyncRelativeRetryInvalidJSONPolling - Long running put request, service returns a 200 to the initial request,
// with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header
// for
// operation status
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// product - Product to put
// options - LROSADsClientBeginPutAsyncRelativeRetryInvalidJSONPollingOptions contains the optional parameters for the LROSADsClient.BeginPutAsyncRelativeRetryInvalidJSONPolling
// method.
func (client *LROSADsClient) BeginPutAsyncRelativeRetryInvalidJSONPolling(ctx context.Context, product Product, options *LROSADsClientBeginPutAsyncRelativeRetryInvalidJSONPollingOptions) (*runtime.Poller[LROSADsClientPutAsyncRelativeRetryInvalidJSONPollingResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.putAsyncRelativeRetryInvalidJSONPolling(ctx, product, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[LROSADsClientPutAsyncRelativeRetryInvalidJSONPollingResponse](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[LROSADsClientPutAsyncRelativeRetryInvalidJSONPollingResponse](options.ResumeToken, client.pl, nil)
	}
}

// PutAsyncRelativeRetryInvalidJSONPolling - Long running put request, service returns a 200 to the initial request, with
// an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
func (client *LROSADsClient) putAsyncRelativeRetryInvalidJSONPolling(ctx context.Context, product Product, options *LROSADsClientBeginPutAsyncRelativeRetryInvalidJSONPollingOptions) (*http.Response, error) {
	req, err := client.putAsyncRelativeRetryInvalidJSONPollingCreateRequest(ctx, product, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// putAsyncRelativeRetryInvalidJSONPollingCreateRequest creates the PutAsyncRelativeRetryInvalidJSONPolling request.
func (client *LROSADsClient) putAsyncRelativeRetryInvalidJSONPollingCreateRequest(ctx context.Context, product Product, options *LROSADsClientBeginPutAsyncRelativeRetryInvalidJSONPollingOptions) (*policy.Request, error) {
	urlPath := "/lro/error/putasync/retry/invalidjsonpolling"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, product)
}

// BeginPutAsyncRelativeRetryNoStatus - Long running put request, service returns a 200 to the initial request, with an entity
// that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// product - Product to put
// options - LROSADsClientBeginPutAsyncRelativeRetryNoStatusOptions contains the optional parameters for the LROSADsClient.BeginPutAsyncRelativeRetryNoStatus
// method.
func (client *LROSADsClient) BeginPutAsyncRelativeRetryNoStatus(ctx context.Context, product Product, options *LROSADsClientBeginPutAsyncRelativeRetryNoStatusOptions) (*runtime.Poller[LROSADsClientPutAsyncRelativeRetryNoStatusResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.putAsyncRelativeRetryNoStatus(ctx, product, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[LROSADsClientPutAsyncRelativeRetryNoStatusResponse](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[LROSADsClientPutAsyncRelativeRetryNoStatusResponse](options.ResumeToken, client.pl, nil)
	}
}

// PutAsyncRelativeRetryNoStatus - Long running put request, service returns a 200 to the initial request, with an entity
// that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
func (client *LROSADsClient) putAsyncRelativeRetryNoStatus(ctx context.Context, product Product, options *LROSADsClientBeginPutAsyncRelativeRetryNoStatusOptions) (*http.Response, error) {
	req, err := client.putAsyncRelativeRetryNoStatusCreateRequest(ctx, product, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// putAsyncRelativeRetryNoStatusCreateRequest creates the PutAsyncRelativeRetryNoStatus request.
func (client *LROSADsClient) putAsyncRelativeRetryNoStatusCreateRequest(ctx context.Context, product Product, options *LROSADsClientBeginPutAsyncRelativeRetryNoStatusOptions) (*policy.Request, error) {
	urlPath := "/lro/error/putasync/retry/nostatus"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, product)
}

// BeginPutAsyncRelativeRetryNoStatusPayload - Long running put request, service returns a 200 to the initial request, with
// an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// product - Product to put
// options - LROSADsClientBeginPutAsyncRelativeRetryNoStatusPayloadOptions contains the optional parameters for the LROSADsClient.BeginPutAsyncRelativeRetryNoStatusPayload
// method.
func (client *LROSADsClient) BeginPutAsyncRelativeRetryNoStatusPayload(ctx context.Context, product Product, options *LROSADsClientBeginPutAsyncRelativeRetryNoStatusPayloadOptions) (*runtime.Poller[LROSADsClientPutAsyncRelativeRetryNoStatusPayloadResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.putAsyncRelativeRetryNoStatusPayload(ctx, product, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[LROSADsClientPutAsyncRelativeRetryNoStatusPayloadResponse](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[LROSADsClientPutAsyncRelativeRetryNoStatusPayloadResponse](options.ResumeToken, client.pl, nil)
	}
}

// PutAsyncRelativeRetryNoStatusPayload - Long running put request, service returns a 200 to the initial request, with an
// entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
func (client *LROSADsClient) putAsyncRelativeRetryNoStatusPayload(ctx context.Context, product Product, options *LROSADsClientBeginPutAsyncRelativeRetryNoStatusPayloadOptions) (*http.Response, error) {
	req, err := client.putAsyncRelativeRetryNoStatusPayloadCreateRequest(ctx, product, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// putAsyncRelativeRetryNoStatusPayloadCreateRequest creates the PutAsyncRelativeRetryNoStatusPayload request.
func (client *LROSADsClient) putAsyncRelativeRetryNoStatusPayloadCreateRequest(ctx context.Context, product Product, options *LROSADsClientBeginPutAsyncRelativeRetryNoStatusPayloadOptions) (*policy.Request, error) {
	urlPath := "/lro/error/putasync/retry/nostatuspayload"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, product)
}

// BeginPutError201NoProvisioningStatePayload - Long running put request, service returns a 201 to the initial request with
// no payload
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// product - Product to put
// options - LROSADsClientBeginPutError201NoProvisioningStatePayloadOptions contains the optional parameters for the LROSADsClient.BeginPutError201NoProvisioningStatePayload
// method.
func (client *LROSADsClient) BeginPutError201NoProvisioningStatePayload(ctx context.Context, product Product, options *LROSADsClientBeginPutError201NoProvisioningStatePayloadOptions) (*runtime.Poller[LROSADsClientPutError201NoProvisioningStatePayloadResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.putError201NoProvisioningStatePayload(ctx, product, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[LROSADsClientPutError201NoProvisioningStatePayloadResponse](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[LROSADsClientPutError201NoProvisioningStatePayloadResponse](options.ResumeToken, client.pl, nil)
	}
}

// PutError201NoProvisioningStatePayload - Long running put request, service returns a 201 to the initial request with no
// payload
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
func (client *LROSADsClient) putError201NoProvisioningStatePayload(ctx context.Context, product Product, options *LROSADsClientBeginPutError201NoProvisioningStatePayloadOptions) (*http.Response, error) {
	req, err := client.putError201NoProvisioningStatePayloadCreateRequest(ctx, product, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// putError201NoProvisioningStatePayloadCreateRequest creates the PutError201NoProvisioningStatePayload request.
func (client *LROSADsClient) putError201NoProvisioningStatePayloadCreateRequest(ctx context.Context, product Product, options *LROSADsClientBeginPutError201NoProvisioningStatePayloadOptions) (*policy.Request, error) {
	urlPath := "/lro/error/put/201/noprovisioningstatepayload"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, product)
}

// BeginPutNonRetry201Creating400 - Long running put request, service returns a Product with 'ProvisioningState' = 'Creating'
// and 201 response code
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// product - Product to put
// options - LROSADsClientBeginPutNonRetry201Creating400Options contains the optional parameters for the LROSADsClient.BeginPutNonRetry201Creating400
// method.
func (client *LROSADsClient) BeginPutNonRetry201Creating400(ctx context.Context, product Product, options *LROSADsClientBeginPutNonRetry201Creating400Options) (*runtime.Poller[LROSADsClientPutNonRetry201Creating400Response], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.putNonRetry201Creating400(ctx, product, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[LROSADsClientPutNonRetry201Creating400Response](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[LROSADsClientPutNonRetry201Creating400Response](options.ResumeToken, client.pl, nil)
	}
}

// PutNonRetry201Creating400 - Long running put request, service returns a Product with 'ProvisioningState' = 'Creating' and
// 201 response code
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
func (client *LROSADsClient) putNonRetry201Creating400(ctx context.Context, product Product, options *LROSADsClientBeginPutNonRetry201Creating400Options) (*http.Response, error) {
	req, err := client.putNonRetry201Creating400CreateRequest(ctx, product, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// putNonRetry201Creating400CreateRequest creates the PutNonRetry201Creating400 request.
func (client *LROSADsClient) putNonRetry201Creating400CreateRequest(ctx context.Context, product Product, options *LROSADsClientBeginPutNonRetry201Creating400Options) (*policy.Request, error) {
	urlPath := "/lro/nonretryerror/put/201/creating/400"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, product)
}

// BeginPutNonRetry201Creating400InvalidJSON - Long running put request, service returns a Product with 'ProvisioningState'
// = 'Creating' and 201 response code
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// product - Product to put
// options - LROSADsClientBeginPutNonRetry201Creating400InvalidJSONOptions contains the optional parameters for the LROSADsClient.BeginPutNonRetry201Creating400InvalidJSON
// method.
func (client *LROSADsClient) BeginPutNonRetry201Creating400InvalidJSON(ctx context.Context, product Product, options *LROSADsClientBeginPutNonRetry201Creating400InvalidJSONOptions) (*runtime.Poller[LROSADsClientPutNonRetry201Creating400InvalidJSONResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.putNonRetry201Creating400InvalidJSON(ctx, product, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[LROSADsClientPutNonRetry201Creating400InvalidJSONResponse](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[LROSADsClientPutNonRetry201Creating400InvalidJSONResponse](options.ResumeToken, client.pl, nil)
	}
}

// PutNonRetry201Creating400InvalidJSON - Long running put request, service returns a Product with 'ProvisioningState' = 'Creating'
// and 201 response code
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
func (client *LROSADsClient) putNonRetry201Creating400InvalidJSON(ctx context.Context, product Product, options *LROSADsClientBeginPutNonRetry201Creating400InvalidJSONOptions) (*http.Response, error) {
	req, err := client.putNonRetry201Creating400InvalidJSONCreateRequest(ctx, product, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// putNonRetry201Creating400InvalidJSONCreateRequest creates the PutNonRetry201Creating400InvalidJSON request.
func (client *LROSADsClient) putNonRetry201Creating400InvalidJSONCreateRequest(ctx context.Context, product Product, options *LROSADsClientBeginPutNonRetry201Creating400InvalidJSONOptions) (*policy.Request, error) {
	urlPath := "/lro/nonretryerror/put/201/creating/400/invalidjson"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, product)
}

// BeginPutNonRetry400 - Long running put request, service returns a 400 to the initial request
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// product - Product to put
// options - LROSADsClientBeginPutNonRetry400Options contains the optional parameters for the LROSADsClient.BeginPutNonRetry400
// method.
func (client *LROSADsClient) BeginPutNonRetry400(ctx context.Context, product Product, options *LROSADsClientBeginPutNonRetry400Options) (*runtime.Poller[LROSADsClientPutNonRetry400Response], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.putNonRetry400(ctx, product, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[LROSADsClientPutNonRetry400Response](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[LROSADsClientPutNonRetry400Response](options.ResumeToken, client.pl, nil)
	}
}

// PutNonRetry400 - Long running put request, service returns a 400 to the initial request
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
func (client *LROSADsClient) putNonRetry400(ctx context.Context, product Product, options *LROSADsClientBeginPutNonRetry400Options) (*http.Response, error) {
	req, err := client.putNonRetry400CreateRequest(ctx, product, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// putNonRetry400CreateRequest creates the PutNonRetry400 request.
func (client *LROSADsClient) putNonRetry400CreateRequest(ctx context.Context, product Product, options *LROSADsClientBeginPutNonRetry400Options) (*policy.Request, error) {
	urlPath := "/lro/nonretryerror/put/400"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, product)
}
