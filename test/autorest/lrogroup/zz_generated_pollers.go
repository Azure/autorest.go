//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package lrogroup

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/armcore"
	"net/http"
)

// LRORetrysDelete202Retry200Poller provides polling facilities until the operation reaches a terminal state.
type LRORetrysDelete202Retry200Poller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LRORetrysDelete202Retry200Poller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LRORetrysDelete202Retry200Poller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LRORetrysDelete202Retry200Response will be returned.
func (p *LRORetrysDelete202Retry200Poller) FinalResponse(ctx context.Context) (LRORetrysDelete202Retry200Response, error) {
	respType := LRORetrysDelete202Retry200Response{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LRORetrysDelete202Retry200Response{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LRORetrysDelete202Retry200Poller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LRORetrysDeleteAsyncRelativeRetrySucceededPoller provides polling facilities until the operation reaches a terminal state.
type LRORetrysDeleteAsyncRelativeRetrySucceededPoller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LRORetrysDeleteAsyncRelativeRetrySucceededPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LRORetrysDeleteAsyncRelativeRetrySucceededPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LRORetrysDeleteAsyncRelativeRetrySucceededResponse will be returned.
func (p *LRORetrysDeleteAsyncRelativeRetrySucceededPoller) FinalResponse(ctx context.Context) (LRORetrysDeleteAsyncRelativeRetrySucceededResponse, error) {
	respType := LRORetrysDeleteAsyncRelativeRetrySucceededResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LRORetrysDeleteAsyncRelativeRetrySucceededResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LRORetrysDeleteAsyncRelativeRetrySucceededPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LRORetrysDeleteProvisioning202Accepted200SucceededPoller provides polling facilities until the operation reaches a terminal state.
type LRORetrysDeleteProvisioning202Accepted200SucceededPoller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LRORetrysDeleteProvisioning202Accepted200SucceededPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LRORetrysDeleteProvisioning202Accepted200SucceededPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LRORetrysDeleteProvisioning202Accepted200SucceededResponse will be returned.
func (p *LRORetrysDeleteProvisioning202Accepted200SucceededPoller) FinalResponse(ctx context.Context) (LRORetrysDeleteProvisioning202Accepted200SucceededResponse, error) {
	respType := LRORetrysDeleteProvisioning202Accepted200SucceededResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Product)
	if err != nil {
		return LRORetrysDeleteProvisioning202Accepted200SucceededResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LRORetrysDeleteProvisioning202Accepted200SucceededPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LRORetrysPost202Retry200Poller provides polling facilities until the operation reaches a terminal state.
type LRORetrysPost202Retry200Poller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LRORetrysPost202Retry200Poller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LRORetrysPost202Retry200Poller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LRORetrysPost202Retry200Response will be returned.
func (p *LRORetrysPost202Retry200Poller) FinalResponse(ctx context.Context) (LRORetrysPost202Retry200Response, error) {
	respType := LRORetrysPost202Retry200Response{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LRORetrysPost202Retry200Response{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LRORetrysPost202Retry200Poller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LRORetrysPostAsyncRelativeRetrySucceededPoller provides polling facilities until the operation reaches a terminal state.
type LRORetrysPostAsyncRelativeRetrySucceededPoller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LRORetrysPostAsyncRelativeRetrySucceededPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LRORetrysPostAsyncRelativeRetrySucceededPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LRORetrysPostAsyncRelativeRetrySucceededResponse will be returned.
func (p *LRORetrysPostAsyncRelativeRetrySucceededPoller) FinalResponse(ctx context.Context) (LRORetrysPostAsyncRelativeRetrySucceededResponse, error) {
	respType := LRORetrysPostAsyncRelativeRetrySucceededResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LRORetrysPostAsyncRelativeRetrySucceededResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LRORetrysPostAsyncRelativeRetrySucceededPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LRORetrysPut201CreatingSucceeded200Poller provides polling facilities until the operation reaches a terminal state.
type LRORetrysPut201CreatingSucceeded200Poller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LRORetrysPut201CreatingSucceeded200Poller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LRORetrysPut201CreatingSucceeded200Poller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LRORetrysPut201CreatingSucceeded200Response will be returned.
func (p *LRORetrysPut201CreatingSucceeded200Poller) FinalResponse(ctx context.Context) (LRORetrysPut201CreatingSucceeded200Response, error) {
	respType := LRORetrysPut201CreatingSucceeded200Response{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Product)
	if err != nil {
		return LRORetrysPut201CreatingSucceeded200Response{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LRORetrysPut201CreatingSucceeded200Poller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LRORetrysPutAsyncRelativeRetrySucceededPoller provides polling facilities until the operation reaches a terminal state.
type LRORetrysPutAsyncRelativeRetrySucceededPoller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LRORetrysPutAsyncRelativeRetrySucceededPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LRORetrysPutAsyncRelativeRetrySucceededPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LRORetrysPutAsyncRelativeRetrySucceededResponse will be returned.
func (p *LRORetrysPutAsyncRelativeRetrySucceededPoller) FinalResponse(ctx context.Context) (LRORetrysPutAsyncRelativeRetrySucceededResponse, error) {
	respType := LRORetrysPutAsyncRelativeRetrySucceededResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Product)
	if err != nil {
		return LRORetrysPutAsyncRelativeRetrySucceededResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LRORetrysPutAsyncRelativeRetrySucceededPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROSADsDelete202NonRetry400Poller provides polling facilities until the operation reaches a terminal state.
type LROSADsDelete202NonRetry400Poller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROSADsDelete202NonRetry400Poller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROSADsDelete202NonRetry400Poller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROSADsDelete202NonRetry400Response will be returned.
func (p *LROSADsDelete202NonRetry400Poller) FinalResponse(ctx context.Context) (LROSADsDelete202NonRetry400Response, error) {
	respType := LROSADsDelete202NonRetry400Response{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LROSADsDelete202NonRetry400Response{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROSADsDelete202NonRetry400Poller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROSADsDelete202RetryInvalidHeaderPoller provides polling facilities until the operation reaches a terminal state.
type LROSADsDelete202RetryInvalidHeaderPoller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROSADsDelete202RetryInvalidHeaderPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROSADsDelete202RetryInvalidHeaderPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROSADsDelete202RetryInvalidHeaderResponse will be returned.
func (p *LROSADsDelete202RetryInvalidHeaderPoller) FinalResponse(ctx context.Context) (LROSADsDelete202RetryInvalidHeaderResponse, error) {
	respType := LROSADsDelete202RetryInvalidHeaderResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LROSADsDelete202RetryInvalidHeaderResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROSADsDelete202RetryInvalidHeaderPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROSADsDelete204SucceededPoller provides polling facilities until the operation reaches a terminal state.
type LROSADsDelete204SucceededPoller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROSADsDelete204SucceededPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROSADsDelete204SucceededPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROSADsDelete204SucceededResponse will be returned.
func (p *LROSADsDelete204SucceededPoller) FinalResponse(ctx context.Context) (LROSADsDelete204SucceededResponse, error) {
	respType := LROSADsDelete204SucceededResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LROSADsDelete204SucceededResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROSADsDelete204SucceededPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROSADsDeleteAsyncRelativeRetry400Poller provides polling facilities until the operation reaches a terminal state.
type LROSADsDeleteAsyncRelativeRetry400Poller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROSADsDeleteAsyncRelativeRetry400Poller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROSADsDeleteAsyncRelativeRetry400Poller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROSADsDeleteAsyncRelativeRetry400Response will be returned.
func (p *LROSADsDeleteAsyncRelativeRetry400Poller) FinalResponse(ctx context.Context) (LROSADsDeleteAsyncRelativeRetry400Response, error) {
	respType := LROSADsDeleteAsyncRelativeRetry400Response{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LROSADsDeleteAsyncRelativeRetry400Response{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROSADsDeleteAsyncRelativeRetry400Poller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROSADsDeleteAsyncRelativeRetryInvalidHeaderPoller provides polling facilities until the operation reaches a terminal state.
type LROSADsDeleteAsyncRelativeRetryInvalidHeaderPoller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROSADsDeleteAsyncRelativeRetryInvalidHeaderPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROSADsDeleteAsyncRelativeRetryInvalidHeaderPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROSADsDeleteAsyncRelativeRetryInvalidHeaderResponse will be returned.
func (p *LROSADsDeleteAsyncRelativeRetryInvalidHeaderPoller) FinalResponse(ctx context.Context) (LROSADsDeleteAsyncRelativeRetryInvalidHeaderResponse, error) {
	respType := LROSADsDeleteAsyncRelativeRetryInvalidHeaderResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LROSADsDeleteAsyncRelativeRetryInvalidHeaderResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROSADsDeleteAsyncRelativeRetryInvalidHeaderPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROSADsDeleteAsyncRelativeRetryInvalidJSONPollingPoller provides polling facilities until the operation reaches a terminal state.
type LROSADsDeleteAsyncRelativeRetryInvalidJSONPollingPoller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROSADsDeleteAsyncRelativeRetryInvalidJSONPollingPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROSADsDeleteAsyncRelativeRetryInvalidJSONPollingPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROSADsDeleteAsyncRelativeRetryInvalidJSONPollingResponse will be returned.
func (p *LROSADsDeleteAsyncRelativeRetryInvalidJSONPollingPoller) FinalResponse(ctx context.Context) (LROSADsDeleteAsyncRelativeRetryInvalidJSONPollingResponse, error) {
	respType := LROSADsDeleteAsyncRelativeRetryInvalidJSONPollingResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LROSADsDeleteAsyncRelativeRetryInvalidJSONPollingResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROSADsDeleteAsyncRelativeRetryInvalidJSONPollingPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROSADsDeleteAsyncRelativeRetryNoStatusPoller provides polling facilities until the operation reaches a terminal state.
type LROSADsDeleteAsyncRelativeRetryNoStatusPoller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROSADsDeleteAsyncRelativeRetryNoStatusPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROSADsDeleteAsyncRelativeRetryNoStatusPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROSADsDeleteAsyncRelativeRetryNoStatusResponse will be returned.
func (p *LROSADsDeleteAsyncRelativeRetryNoStatusPoller) FinalResponse(ctx context.Context) (LROSADsDeleteAsyncRelativeRetryNoStatusResponse, error) {
	respType := LROSADsDeleteAsyncRelativeRetryNoStatusResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LROSADsDeleteAsyncRelativeRetryNoStatusResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROSADsDeleteAsyncRelativeRetryNoStatusPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROSADsDeleteNonRetry400Poller provides polling facilities until the operation reaches a terminal state.
type LROSADsDeleteNonRetry400Poller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROSADsDeleteNonRetry400Poller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROSADsDeleteNonRetry400Poller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROSADsDeleteNonRetry400Response will be returned.
func (p *LROSADsDeleteNonRetry400Poller) FinalResponse(ctx context.Context) (LROSADsDeleteNonRetry400Response, error) {
	respType := LROSADsDeleteNonRetry400Response{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LROSADsDeleteNonRetry400Response{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROSADsDeleteNonRetry400Poller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROSADsPost202NoLocationPoller provides polling facilities until the operation reaches a terminal state.
type LROSADsPost202NoLocationPoller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROSADsPost202NoLocationPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROSADsPost202NoLocationPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROSADsPost202NoLocationResponse will be returned.
func (p *LROSADsPost202NoLocationPoller) FinalResponse(ctx context.Context) (LROSADsPost202NoLocationResponse, error) {
	respType := LROSADsPost202NoLocationResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LROSADsPost202NoLocationResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROSADsPost202NoLocationPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROSADsPost202NonRetry400Poller provides polling facilities until the operation reaches a terminal state.
type LROSADsPost202NonRetry400Poller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROSADsPost202NonRetry400Poller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROSADsPost202NonRetry400Poller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROSADsPost202NonRetry400Response will be returned.
func (p *LROSADsPost202NonRetry400Poller) FinalResponse(ctx context.Context) (LROSADsPost202NonRetry400Response, error) {
	respType := LROSADsPost202NonRetry400Response{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LROSADsPost202NonRetry400Response{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROSADsPost202NonRetry400Poller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROSADsPost202RetryInvalidHeaderPoller provides polling facilities until the operation reaches a terminal state.
type LROSADsPost202RetryInvalidHeaderPoller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROSADsPost202RetryInvalidHeaderPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROSADsPost202RetryInvalidHeaderPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROSADsPost202RetryInvalidHeaderResponse will be returned.
func (p *LROSADsPost202RetryInvalidHeaderPoller) FinalResponse(ctx context.Context) (LROSADsPost202RetryInvalidHeaderResponse, error) {
	respType := LROSADsPost202RetryInvalidHeaderResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LROSADsPost202RetryInvalidHeaderResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROSADsPost202RetryInvalidHeaderPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROSADsPostAsyncRelativeRetry400Poller provides polling facilities until the operation reaches a terminal state.
type LROSADsPostAsyncRelativeRetry400Poller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROSADsPostAsyncRelativeRetry400Poller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROSADsPostAsyncRelativeRetry400Poller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROSADsPostAsyncRelativeRetry400Response will be returned.
func (p *LROSADsPostAsyncRelativeRetry400Poller) FinalResponse(ctx context.Context) (LROSADsPostAsyncRelativeRetry400Response, error) {
	respType := LROSADsPostAsyncRelativeRetry400Response{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LROSADsPostAsyncRelativeRetry400Response{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROSADsPostAsyncRelativeRetry400Poller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROSADsPostAsyncRelativeRetryInvalidHeaderPoller provides polling facilities until the operation reaches a terminal state.
type LROSADsPostAsyncRelativeRetryInvalidHeaderPoller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROSADsPostAsyncRelativeRetryInvalidHeaderPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROSADsPostAsyncRelativeRetryInvalidHeaderPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROSADsPostAsyncRelativeRetryInvalidHeaderResponse will be returned.
func (p *LROSADsPostAsyncRelativeRetryInvalidHeaderPoller) FinalResponse(ctx context.Context) (LROSADsPostAsyncRelativeRetryInvalidHeaderResponse, error) {
	respType := LROSADsPostAsyncRelativeRetryInvalidHeaderResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LROSADsPostAsyncRelativeRetryInvalidHeaderResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROSADsPostAsyncRelativeRetryInvalidHeaderPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROSADsPostAsyncRelativeRetryInvalidJSONPollingPoller provides polling facilities until the operation reaches a terminal state.
type LROSADsPostAsyncRelativeRetryInvalidJSONPollingPoller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROSADsPostAsyncRelativeRetryInvalidJSONPollingPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROSADsPostAsyncRelativeRetryInvalidJSONPollingPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROSADsPostAsyncRelativeRetryInvalidJSONPollingResponse will be returned.
func (p *LROSADsPostAsyncRelativeRetryInvalidJSONPollingPoller) FinalResponse(ctx context.Context) (LROSADsPostAsyncRelativeRetryInvalidJSONPollingResponse, error) {
	respType := LROSADsPostAsyncRelativeRetryInvalidJSONPollingResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LROSADsPostAsyncRelativeRetryInvalidJSONPollingResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROSADsPostAsyncRelativeRetryInvalidJSONPollingPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROSADsPostAsyncRelativeRetryNoPayloadPoller provides polling facilities until the operation reaches a terminal state.
type LROSADsPostAsyncRelativeRetryNoPayloadPoller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROSADsPostAsyncRelativeRetryNoPayloadPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROSADsPostAsyncRelativeRetryNoPayloadPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROSADsPostAsyncRelativeRetryNoPayloadResponse will be returned.
func (p *LROSADsPostAsyncRelativeRetryNoPayloadPoller) FinalResponse(ctx context.Context) (LROSADsPostAsyncRelativeRetryNoPayloadResponse, error) {
	respType := LROSADsPostAsyncRelativeRetryNoPayloadResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LROSADsPostAsyncRelativeRetryNoPayloadResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROSADsPostAsyncRelativeRetryNoPayloadPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROSADsPostNonRetry400Poller provides polling facilities until the operation reaches a terminal state.
type LROSADsPostNonRetry400Poller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROSADsPostNonRetry400Poller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROSADsPostNonRetry400Poller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROSADsPostNonRetry400Response will be returned.
func (p *LROSADsPostNonRetry400Poller) FinalResponse(ctx context.Context) (LROSADsPostNonRetry400Response, error) {
	respType := LROSADsPostNonRetry400Response{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LROSADsPostNonRetry400Response{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROSADsPostNonRetry400Poller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROSADsPut200InvalidJSONPoller provides polling facilities until the operation reaches a terminal state.
type LROSADsPut200InvalidJSONPoller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROSADsPut200InvalidJSONPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROSADsPut200InvalidJSONPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROSADsPut200InvalidJSONResponse will be returned.
func (p *LROSADsPut200InvalidJSONPoller) FinalResponse(ctx context.Context) (LROSADsPut200InvalidJSONResponse, error) {
	respType := LROSADsPut200InvalidJSONResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Product)
	if err != nil {
		return LROSADsPut200InvalidJSONResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROSADsPut200InvalidJSONPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROSADsPutAsyncRelativeRetry400Poller provides polling facilities until the operation reaches a terminal state.
type LROSADsPutAsyncRelativeRetry400Poller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROSADsPutAsyncRelativeRetry400Poller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROSADsPutAsyncRelativeRetry400Poller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROSADsPutAsyncRelativeRetry400Response will be returned.
func (p *LROSADsPutAsyncRelativeRetry400Poller) FinalResponse(ctx context.Context) (LROSADsPutAsyncRelativeRetry400Response, error) {
	respType := LROSADsPutAsyncRelativeRetry400Response{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Product)
	if err != nil {
		return LROSADsPutAsyncRelativeRetry400Response{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROSADsPutAsyncRelativeRetry400Poller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROSADsPutAsyncRelativeRetryInvalidHeaderPoller provides polling facilities until the operation reaches a terminal state.
type LROSADsPutAsyncRelativeRetryInvalidHeaderPoller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROSADsPutAsyncRelativeRetryInvalidHeaderPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROSADsPutAsyncRelativeRetryInvalidHeaderPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROSADsPutAsyncRelativeRetryInvalidHeaderResponse will be returned.
func (p *LROSADsPutAsyncRelativeRetryInvalidHeaderPoller) FinalResponse(ctx context.Context) (LROSADsPutAsyncRelativeRetryInvalidHeaderResponse, error) {
	respType := LROSADsPutAsyncRelativeRetryInvalidHeaderResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Product)
	if err != nil {
		return LROSADsPutAsyncRelativeRetryInvalidHeaderResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROSADsPutAsyncRelativeRetryInvalidHeaderPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROSADsPutAsyncRelativeRetryInvalidJSONPollingPoller provides polling facilities until the operation reaches a terminal state.
type LROSADsPutAsyncRelativeRetryInvalidJSONPollingPoller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROSADsPutAsyncRelativeRetryInvalidJSONPollingPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROSADsPutAsyncRelativeRetryInvalidJSONPollingPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROSADsPutAsyncRelativeRetryInvalidJSONPollingResponse will be returned.
func (p *LROSADsPutAsyncRelativeRetryInvalidJSONPollingPoller) FinalResponse(ctx context.Context) (LROSADsPutAsyncRelativeRetryInvalidJSONPollingResponse, error) {
	respType := LROSADsPutAsyncRelativeRetryInvalidJSONPollingResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Product)
	if err != nil {
		return LROSADsPutAsyncRelativeRetryInvalidJSONPollingResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROSADsPutAsyncRelativeRetryInvalidJSONPollingPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROSADsPutAsyncRelativeRetryNoStatusPayloadPoller provides polling facilities until the operation reaches a terminal state.
type LROSADsPutAsyncRelativeRetryNoStatusPayloadPoller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROSADsPutAsyncRelativeRetryNoStatusPayloadPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROSADsPutAsyncRelativeRetryNoStatusPayloadPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROSADsPutAsyncRelativeRetryNoStatusPayloadResponse will be returned.
func (p *LROSADsPutAsyncRelativeRetryNoStatusPayloadPoller) FinalResponse(ctx context.Context) (LROSADsPutAsyncRelativeRetryNoStatusPayloadResponse, error) {
	respType := LROSADsPutAsyncRelativeRetryNoStatusPayloadResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Product)
	if err != nil {
		return LROSADsPutAsyncRelativeRetryNoStatusPayloadResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROSADsPutAsyncRelativeRetryNoStatusPayloadPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROSADsPutAsyncRelativeRetryNoStatusPoller provides polling facilities until the operation reaches a terminal state.
type LROSADsPutAsyncRelativeRetryNoStatusPoller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROSADsPutAsyncRelativeRetryNoStatusPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROSADsPutAsyncRelativeRetryNoStatusPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROSADsPutAsyncRelativeRetryNoStatusResponse will be returned.
func (p *LROSADsPutAsyncRelativeRetryNoStatusPoller) FinalResponse(ctx context.Context) (LROSADsPutAsyncRelativeRetryNoStatusResponse, error) {
	respType := LROSADsPutAsyncRelativeRetryNoStatusResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Product)
	if err != nil {
		return LROSADsPutAsyncRelativeRetryNoStatusResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROSADsPutAsyncRelativeRetryNoStatusPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROSADsPutError201NoProvisioningStatePayloadPoller provides polling facilities until the operation reaches a terminal state.
type LROSADsPutError201NoProvisioningStatePayloadPoller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROSADsPutError201NoProvisioningStatePayloadPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROSADsPutError201NoProvisioningStatePayloadPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROSADsPutError201NoProvisioningStatePayloadResponse will be returned.
func (p *LROSADsPutError201NoProvisioningStatePayloadPoller) FinalResponse(ctx context.Context) (LROSADsPutError201NoProvisioningStatePayloadResponse, error) {
	respType := LROSADsPutError201NoProvisioningStatePayloadResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Product)
	if err != nil {
		return LROSADsPutError201NoProvisioningStatePayloadResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROSADsPutError201NoProvisioningStatePayloadPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROSADsPutNonRetry201Creating400InvalidJSONPoller provides polling facilities until the operation reaches a terminal state.
type LROSADsPutNonRetry201Creating400InvalidJSONPoller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROSADsPutNonRetry201Creating400InvalidJSONPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROSADsPutNonRetry201Creating400InvalidJSONPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROSADsPutNonRetry201Creating400InvalidJSONResponse will be returned.
func (p *LROSADsPutNonRetry201Creating400InvalidJSONPoller) FinalResponse(ctx context.Context) (LROSADsPutNonRetry201Creating400InvalidJSONResponse, error) {
	respType := LROSADsPutNonRetry201Creating400InvalidJSONResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Product)
	if err != nil {
		return LROSADsPutNonRetry201Creating400InvalidJSONResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROSADsPutNonRetry201Creating400InvalidJSONPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROSADsPutNonRetry201Creating400Poller provides polling facilities until the operation reaches a terminal state.
type LROSADsPutNonRetry201Creating400Poller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROSADsPutNonRetry201Creating400Poller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROSADsPutNonRetry201Creating400Poller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROSADsPutNonRetry201Creating400Response will be returned.
func (p *LROSADsPutNonRetry201Creating400Poller) FinalResponse(ctx context.Context) (LROSADsPutNonRetry201Creating400Response, error) {
	respType := LROSADsPutNonRetry201Creating400Response{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Product)
	if err != nil {
		return LROSADsPutNonRetry201Creating400Response{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROSADsPutNonRetry201Creating400Poller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROSADsPutNonRetry400Poller provides polling facilities until the operation reaches a terminal state.
type LROSADsPutNonRetry400Poller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROSADsPutNonRetry400Poller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROSADsPutNonRetry400Poller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROSADsPutNonRetry400Response will be returned.
func (p *LROSADsPutNonRetry400Poller) FinalResponse(ctx context.Context) (LROSADsPutNonRetry400Response, error) {
	respType := LROSADsPutNonRetry400Response{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Product)
	if err != nil {
		return LROSADsPutNonRetry400Response{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROSADsPutNonRetry400Poller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROsCustomHeaderPost202Retry200Poller provides polling facilities until the operation reaches a terminal state.
type LROsCustomHeaderPost202Retry200Poller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsCustomHeaderPost202Retry200Poller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROsCustomHeaderPost202Retry200Poller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROsCustomHeaderPost202Retry200Response will be returned.
func (p *LROsCustomHeaderPost202Retry200Poller) FinalResponse(ctx context.Context) (LROsCustomHeaderPost202Retry200Response, error) {
	respType := LROsCustomHeaderPost202Retry200Response{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LROsCustomHeaderPost202Retry200Response{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROsCustomHeaderPost202Retry200Poller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROsCustomHeaderPostAsyncRetrySucceededPoller provides polling facilities until the operation reaches a terminal state.
type LROsCustomHeaderPostAsyncRetrySucceededPoller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsCustomHeaderPostAsyncRetrySucceededPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROsCustomHeaderPostAsyncRetrySucceededPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROsCustomHeaderPostAsyncRetrySucceededResponse will be returned.
func (p *LROsCustomHeaderPostAsyncRetrySucceededPoller) FinalResponse(ctx context.Context) (LROsCustomHeaderPostAsyncRetrySucceededResponse, error) {
	respType := LROsCustomHeaderPostAsyncRetrySucceededResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LROsCustomHeaderPostAsyncRetrySucceededResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROsCustomHeaderPostAsyncRetrySucceededPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROsCustomHeaderPut201CreatingSucceeded200Poller provides polling facilities until the operation reaches a terminal state.
type LROsCustomHeaderPut201CreatingSucceeded200Poller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsCustomHeaderPut201CreatingSucceeded200Poller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROsCustomHeaderPut201CreatingSucceeded200Poller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROsCustomHeaderPut201CreatingSucceeded200Response will be returned.
func (p *LROsCustomHeaderPut201CreatingSucceeded200Poller) FinalResponse(ctx context.Context) (LROsCustomHeaderPut201CreatingSucceeded200Response, error) {
	respType := LROsCustomHeaderPut201CreatingSucceeded200Response{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Product)
	if err != nil {
		return LROsCustomHeaderPut201CreatingSucceeded200Response{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROsCustomHeaderPut201CreatingSucceeded200Poller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROsCustomHeaderPutAsyncRetrySucceededPoller provides polling facilities until the operation reaches a terminal state.
type LROsCustomHeaderPutAsyncRetrySucceededPoller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsCustomHeaderPutAsyncRetrySucceededPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROsCustomHeaderPutAsyncRetrySucceededPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROsCustomHeaderPutAsyncRetrySucceededResponse will be returned.
func (p *LROsCustomHeaderPutAsyncRetrySucceededPoller) FinalResponse(ctx context.Context) (LROsCustomHeaderPutAsyncRetrySucceededResponse, error) {
	respType := LROsCustomHeaderPutAsyncRetrySucceededResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Product)
	if err != nil {
		return LROsCustomHeaderPutAsyncRetrySucceededResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROsCustomHeaderPutAsyncRetrySucceededPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROsDelete202NoRetry204Poller provides polling facilities until the operation reaches a terminal state.
type LROsDelete202NoRetry204Poller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsDelete202NoRetry204Poller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROsDelete202NoRetry204Poller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROsDelete202NoRetry204Response will be returned.
func (p *LROsDelete202NoRetry204Poller) FinalResponse(ctx context.Context) (LROsDelete202NoRetry204Response, error) {
	respType := LROsDelete202NoRetry204Response{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Product)
	if err != nil {
		return LROsDelete202NoRetry204Response{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROsDelete202NoRetry204Poller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROsDelete202Retry200Poller provides polling facilities until the operation reaches a terminal state.
type LROsDelete202Retry200Poller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsDelete202Retry200Poller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROsDelete202Retry200Poller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROsDelete202Retry200Response will be returned.
func (p *LROsDelete202Retry200Poller) FinalResponse(ctx context.Context) (LROsDelete202Retry200Response, error) {
	respType := LROsDelete202Retry200Response{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Product)
	if err != nil {
		return LROsDelete202Retry200Response{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROsDelete202Retry200Poller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROsDelete204SucceededPoller provides polling facilities until the operation reaches a terminal state.
type LROsDelete204SucceededPoller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsDelete204SucceededPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROsDelete204SucceededPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROsDelete204SucceededResponse will be returned.
func (p *LROsDelete204SucceededPoller) FinalResponse(ctx context.Context) (LROsDelete204SucceededResponse, error) {
	respType := LROsDelete204SucceededResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LROsDelete204SucceededResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROsDelete204SucceededPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROsDeleteAsyncNoHeaderInRetryPoller provides polling facilities until the operation reaches a terminal state.
type LROsDeleteAsyncNoHeaderInRetryPoller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsDeleteAsyncNoHeaderInRetryPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROsDeleteAsyncNoHeaderInRetryPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROsDeleteAsyncNoHeaderInRetryResponse will be returned.
func (p *LROsDeleteAsyncNoHeaderInRetryPoller) FinalResponse(ctx context.Context) (LROsDeleteAsyncNoHeaderInRetryResponse, error) {
	respType := LROsDeleteAsyncNoHeaderInRetryResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LROsDeleteAsyncNoHeaderInRetryResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROsDeleteAsyncNoHeaderInRetryPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROsDeleteAsyncNoRetrySucceededPoller provides polling facilities until the operation reaches a terminal state.
type LROsDeleteAsyncNoRetrySucceededPoller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsDeleteAsyncNoRetrySucceededPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROsDeleteAsyncNoRetrySucceededPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROsDeleteAsyncNoRetrySucceededResponse will be returned.
func (p *LROsDeleteAsyncNoRetrySucceededPoller) FinalResponse(ctx context.Context) (LROsDeleteAsyncNoRetrySucceededResponse, error) {
	respType := LROsDeleteAsyncNoRetrySucceededResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LROsDeleteAsyncNoRetrySucceededResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROsDeleteAsyncNoRetrySucceededPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROsDeleteAsyncRetryFailedPoller provides polling facilities until the operation reaches a terminal state.
type LROsDeleteAsyncRetryFailedPoller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsDeleteAsyncRetryFailedPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROsDeleteAsyncRetryFailedPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROsDeleteAsyncRetryFailedResponse will be returned.
func (p *LROsDeleteAsyncRetryFailedPoller) FinalResponse(ctx context.Context) (LROsDeleteAsyncRetryFailedResponse, error) {
	respType := LROsDeleteAsyncRetryFailedResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LROsDeleteAsyncRetryFailedResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROsDeleteAsyncRetryFailedPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROsDeleteAsyncRetrySucceededPoller provides polling facilities until the operation reaches a terminal state.
type LROsDeleteAsyncRetrySucceededPoller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsDeleteAsyncRetrySucceededPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROsDeleteAsyncRetrySucceededPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROsDeleteAsyncRetrySucceededResponse will be returned.
func (p *LROsDeleteAsyncRetrySucceededPoller) FinalResponse(ctx context.Context) (LROsDeleteAsyncRetrySucceededResponse, error) {
	respType := LROsDeleteAsyncRetrySucceededResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LROsDeleteAsyncRetrySucceededResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROsDeleteAsyncRetrySucceededPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROsDeleteAsyncRetrycanceledPoller provides polling facilities until the operation reaches a terminal state.
type LROsDeleteAsyncRetrycanceledPoller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsDeleteAsyncRetrycanceledPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROsDeleteAsyncRetrycanceledPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROsDeleteAsyncRetrycanceledResponse will be returned.
func (p *LROsDeleteAsyncRetrycanceledPoller) FinalResponse(ctx context.Context) (LROsDeleteAsyncRetrycanceledResponse, error) {
	respType := LROsDeleteAsyncRetrycanceledResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LROsDeleteAsyncRetrycanceledResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROsDeleteAsyncRetrycanceledPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROsDeleteNoHeaderInRetryPoller provides polling facilities until the operation reaches a terminal state.
type LROsDeleteNoHeaderInRetryPoller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsDeleteNoHeaderInRetryPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROsDeleteNoHeaderInRetryPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROsDeleteNoHeaderInRetryResponse will be returned.
func (p *LROsDeleteNoHeaderInRetryPoller) FinalResponse(ctx context.Context) (LROsDeleteNoHeaderInRetryResponse, error) {
	respType := LROsDeleteNoHeaderInRetryResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LROsDeleteNoHeaderInRetryResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROsDeleteNoHeaderInRetryPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROsDeleteProvisioning202Accepted200SucceededPoller provides polling facilities until the operation reaches a terminal state.
type LROsDeleteProvisioning202Accepted200SucceededPoller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsDeleteProvisioning202Accepted200SucceededPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROsDeleteProvisioning202Accepted200SucceededPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROsDeleteProvisioning202Accepted200SucceededResponse will be returned.
func (p *LROsDeleteProvisioning202Accepted200SucceededPoller) FinalResponse(ctx context.Context) (LROsDeleteProvisioning202Accepted200SucceededResponse, error) {
	respType := LROsDeleteProvisioning202Accepted200SucceededResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Product)
	if err != nil {
		return LROsDeleteProvisioning202Accepted200SucceededResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROsDeleteProvisioning202Accepted200SucceededPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROsDeleteProvisioning202DeletingFailed200Poller provides polling facilities until the operation reaches a terminal state.
type LROsDeleteProvisioning202DeletingFailed200Poller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsDeleteProvisioning202DeletingFailed200Poller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROsDeleteProvisioning202DeletingFailed200Poller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROsDeleteProvisioning202DeletingFailed200Response will be returned.
func (p *LROsDeleteProvisioning202DeletingFailed200Poller) FinalResponse(ctx context.Context) (LROsDeleteProvisioning202DeletingFailed200Response, error) {
	respType := LROsDeleteProvisioning202DeletingFailed200Response{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Product)
	if err != nil {
		return LROsDeleteProvisioning202DeletingFailed200Response{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROsDeleteProvisioning202DeletingFailed200Poller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROsDeleteProvisioning202Deletingcanceled200Poller provides polling facilities until the operation reaches a terminal state.
type LROsDeleteProvisioning202Deletingcanceled200Poller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsDeleteProvisioning202Deletingcanceled200Poller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROsDeleteProvisioning202Deletingcanceled200Poller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROsDeleteProvisioning202Deletingcanceled200Response will be returned.
func (p *LROsDeleteProvisioning202Deletingcanceled200Poller) FinalResponse(ctx context.Context) (LROsDeleteProvisioning202Deletingcanceled200Response, error) {
	respType := LROsDeleteProvisioning202Deletingcanceled200Response{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Product)
	if err != nil {
		return LROsDeleteProvisioning202Deletingcanceled200Response{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROsDeleteProvisioning202Deletingcanceled200Poller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROsPost200WithPayloadPoller provides polling facilities until the operation reaches a terminal state.
type LROsPost200WithPayloadPoller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsPost200WithPayloadPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROsPost200WithPayloadPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROsPost200WithPayloadResponse will be returned.
func (p *LROsPost200WithPayloadPoller) FinalResponse(ctx context.Context) (LROsPost200WithPayloadResponse, error) {
	respType := LROsPost200WithPayloadResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SKU)
	if err != nil {
		return LROsPost200WithPayloadResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROsPost200WithPayloadPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROsPost202ListPoller provides polling facilities until the operation reaches a terminal state.
type LROsPost202ListPoller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsPost202ListPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROsPost202ListPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROsPost202ListResponse will be returned.
func (p *LROsPost202ListPoller) FinalResponse(ctx context.Context) (LROsPost202ListResponse, error) {
	respType := LROsPost202ListResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ProductArray)
	if err != nil {
		return LROsPost202ListResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROsPost202ListPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROsPost202NoRetry204Poller provides polling facilities until the operation reaches a terminal state.
type LROsPost202NoRetry204Poller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsPost202NoRetry204Poller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROsPost202NoRetry204Poller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROsPost202NoRetry204Response will be returned.
func (p *LROsPost202NoRetry204Poller) FinalResponse(ctx context.Context) (LROsPost202NoRetry204Response, error) {
	respType := LROsPost202NoRetry204Response{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Product)
	if err != nil {
		return LROsPost202NoRetry204Response{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROsPost202NoRetry204Poller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROsPost202Retry200Poller provides polling facilities until the operation reaches a terminal state.
type LROsPost202Retry200Poller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsPost202Retry200Poller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROsPost202Retry200Poller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROsPost202Retry200Response will be returned.
func (p *LROsPost202Retry200Poller) FinalResponse(ctx context.Context) (LROsPost202Retry200Response, error) {
	respType := LROsPost202Retry200Response{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LROsPost202Retry200Response{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROsPost202Retry200Poller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROsPostAsyncNoRetrySucceededPoller provides polling facilities until the operation reaches a terminal state.
type LROsPostAsyncNoRetrySucceededPoller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsPostAsyncNoRetrySucceededPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROsPostAsyncNoRetrySucceededPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROsPostAsyncNoRetrySucceededResponse will be returned.
func (p *LROsPostAsyncNoRetrySucceededPoller) FinalResponse(ctx context.Context) (LROsPostAsyncNoRetrySucceededResponse, error) {
	respType := LROsPostAsyncNoRetrySucceededResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Product)
	if err != nil {
		return LROsPostAsyncNoRetrySucceededResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROsPostAsyncNoRetrySucceededPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROsPostAsyncRetryFailedPoller provides polling facilities until the operation reaches a terminal state.
type LROsPostAsyncRetryFailedPoller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsPostAsyncRetryFailedPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROsPostAsyncRetryFailedPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROsPostAsyncRetryFailedResponse will be returned.
func (p *LROsPostAsyncRetryFailedPoller) FinalResponse(ctx context.Context) (LROsPostAsyncRetryFailedResponse, error) {
	respType := LROsPostAsyncRetryFailedResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LROsPostAsyncRetryFailedResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROsPostAsyncRetryFailedPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROsPostAsyncRetrySucceededPoller provides polling facilities until the operation reaches a terminal state.
type LROsPostAsyncRetrySucceededPoller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsPostAsyncRetrySucceededPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROsPostAsyncRetrySucceededPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROsPostAsyncRetrySucceededResponse will be returned.
func (p *LROsPostAsyncRetrySucceededPoller) FinalResponse(ctx context.Context) (LROsPostAsyncRetrySucceededResponse, error) {
	respType := LROsPostAsyncRetrySucceededResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Product)
	if err != nil {
		return LROsPostAsyncRetrySucceededResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROsPostAsyncRetrySucceededPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROsPostAsyncRetrycanceledPoller provides polling facilities until the operation reaches a terminal state.
type LROsPostAsyncRetrycanceledPoller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsPostAsyncRetrycanceledPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROsPostAsyncRetrycanceledPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROsPostAsyncRetrycanceledResponse will be returned.
func (p *LROsPostAsyncRetrycanceledPoller) FinalResponse(ctx context.Context) (LROsPostAsyncRetrycanceledResponse, error) {
	respType := LROsPostAsyncRetrycanceledResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LROsPostAsyncRetrycanceledResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROsPostAsyncRetrycanceledPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROsPostDoubleHeadersFinalAzureHeaderGetDefaultPoller provides polling facilities until the operation reaches a terminal state.
type LROsPostDoubleHeadersFinalAzureHeaderGetDefaultPoller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsPostDoubleHeadersFinalAzureHeaderGetDefaultPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROsPostDoubleHeadersFinalAzureHeaderGetDefaultPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROsPostDoubleHeadersFinalAzureHeaderGetDefaultResponse will be returned.
func (p *LROsPostDoubleHeadersFinalAzureHeaderGetDefaultPoller) FinalResponse(ctx context.Context) (LROsPostDoubleHeadersFinalAzureHeaderGetDefaultResponse, error) {
	respType := LROsPostDoubleHeadersFinalAzureHeaderGetDefaultResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Product)
	if err != nil {
		return LROsPostDoubleHeadersFinalAzureHeaderGetDefaultResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROsPostDoubleHeadersFinalAzureHeaderGetDefaultPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROsPostDoubleHeadersFinalAzureHeaderGetPoller provides polling facilities until the operation reaches a terminal state.
type LROsPostDoubleHeadersFinalAzureHeaderGetPoller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsPostDoubleHeadersFinalAzureHeaderGetPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROsPostDoubleHeadersFinalAzureHeaderGetPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROsPostDoubleHeadersFinalAzureHeaderGetResponse will be returned.
func (p *LROsPostDoubleHeadersFinalAzureHeaderGetPoller) FinalResponse(ctx context.Context) (LROsPostDoubleHeadersFinalAzureHeaderGetResponse, error) {
	respType := LROsPostDoubleHeadersFinalAzureHeaderGetResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Product)
	if err != nil {
		return LROsPostDoubleHeadersFinalAzureHeaderGetResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROsPostDoubleHeadersFinalAzureHeaderGetPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROsPostDoubleHeadersFinalLocationGetPoller provides polling facilities until the operation reaches a terminal state.
type LROsPostDoubleHeadersFinalLocationGetPoller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsPostDoubleHeadersFinalLocationGetPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROsPostDoubleHeadersFinalLocationGetPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROsPostDoubleHeadersFinalLocationGetResponse will be returned.
func (p *LROsPostDoubleHeadersFinalLocationGetPoller) FinalResponse(ctx context.Context) (LROsPostDoubleHeadersFinalLocationGetResponse, error) {
	respType := LROsPostDoubleHeadersFinalLocationGetResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Product)
	if err != nil {
		return LROsPostDoubleHeadersFinalLocationGetResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROsPostDoubleHeadersFinalLocationGetPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROsPut200Acceptedcanceled200Poller provides polling facilities until the operation reaches a terminal state.
type LROsPut200Acceptedcanceled200Poller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsPut200Acceptedcanceled200Poller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROsPut200Acceptedcanceled200Poller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROsPut200Acceptedcanceled200Response will be returned.
func (p *LROsPut200Acceptedcanceled200Poller) FinalResponse(ctx context.Context) (LROsPut200Acceptedcanceled200Response, error) {
	respType := LROsPut200Acceptedcanceled200Response{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Product)
	if err != nil {
		return LROsPut200Acceptedcanceled200Response{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROsPut200Acceptedcanceled200Poller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROsPut200SucceededNoStatePoller provides polling facilities until the operation reaches a terminal state.
type LROsPut200SucceededNoStatePoller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsPut200SucceededNoStatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROsPut200SucceededNoStatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROsPut200SucceededNoStateResponse will be returned.
func (p *LROsPut200SucceededNoStatePoller) FinalResponse(ctx context.Context) (LROsPut200SucceededNoStateResponse, error) {
	respType := LROsPut200SucceededNoStateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Product)
	if err != nil {
		return LROsPut200SucceededNoStateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROsPut200SucceededNoStatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROsPut200SucceededPoller provides polling facilities until the operation reaches a terminal state.
type LROsPut200SucceededPoller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsPut200SucceededPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROsPut200SucceededPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROsPut200SucceededResponse will be returned.
func (p *LROsPut200SucceededPoller) FinalResponse(ctx context.Context) (LROsPut200SucceededResponse, error) {
	respType := LROsPut200SucceededResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Product)
	if err != nil {
		return LROsPut200SucceededResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROsPut200SucceededPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROsPut200UpdatingSucceeded204Poller provides polling facilities until the operation reaches a terminal state.
type LROsPut200UpdatingSucceeded204Poller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsPut200UpdatingSucceeded204Poller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROsPut200UpdatingSucceeded204Poller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROsPut200UpdatingSucceeded204Response will be returned.
func (p *LROsPut200UpdatingSucceeded204Poller) FinalResponse(ctx context.Context) (LROsPut200UpdatingSucceeded204Response, error) {
	respType := LROsPut200UpdatingSucceeded204Response{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Product)
	if err != nil {
		return LROsPut200UpdatingSucceeded204Response{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROsPut200UpdatingSucceeded204Poller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROsPut201CreatingFailed200Poller provides polling facilities until the operation reaches a terminal state.
type LROsPut201CreatingFailed200Poller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsPut201CreatingFailed200Poller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROsPut201CreatingFailed200Poller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROsPut201CreatingFailed200Response will be returned.
func (p *LROsPut201CreatingFailed200Poller) FinalResponse(ctx context.Context) (LROsPut201CreatingFailed200Response, error) {
	respType := LROsPut201CreatingFailed200Response{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Product)
	if err != nil {
		return LROsPut201CreatingFailed200Response{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROsPut201CreatingFailed200Poller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROsPut201CreatingSucceeded200Poller provides polling facilities until the operation reaches a terminal state.
type LROsPut201CreatingSucceeded200Poller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsPut201CreatingSucceeded200Poller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROsPut201CreatingSucceeded200Poller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROsPut201CreatingSucceeded200Response will be returned.
func (p *LROsPut201CreatingSucceeded200Poller) FinalResponse(ctx context.Context) (LROsPut201CreatingSucceeded200Response, error) {
	respType := LROsPut201CreatingSucceeded200Response{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Product)
	if err != nil {
		return LROsPut201CreatingSucceeded200Response{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROsPut201CreatingSucceeded200Poller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROsPut201SucceededPoller provides polling facilities until the operation reaches a terminal state.
type LROsPut201SucceededPoller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsPut201SucceededPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROsPut201SucceededPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROsPut201SucceededResponse will be returned.
func (p *LROsPut201SucceededPoller) FinalResponse(ctx context.Context) (LROsPut201SucceededResponse, error) {
	respType := LROsPut201SucceededResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Product)
	if err != nil {
		return LROsPut201SucceededResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROsPut201SucceededPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROsPut202Retry200Poller provides polling facilities until the operation reaches a terminal state.
type LROsPut202Retry200Poller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsPut202Retry200Poller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROsPut202Retry200Poller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROsPut202Retry200Response will be returned.
func (p *LROsPut202Retry200Poller) FinalResponse(ctx context.Context) (LROsPut202Retry200Response, error) {
	respType := LROsPut202Retry200Response{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Product)
	if err != nil {
		return LROsPut202Retry200Response{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROsPut202Retry200Poller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROsPutAsyncNoHeaderInRetryPoller provides polling facilities until the operation reaches a terminal state.
type LROsPutAsyncNoHeaderInRetryPoller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsPutAsyncNoHeaderInRetryPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROsPutAsyncNoHeaderInRetryPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROsPutAsyncNoHeaderInRetryResponse will be returned.
func (p *LROsPutAsyncNoHeaderInRetryPoller) FinalResponse(ctx context.Context) (LROsPutAsyncNoHeaderInRetryResponse, error) {
	respType := LROsPutAsyncNoHeaderInRetryResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Product)
	if err != nil {
		return LROsPutAsyncNoHeaderInRetryResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROsPutAsyncNoHeaderInRetryPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROsPutAsyncNoRetrySucceededPoller provides polling facilities until the operation reaches a terminal state.
type LROsPutAsyncNoRetrySucceededPoller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsPutAsyncNoRetrySucceededPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROsPutAsyncNoRetrySucceededPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROsPutAsyncNoRetrySucceededResponse will be returned.
func (p *LROsPutAsyncNoRetrySucceededPoller) FinalResponse(ctx context.Context) (LROsPutAsyncNoRetrySucceededResponse, error) {
	respType := LROsPutAsyncNoRetrySucceededResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Product)
	if err != nil {
		return LROsPutAsyncNoRetrySucceededResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROsPutAsyncNoRetrySucceededPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROsPutAsyncNoRetrycanceledPoller provides polling facilities until the operation reaches a terminal state.
type LROsPutAsyncNoRetrycanceledPoller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsPutAsyncNoRetrycanceledPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROsPutAsyncNoRetrycanceledPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROsPutAsyncNoRetrycanceledResponse will be returned.
func (p *LROsPutAsyncNoRetrycanceledPoller) FinalResponse(ctx context.Context) (LROsPutAsyncNoRetrycanceledResponse, error) {
	respType := LROsPutAsyncNoRetrycanceledResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Product)
	if err != nil {
		return LROsPutAsyncNoRetrycanceledResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROsPutAsyncNoRetrycanceledPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROsPutAsyncNonResourcePoller provides polling facilities until the operation reaches a terminal state.
type LROsPutAsyncNonResourcePoller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsPutAsyncNonResourcePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROsPutAsyncNonResourcePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROsPutAsyncNonResourceResponse will be returned.
func (p *LROsPutAsyncNonResourcePoller) FinalResponse(ctx context.Context) (LROsPutAsyncNonResourceResponse, error) {
	respType := LROsPutAsyncNonResourceResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SKU)
	if err != nil {
		return LROsPutAsyncNonResourceResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROsPutAsyncNonResourcePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROsPutAsyncRetryFailedPoller provides polling facilities until the operation reaches a terminal state.
type LROsPutAsyncRetryFailedPoller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsPutAsyncRetryFailedPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROsPutAsyncRetryFailedPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROsPutAsyncRetryFailedResponse will be returned.
func (p *LROsPutAsyncRetryFailedPoller) FinalResponse(ctx context.Context) (LROsPutAsyncRetryFailedResponse, error) {
	respType := LROsPutAsyncRetryFailedResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Product)
	if err != nil {
		return LROsPutAsyncRetryFailedResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROsPutAsyncRetryFailedPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROsPutAsyncRetrySucceededPoller provides polling facilities until the operation reaches a terminal state.
type LROsPutAsyncRetrySucceededPoller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsPutAsyncRetrySucceededPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROsPutAsyncRetrySucceededPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROsPutAsyncRetrySucceededResponse will be returned.
func (p *LROsPutAsyncRetrySucceededPoller) FinalResponse(ctx context.Context) (LROsPutAsyncRetrySucceededResponse, error) {
	respType := LROsPutAsyncRetrySucceededResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Product)
	if err != nil {
		return LROsPutAsyncRetrySucceededResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROsPutAsyncRetrySucceededPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROsPutAsyncSubResourcePoller provides polling facilities until the operation reaches a terminal state.
type LROsPutAsyncSubResourcePoller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsPutAsyncSubResourcePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROsPutAsyncSubResourcePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROsPutAsyncSubResourceResponse will be returned.
func (p *LROsPutAsyncSubResourcePoller) FinalResponse(ctx context.Context) (LROsPutAsyncSubResourceResponse, error) {
	respType := LROsPutAsyncSubResourceResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SubProduct)
	if err != nil {
		return LROsPutAsyncSubResourceResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROsPutAsyncSubResourcePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROsPutNoHeaderInRetryPoller provides polling facilities until the operation reaches a terminal state.
type LROsPutNoHeaderInRetryPoller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsPutNoHeaderInRetryPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROsPutNoHeaderInRetryPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROsPutNoHeaderInRetryResponse will be returned.
func (p *LROsPutNoHeaderInRetryPoller) FinalResponse(ctx context.Context) (LROsPutNoHeaderInRetryResponse, error) {
	respType := LROsPutNoHeaderInRetryResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Product)
	if err != nil {
		return LROsPutNoHeaderInRetryResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROsPutNoHeaderInRetryPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROsPutNonResourcePoller provides polling facilities until the operation reaches a terminal state.
type LROsPutNonResourcePoller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsPutNonResourcePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROsPutNonResourcePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROsPutNonResourceResponse will be returned.
func (p *LROsPutNonResourcePoller) FinalResponse(ctx context.Context) (LROsPutNonResourceResponse, error) {
	respType := LROsPutNonResourceResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SKU)
	if err != nil {
		return LROsPutNonResourceResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROsPutNonResourcePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LROsPutSubResourcePoller provides polling facilities until the operation reaches a terminal state.
type LROsPutSubResourcePoller struct {
	pt *armcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsPutSubResourcePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LROsPutSubResourcePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LROsPutSubResourceResponse will be returned.
func (p *LROsPutSubResourcePoller) FinalResponse(ctx context.Context) (LROsPutSubResourceResponse, error) {
	respType := LROsPutSubResourceResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SubProduct)
	if err != nil {
		return LROsPutSubResourceResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LROsPutSubResourcePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}
