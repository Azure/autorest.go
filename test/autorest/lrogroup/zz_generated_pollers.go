//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package lrogroup

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"net/http"
	"time"
)

// LRORetrysClientDelete202Retry200Poller provides polling facilities until the operation reaches a terminal state.
type LRORetrysClientDelete202Retry200Poller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LRORetrysClientDelete202Retry200Poller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LRORetrysClientDelete202Retry200Poller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LRORetrysClientDelete202Retry200Poller) Result(ctx context.Context) (resp LRORetrysClientDelete202Retry200Response, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LRORetrysClientDelete202Retry200Poller) PollUntilDone(ctx context.Context, freq time.Duration) (LRORetrysClientDelete202Retry200Response, error) {
	result := LRORetrysClientDelete202Retry200Response{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LRORetrysClientDelete202Retry200Poller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LRORetrysClientDelete202Retry200Poller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LRORetrysClientDelete202Retry200Poller) Resume(token string, client *LRORetrysClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LRORetrysClient.Delete202Retry200", token, client.pl)
	return
}

// LRORetrysClientDeleteAsyncRelativeRetrySucceededPoller provides polling facilities until the operation reaches a terminal state.
type LRORetrysClientDeleteAsyncRelativeRetrySucceededPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LRORetrysClientDeleteAsyncRelativeRetrySucceededPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LRORetrysClientDeleteAsyncRelativeRetrySucceededPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LRORetrysClientDeleteAsyncRelativeRetrySucceededPoller) Result(ctx context.Context) (resp LRORetrysClientDeleteAsyncRelativeRetrySucceededResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LRORetrysClientDeleteAsyncRelativeRetrySucceededPoller) PollUntilDone(ctx context.Context, freq time.Duration) (LRORetrysClientDeleteAsyncRelativeRetrySucceededResponse, error) {
	result := LRORetrysClientDeleteAsyncRelativeRetrySucceededResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LRORetrysClientDeleteAsyncRelativeRetrySucceededPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LRORetrysClientDeleteAsyncRelativeRetrySucceededPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LRORetrysClientDeleteAsyncRelativeRetrySucceededPoller) Resume(token string, client *LRORetrysClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LRORetrysClient.DeleteAsyncRelativeRetrySucceeded", token, client.pl)
	return
}

// LRORetrysClientDeleteProvisioning202Accepted200SucceededPoller provides polling facilities until the operation reaches a terminal state.
type LRORetrysClientDeleteProvisioning202Accepted200SucceededPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LRORetrysClientDeleteProvisioning202Accepted200SucceededPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LRORetrysClientDeleteProvisioning202Accepted200SucceededPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LRORetrysClientDeleteProvisioning202Accepted200SucceededPoller) Result(ctx context.Context) (resp LRORetrysClientDeleteProvisioning202Accepted200SucceededResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LRORetrysClientDeleteProvisioning202Accepted200SucceededPoller) PollUntilDone(ctx context.Context, freq time.Duration) (LRORetrysClientDeleteProvisioning202Accepted200SucceededResponse, error) {
	result := LRORetrysClientDeleteProvisioning202Accepted200SucceededResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Product)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LRORetrysClientDeleteProvisioning202Accepted200SucceededPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LRORetrysClientDeleteProvisioning202Accepted200SucceededPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LRORetrysClientDeleteProvisioning202Accepted200SucceededPoller) Resume(token string, client *LRORetrysClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LRORetrysClient.DeleteProvisioning202Accepted200Succeeded", token, client.pl)
	return
}

// LRORetrysClientPost202Retry200Poller provides polling facilities until the operation reaches a terminal state.
type LRORetrysClientPost202Retry200Poller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LRORetrysClientPost202Retry200Poller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LRORetrysClientPost202Retry200Poller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LRORetrysClientPost202Retry200Poller) Result(ctx context.Context) (resp LRORetrysClientPost202Retry200Response, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LRORetrysClientPost202Retry200Poller) PollUntilDone(ctx context.Context, freq time.Duration) (LRORetrysClientPost202Retry200Response, error) {
	result := LRORetrysClientPost202Retry200Response{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LRORetrysClientPost202Retry200Poller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LRORetrysClientPost202Retry200Poller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LRORetrysClientPost202Retry200Poller) Resume(token string, client *LRORetrysClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LRORetrysClient.Post202Retry200", token, client.pl)
	return
}

// LRORetrysClientPostAsyncRelativeRetrySucceededPoller provides polling facilities until the operation reaches a terminal state.
type LRORetrysClientPostAsyncRelativeRetrySucceededPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LRORetrysClientPostAsyncRelativeRetrySucceededPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LRORetrysClientPostAsyncRelativeRetrySucceededPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LRORetrysClientPostAsyncRelativeRetrySucceededPoller) Result(ctx context.Context) (resp LRORetrysClientPostAsyncRelativeRetrySucceededResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LRORetrysClientPostAsyncRelativeRetrySucceededPoller) PollUntilDone(ctx context.Context, freq time.Duration) (LRORetrysClientPostAsyncRelativeRetrySucceededResponse, error) {
	result := LRORetrysClientPostAsyncRelativeRetrySucceededResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LRORetrysClientPostAsyncRelativeRetrySucceededPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LRORetrysClientPostAsyncRelativeRetrySucceededPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LRORetrysClientPostAsyncRelativeRetrySucceededPoller) Resume(token string, client *LRORetrysClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LRORetrysClient.PostAsyncRelativeRetrySucceeded", token, client.pl)
	return
}

// LRORetrysClientPut201CreatingSucceeded200Poller provides polling facilities until the operation reaches a terminal state.
type LRORetrysClientPut201CreatingSucceeded200Poller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LRORetrysClientPut201CreatingSucceeded200Poller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LRORetrysClientPut201CreatingSucceeded200Poller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LRORetrysClientPut201CreatingSucceeded200Poller) Result(ctx context.Context) (resp LRORetrysClientPut201CreatingSucceeded200Response, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LRORetrysClientPut201CreatingSucceeded200Poller) PollUntilDone(ctx context.Context, freq time.Duration) (LRORetrysClientPut201CreatingSucceeded200Response, error) {
	result := LRORetrysClientPut201CreatingSucceeded200Response{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Product)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LRORetrysClientPut201CreatingSucceeded200Poller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LRORetrysClientPut201CreatingSucceeded200Poller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LRORetrysClientPut201CreatingSucceeded200Poller) Resume(token string, client *LRORetrysClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LRORetrysClient.Put201CreatingSucceeded200", token, client.pl)
	return
}

// LRORetrysClientPutAsyncRelativeRetrySucceededPoller provides polling facilities until the operation reaches a terminal state.
type LRORetrysClientPutAsyncRelativeRetrySucceededPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LRORetrysClientPutAsyncRelativeRetrySucceededPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LRORetrysClientPutAsyncRelativeRetrySucceededPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LRORetrysClientPutAsyncRelativeRetrySucceededPoller) Result(ctx context.Context) (resp LRORetrysClientPutAsyncRelativeRetrySucceededResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LRORetrysClientPutAsyncRelativeRetrySucceededPoller) PollUntilDone(ctx context.Context, freq time.Duration) (LRORetrysClientPutAsyncRelativeRetrySucceededResponse, error) {
	result := LRORetrysClientPutAsyncRelativeRetrySucceededResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Product)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LRORetrysClientPutAsyncRelativeRetrySucceededPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LRORetrysClientPutAsyncRelativeRetrySucceededPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LRORetrysClientPutAsyncRelativeRetrySucceededPoller) Resume(token string, client *LRORetrysClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LRORetrysClient.PutAsyncRelativeRetrySucceeded", token, client.pl)
	return
}

// LROSADsClientDelete202NonRetry400Poller provides polling facilities until the operation reaches a terminal state.
type LROSADsClientDelete202NonRetry400Poller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROSADsClientDelete202NonRetry400Poller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROSADsClientDelete202NonRetry400Poller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROSADsClientDelete202NonRetry400Poller) Result(ctx context.Context) (resp LROSADsClientDelete202NonRetry400Response, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROSADsClientDelete202NonRetry400Poller) PollUntilDone(ctx context.Context, freq time.Duration) (LROSADsClientDelete202NonRetry400Response, error) {
	result := LROSADsClientDelete202NonRetry400Response{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROSADsClientDelete202NonRetry400Poller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROSADsClientDelete202NonRetry400Poller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROSADsClientDelete202NonRetry400Poller) Resume(token string, client *LROSADsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROSADsClient.Delete202NonRetry400", token, client.pl)
	return
}

// LROSADsClientDelete202RetryInvalidHeaderPoller provides polling facilities until the operation reaches a terminal state.
type LROSADsClientDelete202RetryInvalidHeaderPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROSADsClientDelete202RetryInvalidHeaderPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROSADsClientDelete202RetryInvalidHeaderPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROSADsClientDelete202RetryInvalidHeaderPoller) Result(ctx context.Context) (resp LROSADsClientDelete202RetryInvalidHeaderResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROSADsClientDelete202RetryInvalidHeaderPoller) PollUntilDone(ctx context.Context, freq time.Duration) (LROSADsClientDelete202RetryInvalidHeaderResponse, error) {
	result := LROSADsClientDelete202RetryInvalidHeaderResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROSADsClientDelete202RetryInvalidHeaderPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROSADsClientDelete202RetryInvalidHeaderPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROSADsClientDelete202RetryInvalidHeaderPoller) Resume(token string, client *LROSADsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROSADsClient.Delete202RetryInvalidHeader", token, client.pl)
	return
}

// LROSADsClientDelete204SucceededPoller provides polling facilities until the operation reaches a terminal state.
type LROSADsClientDelete204SucceededPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROSADsClientDelete204SucceededPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROSADsClientDelete204SucceededPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROSADsClientDelete204SucceededPoller) Result(ctx context.Context) (resp LROSADsClientDelete204SucceededResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROSADsClientDelete204SucceededPoller) PollUntilDone(ctx context.Context, freq time.Duration) (LROSADsClientDelete204SucceededResponse, error) {
	result := LROSADsClientDelete204SucceededResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROSADsClientDelete204SucceededPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROSADsClientDelete204SucceededPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROSADsClientDelete204SucceededPoller) Resume(token string, client *LROSADsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROSADsClient.Delete204Succeeded", token, client.pl)
	return
}

// LROSADsClientDeleteAsyncRelativeRetry400Poller provides polling facilities until the operation reaches a terminal state.
type LROSADsClientDeleteAsyncRelativeRetry400Poller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROSADsClientDeleteAsyncRelativeRetry400Poller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROSADsClientDeleteAsyncRelativeRetry400Poller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROSADsClientDeleteAsyncRelativeRetry400Poller) Result(ctx context.Context) (resp LROSADsClientDeleteAsyncRelativeRetry400Response, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROSADsClientDeleteAsyncRelativeRetry400Poller) PollUntilDone(ctx context.Context, freq time.Duration) (LROSADsClientDeleteAsyncRelativeRetry400Response, error) {
	result := LROSADsClientDeleteAsyncRelativeRetry400Response{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROSADsClientDeleteAsyncRelativeRetry400Poller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROSADsClientDeleteAsyncRelativeRetry400Poller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROSADsClientDeleteAsyncRelativeRetry400Poller) Resume(token string, client *LROSADsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROSADsClient.DeleteAsyncRelativeRetry400", token, client.pl)
	return
}

// LROSADsClientDeleteAsyncRelativeRetryInvalidHeaderPoller provides polling facilities until the operation reaches a terminal state.
type LROSADsClientDeleteAsyncRelativeRetryInvalidHeaderPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROSADsClientDeleteAsyncRelativeRetryInvalidHeaderPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROSADsClientDeleteAsyncRelativeRetryInvalidHeaderPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROSADsClientDeleteAsyncRelativeRetryInvalidHeaderPoller) Result(ctx context.Context) (resp LROSADsClientDeleteAsyncRelativeRetryInvalidHeaderResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROSADsClientDeleteAsyncRelativeRetryInvalidHeaderPoller) PollUntilDone(ctx context.Context, freq time.Duration) (LROSADsClientDeleteAsyncRelativeRetryInvalidHeaderResponse, error) {
	result := LROSADsClientDeleteAsyncRelativeRetryInvalidHeaderResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROSADsClientDeleteAsyncRelativeRetryInvalidHeaderPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROSADsClientDeleteAsyncRelativeRetryInvalidHeaderPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROSADsClientDeleteAsyncRelativeRetryInvalidHeaderPoller) Resume(token string, client *LROSADsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROSADsClient.DeleteAsyncRelativeRetryInvalidHeader", token, client.pl)
	return
}

// LROSADsClientDeleteAsyncRelativeRetryInvalidJSONPollingPoller provides polling facilities until the operation reaches a terminal state.
type LROSADsClientDeleteAsyncRelativeRetryInvalidJSONPollingPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROSADsClientDeleteAsyncRelativeRetryInvalidJSONPollingPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROSADsClientDeleteAsyncRelativeRetryInvalidJSONPollingPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROSADsClientDeleteAsyncRelativeRetryInvalidJSONPollingPoller) Result(ctx context.Context) (resp LROSADsClientDeleteAsyncRelativeRetryInvalidJSONPollingResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROSADsClientDeleteAsyncRelativeRetryInvalidJSONPollingPoller) PollUntilDone(ctx context.Context, freq time.Duration) (LROSADsClientDeleteAsyncRelativeRetryInvalidJSONPollingResponse, error) {
	result := LROSADsClientDeleteAsyncRelativeRetryInvalidJSONPollingResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROSADsClientDeleteAsyncRelativeRetryInvalidJSONPollingPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROSADsClientDeleteAsyncRelativeRetryInvalidJSONPollingPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROSADsClientDeleteAsyncRelativeRetryInvalidJSONPollingPoller) Resume(token string, client *LROSADsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROSADsClient.DeleteAsyncRelativeRetryInvalidJSONPolling", token, client.pl)
	return
}

// LROSADsClientDeleteAsyncRelativeRetryNoStatusPoller provides polling facilities until the operation reaches a terminal state.
type LROSADsClientDeleteAsyncRelativeRetryNoStatusPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROSADsClientDeleteAsyncRelativeRetryNoStatusPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROSADsClientDeleteAsyncRelativeRetryNoStatusPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROSADsClientDeleteAsyncRelativeRetryNoStatusPoller) Result(ctx context.Context) (resp LROSADsClientDeleteAsyncRelativeRetryNoStatusResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROSADsClientDeleteAsyncRelativeRetryNoStatusPoller) PollUntilDone(ctx context.Context, freq time.Duration) (LROSADsClientDeleteAsyncRelativeRetryNoStatusResponse, error) {
	result := LROSADsClientDeleteAsyncRelativeRetryNoStatusResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROSADsClientDeleteAsyncRelativeRetryNoStatusPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROSADsClientDeleteAsyncRelativeRetryNoStatusPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROSADsClientDeleteAsyncRelativeRetryNoStatusPoller) Resume(token string, client *LROSADsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROSADsClient.DeleteAsyncRelativeRetryNoStatus", token, client.pl)
	return
}

// LROSADsClientDeleteNonRetry400Poller provides polling facilities until the operation reaches a terminal state.
type LROSADsClientDeleteNonRetry400Poller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROSADsClientDeleteNonRetry400Poller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROSADsClientDeleteNonRetry400Poller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROSADsClientDeleteNonRetry400Poller) Result(ctx context.Context) (resp LROSADsClientDeleteNonRetry400Response, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROSADsClientDeleteNonRetry400Poller) PollUntilDone(ctx context.Context, freq time.Duration) (LROSADsClientDeleteNonRetry400Response, error) {
	result := LROSADsClientDeleteNonRetry400Response{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROSADsClientDeleteNonRetry400Poller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROSADsClientDeleteNonRetry400Poller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROSADsClientDeleteNonRetry400Poller) Resume(token string, client *LROSADsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROSADsClient.DeleteNonRetry400", token, client.pl)
	return
}

// LROSADsClientPost202NoLocationPoller provides polling facilities until the operation reaches a terminal state.
type LROSADsClientPost202NoLocationPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROSADsClientPost202NoLocationPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROSADsClientPost202NoLocationPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROSADsClientPost202NoLocationPoller) Result(ctx context.Context) (resp LROSADsClientPost202NoLocationResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROSADsClientPost202NoLocationPoller) PollUntilDone(ctx context.Context, freq time.Duration) (LROSADsClientPost202NoLocationResponse, error) {
	result := LROSADsClientPost202NoLocationResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROSADsClientPost202NoLocationPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROSADsClientPost202NoLocationPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROSADsClientPost202NoLocationPoller) Resume(token string, client *LROSADsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROSADsClient.Post202NoLocation", token, client.pl)
	return
}

// LROSADsClientPost202NonRetry400Poller provides polling facilities until the operation reaches a terminal state.
type LROSADsClientPost202NonRetry400Poller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROSADsClientPost202NonRetry400Poller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROSADsClientPost202NonRetry400Poller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROSADsClientPost202NonRetry400Poller) Result(ctx context.Context) (resp LROSADsClientPost202NonRetry400Response, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROSADsClientPost202NonRetry400Poller) PollUntilDone(ctx context.Context, freq time.Duration) (LROSADsClientPost202NonRetry400Response, error) {
	result := LROSADsClientPost202NonRetry400Response{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROSADsClientPost202NonRetry400Poller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROSADsClientPost202NonRetry400Poller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROSADsClientPost202NonRetry400Poller) Resume(token string, client *LROSADsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROSADsClient.Post202NonRetry400", token, client.pl)
	return
}

// LROSADsClientPost202RetryInvalidHeaderPoller provides polling facilities until the operation reaches a terminal state.
type LROSADsClientPost202RetryInvalidHeaderPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROSADsClientPost202RetryInvalidHeaderPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROSADsClientPost202RetryInvalidHeaderPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROSADsClientPost202RetryInvalidHeaderPoller) Result(ctx context.Context) (resp LROSADsClientPost202RetryInvalidHeaderResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROSADsClientPost202RetryInvalidHeaderPoller) PollUntilDone(ctx context.Context, freq time.Duration) (LROSADsClientPost202RetryInvalidHeaderResponse, error) {
	result := LROSADsClientPost202RetryInvalidHeaderResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROSADsClientPost202RetryInvalidHeaderPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROSADsClientPost202RetryInvalidHeaderPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROSADsClientPost202RetryInvalidHeaderPoller) Resume(token string, client *LROSADsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROSADsClient.Post202RetryInvalidHeader", token, client.pl)
	return
}

// LROSADsClientPostAsyncRelativeRetry400Poller provides polling facilities until the operation reaches a terminal state.
type LROSADsClientPostAsyncRelativeRetry400Poller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROSADsClientPostAsyncRelativeRetry400Poller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROSADsClientPostAsyncRelativeRetry400Poller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROSADsClientPostAsyncRelativeRetry400Poller) Result(ctx context.Context) (resp LROSADsClientPostAsyncRelativeRetry400Response, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROSADsClientPostAsyncRelativeRetry400Poller) PollUntilDone(ctx context.Context, freq time.Duration) (LROSADsClientPostAsyncRelativeRetry400Response, error) {
	result := LROSADsClientPostAsyncRelativeRetry400Response{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROSADsClientPostAsyncRelativeRetry400Poller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROSADsClientPostAsyncRelativeRetry400Poller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROSADsClientPostAsyncRelativeRetry400Poller) Resume(token string, client *LROSADsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROSADsClient.PostAsyncRelativeRetry400", token, client.pl)
	return
}

// LROSADsClientPostAsyncRelativeRetryInvalidHeaderPoller provides polling facilities until the operation reaches a terminal state.
type LROSADsClientPostAsyncRelativeRetryInvalidHeaderPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROSADsClientPostAsyncRelativeRetryInvalidHeaderPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROSADsClientPostAsyncRelativeRetryInvalidHeaderPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROSADsClientPostAsyncRelativeRetryInvalidHeaderPoller) Result(ctx context.Context) (resp LROSADsClientPostAsyncRelativeRetryInvalidHeaderResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROSADsClientPostAsyncRelativeRetryInvalidHeaderPoller) PollUntilDone(ctx context.Context, freq time.Duration) (LROSADsClientPostAsyncRelativeRetryInvalidHeaderResponse, error) {
	result := LROSADsClientPostAsyncRelativeRetryInvalidHeaderResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROSADsClientPostAsyncRelativeRetryInvalidHeaderPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROSADsClientPostAsyncRelativeRetryInvalidHeaderPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROSADsClientPostAsyncRelativeRetryInvalidHeaderPoller) Resume(token string, client *LROSADsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROSADsClient.PostAsyncRelativeRetryInvalidHeader", token, client.pl)
	return
}

// LROSADsClientPostAsyncRelativeRetryInvalidJSONPollingPoller provides polling facilities until the operation reaches a terminal state.
type LROSADsClientPostAsyncRelativeRetryInvalidJSONPollingPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROSADsClientPostAsyncRelativeRetryInvalidJSONPollingPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROSADsClientPostAsyncRelativeRetryInvalidJSONPollingPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROSADsClientPostAsyncRelativeRetryInvalidJSONPollingPoller) Result(ctx context.Context) (resp LROSADsClientPostAsyncRelativeRetryInvalidJSONPollingResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROSADsClientPostAsyncRelativeRetryInvalidJSONPollingPoller) PollUntilDone(ctx context.Context, freq time.Duration) (LROSADsClientPostAsyncRelativeRetryInvalidJSONPollingResponse, error) {
	result := LROSADsClientPostAsyncRelativeRetryInvalidJSONPollingResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROSADsClientPostAsyncRelativeRetryInvalidJSONPollingPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROSADsClientPostAsyncRelativeRetryInvalidJSONPollingPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROSADsClientPostAsyncRelativeRetryInvalidJSONPollingPoller) Resume(token string, client *LROSADsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROSADsClient.PostAsyncRelativeRetryInvalidJSONPolling", token, client.pl)
	return
}

// LROSADsClientPostAsyncRelativeRetryNoPayloadPoller provides polling facilities until the operation reaches a terminal state.
type LROSADsClientPostAsyncRelativeRetryNoPayloadPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROSADsClientPostAsyncRelativeRetryNoPayloadPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROSADsClientPostAsyncRelativeRetryNoPayloadPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROSADsClientPostAsyncRelativeRetryNoPayloadPoller) Result(ctx context.Context) (resp LROSADsClientPostAsyncRelativeRetryNoPayloadResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROSADsClientPostAsyncRelativeRetryNoPayloadPoller) PollUntilDone(ctx context.Context, freq time.Duration) (LROSADsClientPostAsyncRelativeRetryNoPayloadResponse, error) {
	result := LROSADsClientPostAsyncRelativeRetryNoPayloadResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROSADsClientPostAsyncRelativeRetryNoPayloadPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROSADsClientPostAsyncRelativeRetryNoPayloadPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROSADsClientPostAsyncRelativeRetryNoPayloadPoller) Resume(token string, client *LROSADsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROSADsClient.PostAsyncRelativeRetryNoPayload", token, client.pl)
	return
}

// LROSADsClientPostNonRetry400Poller provides polling facilities until the operation reaches a terminal state.
type LROSADsClientPostNonRetry400Poller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROSADsClientPostNonRetry400Poller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROSADsClientPostNonRetry400Poller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROSADsClientPostNonRetry400Poller) Result(ctx context.Context) (resp LROSADsClientPostNonRetry400Response, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROSADsClientPostNonRetry400Poller) PollUntilDone(ctx context.Context, freq time.Duration) (LROSADsClientPostNonRetry400Response, error) {
	result := LROSADsClientPostNonRetry400Response{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROSADsClientPostNonRetry400Poller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROSADsClientPostNonRetry400Poller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROSADsClientPostNonRetry400Poller) Resume(token string, client *LROSADsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROSADsClient.PostNonRetry400", token, client.pl)
	return
}

// LROSADsClientPut200InvalidJSONPoller provides polling facilities until the operation reaches a terminal state.
type LROSADsClientPut200InvalidJSONPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROSADsClientPut200InvalidJSONPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROSADsClientPut200InvalidJSONPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROSADsClientPut200InvalidJSONPoller) Result(ctx context.Context) (resp LROSADsClientPut200InvalidJSONResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROSADsClientPut200InvalidJSONPoller) PollUntilDone(ctx context.Context, freq time.Duration) (LROSADsClientPut200InvalidJSONResponse, error) {
	result := LROSADsClientPut200InvalidJSONResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Product)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROSADsClientPut200InvalidJSONPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROSADsClientPut200InvalidJSONPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROSADsClientPut200InvalidJSONPoller) Resume(token string, client *LROSADsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROSADsClient.Put200InvalidJSON", token, client.pl)
	return
}

// LROSADsClientPutAsyncRelativeRetry400Poller provides polling facilities until the operation reaches a terminal state.
type LROSADsClientPutAsyncRelativeRetry400Poller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROSADsClientPutAsyncRelativeRetry400Poller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROSADsClientPutAsyncRelativeRetry400Poller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROSADsClientPutAsyncRelativeRetry400Poller) Result(ctx context.Context) (resp LROSADsClientPutAsyncRelativeRetry400Response, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROSADsClientPutAsyncRelativeRetry400Poller) PollUntilDone(ctx context.Context, freq time.Duration) (LROSADsClientPutAsyncRelativeRetry400Response, error) {
	result := LROSADsClientPutAsyncRelativeRetry400Response{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Product)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROSADsClientPutAsyncRelativeRetry400Poller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROSADsClientPutAsyncRelativeRetry400Poller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROSADsClientPutAsyncRelativeRetry400Poller) Resume(token string, client *LROSADsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROSADsClient.PutAsyncRelativeRetry400", token, client.pl)
	return
}

// LROSADsClientPutAsyncRelativeRetryInvalidHeaderPoller provides polling facilities until the operation reaches a terminal state.
type LROSADsClientPutAsyncRelativeRetryInvalidHeaderPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROSADsClientPutAsyncRelativeRetryInvalidHeaderPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROSADsClientPutAsyncRelativeRetryInvalidHeaderPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROSADsClientPutAsyncRelativeRetryInvalidHeaderPoller) Result(ctx context.Context) (resp LROSADsClientPutAsyncRelativeRetryInvalidHeaderResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROSADsClientPutAsyncRelativeRetryInvalidHeaderPoller) PollUntilDone(ctx context.Context, freq time.Duration) (LROSADsClientPutAsyncRelativeRetryInvalidHeaderResponse, error) {
	result := LROSADsClientPutAsyncRelativeRetryInvalidHeaderResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Product)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROSADsClientPutAsyncRelativeRetryInvalidHeaderPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROSADsClientPutAsyncRelativeRetryInvalidHeaderPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROSADsClientPutAsyncRelativeRetryInvalidHeaderPoller) Resume(token string, client *LROSADsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROSADsClient.PutAsyncRelativeRetryInvalidHeader", token, client.pl)
	return
}

// LROSADsClientPutAsyncRelativeRetryInvalidJSONPollingPoller provides polling facilities until the operation reaches a terminal state.
type LROSADsClientPutAsyncRelativeRetryInvalidJSONPollingPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROSADsClientPutAsyncRelativeRetryInvalidJSONPollingPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROSADsClientPutAsyncRelativeRetryInvalidJSONPollingPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROSADsClientPutAsyncRelativeRetryInvalidJSONPollingPoller) Result(ctx context.Context) (resp LROSADsClientPutAsyncRelativeRetryInvalidJSONPollingResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROSADsClientPutAsyncRelativeRetryInvalidJSONPollingPoller) PollUntilDone(ctx context.Context, freq time.Duration) (LROSADsClientPutAsyncRelativeRetryInvalidJSONPollingResponse, error) {
	result := LROSADsClientPutAsyncRelativeRetryInvalidJSONPollingResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Product)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROSADsClientPutAsyncRelativeRetryInvalidJSONPollingPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROSADsClientPutAsyncRelativeRetryInvalidJSONPollingPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROSADsClientPutAsyncRelativeRetryInvalidJSONPollingPoller) Resume(token string, client *LROSADsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROSADsClient.PutAsyncRelativeRetryInvalidJSONPolling", token, client.pl)
	return
}

// LROSADsClientPutAsyncRelativeRetryNoStatusPayloadPoller provides polling facilities until the operation reaches a terminal state.
type LROSADsClientPutAsyncRelativeRetryNoStatusPayloadPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROSADsClientPutAsyncRelativeRetryNoStatusPayloadPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROSADsClientPutAsyncRelativeRetryNoStatusPayloadPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROSADsClientPutAsyncRelativeRetryNoStatusPayloadPoller) Result(ctx context.Context) (resp LROSADsClientPutAsyncRelativeRetryNoStatusPayloadResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROSADsClientPutAsyncRelativeRetryNoStatusPayloadPoller) PollUntilDone(ctx context.Context, freq time.Duration) (LROSADsClientPutAsyncRelativeRetryNoStatusPayloadResponse, error) {
	result := LROSADsClientPutAsyncRelativeRetryNoStatusPayloadResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Product)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROSADsClientPutAsyncRelativeRetryNoStatusPayloadPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROSADsClientPutAsyncRelativeRetryNoStatusPayloadPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROSADsClientPutAsyncRelativeRetryNoStatusPayloadPoller) Resume(token string, client *LROSADsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROSADsClient.PutAsyncRelativeRetryNoStatusPayload", token, client.pl)
	return
}

// LROSADsClientPutAsyncRelativeRetryNoStatusPoller provides polling facilities until the operation reaches a terminal state.
type LROSADsClientPutAsyncRelativeRetryNoStatusPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROSADsClientPutAsyncRelativeRetryNoStatusPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROSADsClientPutAsyncRelativeRetryNoStatusPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROSADsClientPutAsyncRelativeRetryNoStatusPoller) Result(ctx context.Context) (resp LROSADsClientPutAsyncRelativeRetryNoStatusResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROSADsClientPutAsyncRelativeRetryNoStatusPoller) PollUntilDone(ctx context.Context, freq time.Duration) (LROSADsClientPutAsyncRelativeRetryNoStatusResponse, error) {
	result := LROSADsClientPutAsyncRelativeRetryNoStatusResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Product)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROSADsClientPutAsyncRelativeRetryNoStatusPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROSADsClientPutAsyncRelativeRetryNoStatusPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROSADsClientPutAsyncRelativeRetryNoStatusPoller) Resume(token string, client *LROSADsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROSADsClient.PutAsyncRelativeRetryNoStatus", token, client.pl)
	return
}

// LROSADsClientPutError201NoProvisioningStatePayloadPoller provides polling facilities until the operation reaches a terminal state.
type LROSADsClientPutError201NoProvisioningStatePayloadPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROSADsClientPutError201NoProvisioningStatePayloadPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROSADsClientPutError201NoProvisioningStatePayloadPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROSADsClientPutError201NoProvisioningStatePayloadPoller) Result(ctx context.Context) (resp LROSADsClientPutError201NoProvisioningStatePayloadResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROSADsClientPutError201NoProvisioningStatePayloadPoller) PollUntilDone(ctx context.Context, freq time.Duration) (LROSADsClientPutError201NoProvisioningStatePayloadResponse, error) {
	result := LROSADsClientPutError201NoProvisioningStatePayloadResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Product)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROSADsClientPutError201NoProvisioningStatePayloadPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROSADsClientPutError201NoProvisioningStatePayloadPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROSADsClientPutError201NoProvisioningStatePayloadPoller) Resume(token string, client *LROSADsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROSADsClient.PutError201NoProvisioningStatePayload", token, client.pl)
	return
}

// LROSADsClientPutNonRetry201Creating400InvalidJSONPoller provides polling facilities until the operation reaches a terminal state.
type LROSADsClientPutNonRetry201Creating400InvalidJSONPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROSADsClientPutNonRetry201Creating400InvalidJSONPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROSADsClientPutNonRetry201Creating400InvalidJSONPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROSADsClientPutNonRetry201Creating400InvalidJSONPoller) Result(ctx context.Context) (resp LROSADsClientPutNonRetry201Creating400InvalidJSONResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROSADsClientPutNonRetry201Creating400InvalidJSONPoller) PollUntilDone(ctx context.Context, freq time.Duration) (LROSADsClientPutNonRetry201Creating400InvalidJSONResponse, error) {
	result := LROSADsClientPutNonRetry201Creating400InvalidJSONResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Product)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROSADsClientPutNonRetry201Creating400InvalidJSONPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROSADsClientPutNonRetry201Creating400InvalidJSONPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROSADsClientPutNonRetry201Creating400InvalidJSONPoller) Resume(token string, client *LROSADsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROSADsClient.PutNonRetry201Creating400InvalidJSON", token, client.pl)
	return
}

// LROSADsClientPutNonRetry201Creating400Poller provides polling facilities until the operation reaches a terminal state.
type LROSADsClientPutNonRetry201Creating400Poller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROSADsClientPutNonRetry201Creating400Poller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROSADsClientPutNonRetry201Creating400Poller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROSADsClientPutNonRetry201Creating400Poller) Result(ctx context.Context) (resp LROSADsClientPutNonRetry201Creating400Response, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROSADsClientPutNonRetry201Creating400Poller) PollUntilDone(ctx context.Context, freq time.Duration) (LROSADsClientPutNonRetry201Creating400Response, error) {
	result := LROSADsClientPutNonRetry201Creating400Response{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Product)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROSADsClientPutNonRetry201Creating400Poller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROSADsClientPutNonRetry201Creating400Poller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROSADsClientPutNonRetry201Creating400Poller) Resume(token string, client *LROSADsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROSADsClient.PutNonRetry201Creating400", token, client.pl)
	return
}

// LROSADsClientPutNonRetry400Poller provides polling facilities until the operation reaches a terminal state.
type LROSADsClientPutNonRetry400Poller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROSADsClientPutNonRetry400Poller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROSADsClientPutNonRetry400Poller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROSADsClientPutNonRetry400Poller) Result(ctx context.Context) (resp LROSADsClientPutNonRetry400Response, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROSADsClientPutNonRetry400Poller) PollUntilDone(ctx context.Context, freq time.Duration) (LROSADsClientPutNonRetry400Response, error) {
	result := LROSADsClientPutNonRetry400Response{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Product)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROSADsClientPutNonRetry400Poller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROSADsClientPutNonRetry400Poller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROSADsClientPutNonRetry400Poller) Resume(token string, client *LROSADsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROSADsClient.PutNonRetry400", token, client.pl)
	return
}

// LROsClientDelete202NoRetry204Poller provides polling facilities until the operation reaches a terminal state.
type LROsClientDelete202NoRetry204Poller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsClientDelete202NoRetry204Poller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROsClientDelete202NoRetry204Poller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROsClientDelete202NoRetry204Poller) Result(ctx context.Context) (resp LROsClientDelete202NoRetry204Response, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROsClientDelete202NoRetry204Poller) PollUntilDone(ctx context.Context, freq time.Duration) (LROsClientDelete202NoRetry204Response, error) {
	result := LROsClientDelete202NoRetry204Response{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Product)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROsClientDelete202NoRetry204Poller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROsClientDelete202NoRetry204Poller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROsClientDelete202NoRetry204Poller) Resume(token string, client *LROsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROsClient.Delete202NoRetry204", token, client.pl)
	return
}

// LROsClientDelete202Retry200Poller provides polling facilities until the operation reaches a terminal state.
type LROsClientDelete202Retry200Poller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsClientDelete202Retry200Poller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROsClientDelete202Retry200Poller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROsClientDelete202Retry200Poller) Result(ctx context.Context) (resp LROsClientDelete202Retry200Response, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROsClientDelete202Retry200Poller) PollUntilDone(ctx context.Context, freq time.Duration) (LROsClientDelete202Retry200Response, error) {
	result := LROsClientDelete202Retry200Response{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Product)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROsClientDelete202Retry200Poller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROsClientDelete202Retry200Poller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROsClientDelete202Retry200Poller) Resume(token string, client *LROsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROsClient.Delete202Retry200", token, client.pl)
	return
}

// LROsClientDelete204SucceededPoller provides polling facilities until the operation reaches a terminal state.
type LROsClientDelete204SucceededPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsClientDelete204SucceededPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROsClientDelete204SucceededPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROsClientDelete204SucceededPoller) Result(ctx context.Context) (resp LROsClientDelete204SucceededResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROsClientDelete204SucceededPoller) PollUntilDone(ctx context.Context, freq time.Duration) (LROsClientDelete204SucceededResponse, error) {
	result := LROsClientDelete204SucceededResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROsClientDelete204SucceededPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROsClientDelete204SucceededPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROsClientDelete204SucceededPoller) Resume(token string, client *LROsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROsClient.Delete204Succeeded", token, client.pl)
	return
}

// LROsClientDeleteAsyncNoHeaderInRetryPoller provides polling facilities until the operation reaches a terminal state.
type LROsClientDeleteAsyncNoHeaderInRetryPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsClientDeleteAsyncNoHeaderInRetryPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROsClientDeleteAsyncNoHeaderInRetryPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROsClientDeleteAsyncNoHeaderInRetryPoller) Result(ctx context.Context) (resp LROsClientDeleteAsyncNoHeaderInRetryResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROsClientDeleteAsyncNoHeaderInRetryPoller) PollUntilDone(ctx context.Context, freq time.Duration) (LROsClientDeleteAsyncNoHeaderInRetryResponse, error) {
	result := LROsClientDeleteAsyncNoHeaderInRetryResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROsClientDeleteAsyncNoHeaderInRetryPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROsClientDeleteAsyncNoHeaderInRetryPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROsClientDeleteAsyncNoHeaderInRetryPoller) Resume(token string, client *LROsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROsClient.DeleteAsyncNoHeaderInRetry", token, client.pl)
	return
}

// LROsClientDeleteAsyncNoRetrySucceededPoller provides polling facilities until the operation reaches a terminal state.
type LROsClientDeleteAsyncNoRetrySucceededPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsClientDeleteAsyncNoRetrySucceededPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROsClientDeleteAsyncNoRetrySucceededPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROsClientDeleteAsyncNoRetrySucceededPoller) Result(ctx context.Context) (resp LROsClientDeleteAsyncNoRetrySucceededResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROsClientDeleteAsyncNoRetrySucceededPoller) PollUntilDone(ctx context.Context, freq time.Duration) (LROsClientDeleteAsyncNoRetrySucceededResponse, error) {
	result := LROsClientDeleteAsyncNoRetrySucceededResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROsClientDeleteAsyncNoRetrySucceededPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROsClientDeleteAsyncNoRetrySucceededPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROsClientDeleteAsyncNoRetrySucceededPoller) Resume(token string, client *LROsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROsClient.DeleteAsyncNoRetrySucceeded", token, client.pl)
	return
}

// LROsClientDeleteAsyncRetryFailedPoller provides polling facilities until the operation reaches a terminal state.
type LROsClientDeleteAsyncRetryFailedPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsClientDeleteAsyncRetryFailedPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROsClientDeleteAsyncRetryFailedPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROsClientDeleteAsyncRetryFailedPoller) Result(ctx context.Context) (resp LROsClientDeleteAsyncRetryFailedResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROsClientDeleteAsyncRetryFailedPoller) PollUntilDone(ctx context.Context, freq time.Duration) (LROsClientDeleteAsyncRetryFailedResponse, error) {
	result := LROsClientDeleteAsyncRetryFailedResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROsClientDeleteAsyncRetryFailedPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROsClientDeleteAsyncRetryFailedPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROsClientDeleteAsyncRetryFailedPoller) Resume(token string, client *LROsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROsClient.DeleteAsyncRetryFailed", token, client.pl)
	return
}

// LROsClientDeleteAsyncRetrySucceededPoller provides polling facilities until the operation reaches a terminal state.
type LROsClientDeleteAsyncRetrySucceededPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsClientDeleteAsyncRetrySucceededPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROsClientDeleteAsyncRetrySucceededPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROsClientDeleteAsyncRetrySucceededPoller) Result(ctx context.Context) (resp LROsClientDeleteAsyncRetrySucceededResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROsClientDeleteAsyncRetrySucceededPoller) PollUntilDone(ctx context.Context, freq time.Duration) (LROsClientDeleteAsyncRetrySucceededResponse, error) {
	result := LROsClientDeleteAsyncRetrySucceededResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROsClientDeleteAsyncRetrySucceededPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROsClientDeleteAsyncRetrySucceededPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROsClientDeleteAsyncRetrySucceededPoller) Resume(token string, client *LROsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROsClient.DeleteAsyncRetrySucceeded", token, client.pl)
	return
}

// LROsClientDeleteAsyncRetrycanceledPoller provides polling facilities until the operation reaches a terminal state.
type LROsClientDeleteAsyncRetrycanceledPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsClientDeleteAsyncRetrycanceledPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROsClientDeleteAsyncRetrycanceledPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROsClientDeleteAsyncRetrycanceledPoller) Result(ctx context.Context) (resp LROsClientDeleteAsyncRetrycanceledResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROsClientDeleteAsyncRetrycanceledPoller) PollUntilDone(ctx context.Context, freq time.Duration) (LROsClientDeleteAsyncRetrycanceledResponse, error) {
	result := LROsClientDeleteAsyncRetrycanceledResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROsClientDeleteAsyncRetrycanceledPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROsClientDeleteAsyncRetrycanceledPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROsClientDeleteAsyncRetrycanceledPoller) Resume(token string, client *LROsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROsClient.DeleteAsyncRetrycanceled", token, client.pl)
	return
}

// LROsClientDeleteNoHeaderInRetryPoller provides polling facilities until the operation reaches a terminal state.
type LROsClientDeleteNoHeaderInRetryPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsClientDeleteNoHeaderInRetryPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROsClientDeleteNoHeaderInRetryPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROsClientDeleteNoHeaderInRetryPoller) Result(ctx context.Context) (resp LROsClientDeleteNoHeaderInRetryResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROsClientDeleteNoHeaderInRetryPoller) PollUntilDone(ctx context.Context, freq time.Duration) (LROsClientDeleteNoHeaderInRetryResponse, error) {
	result := LROsClientDeleteNoHeaderInRetryResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROsClientDeleteNoHeaderInRetryPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROsClientDeleteNoHeaderInRetryPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROsClientDeleteNoHeaderInRetryPoller) Resume(token string, client *LROsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROsClient.DeleteNoHeaderInRetry", token, client.pl)
	return
}

// LROsClientDeleteProvisioning202Accepted200SucceededPoller provides polling facilities until the operation reaches a terminal state.
type LROsClientDeleteProvisioning202Accepted200SucceededPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsClientDeleteProvisioning202Accepted200SucceededPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROsClientDeleteProvisioning202Accepted200SucceededPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROsClientDeleteProvisioning202Accepted200SucceededPoller) Result(ctx context.Context) (resp LROsClientDeleteProvisioning202Accepted200SucceededResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROsClientDeleteProvisioning202Accepted200SucceededPoller) PollUntilDone(ctx context.Context, freq time.Duration) (LROsClientDeleteProvisioning202Accepted200SucceededResponse, error) {
	result := LROsClientDeleteProvisioning202Accepted200SucceededResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Product)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROsClientDeleteProvisioning202Accepted200SucceededPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROsClientDeleteProvisioning202Accepted200SucceededPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROsClientDeleteProvisioning202Accepted200SucceededPoller) Resume(token string, client *LROsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROsClient.DeleteProvisioning202Accepted200Succeeded", token, client.pl)
	return
}

// LROsClientDeleteProvisioning202DeletingFailed200Poller provides polling facilities until the operation reaches a terminal state.
type LROsClientDeleteProvisioning202DeletingFailed200Poller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsClientDeleteProvisioning202DeletingFailed200Poller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROsClientDeleteProvisioning202DeletingFailed200Poller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROsClientDeleteProvisioning202DeletingFailed200Poller) Result(ctx context.Context) (resp LROsClientDeleteProvisioning202DeletingFailed200Response, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROsClientDeleteProvisioning202DeletingFailed200Poller) PollUntilDone(ctx context.Context, freq time.Duration) (LROsClientDeleteProvisioning202DeletingFailed200Response, error) {
	result := LROsClientDeleteProvisioning202DeletingFailed200Response{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Product)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROsClientDeleteProvisioning202DeletingFailed200Poller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROsClientDeleteProvisioning202DeletingFailed200Poller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROsClientDeleteProvisioning202DeletingFailed200Poller) Resume(token string, client *LROsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROsClient.DeleteProvisioning202DeletingFailed200", token, client.pl)
	return
}

// LROsClientDeleteProvisioning202Deletingcanceled200Poller provides polling facilities until the operation reaches a terminal state.
type LROsClientDeleteProvisioning202Deletingcanceled200Poller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsClientDeleteProvisioning202Deletingcanceled200Poller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROsClientDeleteProvisioning202Deletingcanceled200Poller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROsClientDeleteProvisioning202Deletingcanceled200Poller) Result(ctx context.Context) (resp LROsClientDeleteProvisioning202Deletingcanceled200Response, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROsClientDeleteProvisioning202Deletingcanceled200Poller) PollUntilDone(ctx context.Context, freq time.Duration) (LROsClientDeleteProvisioning202Deletingcanceled200Response, error) {
	result := LROsClientDeleteProvisioning202Deletingcanceled200Response{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Product)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROsClientDeleteProvisioning202Deletingcanceled200Poller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROsClientDeleteProvisioning202Deletingcanceled200Poller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROsClientDeleteProvisioning202Deletingcanceled200Poller) Resume(token string, client *LROsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROsClient.DeleteProvisioning202Deletingcanceled200", token, client.pl)
	return
}

// LROsClientPatch200SucceededIgnoreHeadersPoller provides polling facilities until the operation reaches a terminal state.
type LROsClientPatch200SucceededIgnoreHeadersPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsClientPatch200SucceededIgnoreHeadersPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROsClientPatch200SucceededIgnoreHeadersPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROsClientPatch200SucceededIgnoreHeadersPoller) Result(ctx context.Context) (resp LROsClientPatch200SucceededIgnoreHeadersResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROsClientPatch200SucceededIgnoreHeadersPoller) PollUntilDone(ctx context.Context, freq time.Duration) (LROsClientPatch200SucceededIgnoreHeadersResponse, error) {
	result := LROsClientPatch200SucceededIgnoreHeadersResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Product)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROsClientPatch200SucceededIgnoreHeadersPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROsClientPatch200SucceededIgnoreHeadersPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROsClientPatch200SucceededIgnoreHeadersPoller) Resume(token string, client *LROsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROsClient.Patch200SucceededIgnoreHeaders", token, client.pl)
	return
}

// LROsClientPatch201RetryWithAsyncHeaderPoller provides polling facilities until the operation reaches a terminal state.
type LROsClientPatch201RetryWithAsyncHeaderPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsClientPatch201RetryWithAsyncHeaderPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROsClientPatch201RetryWithAsyncHeaderPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROsClientPatch201RetryWithAsyncHeaderPoller) Result(ctx context.Context) (resp LROsClientPatch201RetryWithAsyncHeaderResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROsClientPatch201RetryWithAsyncHeaderPoller) PollUntilDone(ctx context.Context, freq time.Duration) (LROsClientPatch201RetryWithAsyncHeaderResponse, error) {
	result := LROsClientPatch201RetryWithAsyncHeaderResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Product)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROsClientPatch201RetryWithAsyncHeaderPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROsClientPatch201RetryWithAsyncHeaderPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROsClientPatch201RetryWithAsyncHeaderPoller) Resume(token string, client *LROsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROsClient.Patch201RetryWithAsyncHeader", token, client.pl)
	return
}

// LROsClientPatch202RetryWithAsyncAndLocationHeaderPoller provides polling facilities until the operation reaches a terminal state.
type LROsClientPatch202RetryWithAsyncAndLocationHeaderPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsClientPatch202RetryWithAsyncAndLocationHeaderPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROsClientPatch202RetryWithAsyncAndLocationHeaderPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROsClientPatch202RetryWithAsyncAndLocationHeaderPoller) Result(ctx context.Context) (resp LROsClientPatch202RetryWithAsyncAndLocationHeaderResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROsClientPatch202RetryWithAsyncAndLocationHeaderPoller) PollUntilDone(ctx context.Context, freq time.Duration) (LROsClientPatch202RetryWithAsyncAndLocationHeaderResponse, error) {
	result := LROsClientPatch202RetryWithAsyncAndLocationHeaderResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Product)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROsClientPatch202RetryWithAsyncAndLocationHeaderPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROsClientPatch202RetryWithAsyncAndLocationHeaderPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROsClientPatch202RetryWithAsyncAndLocationHeaderPoller) Resume(token string, client *LROsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROsClient.Patch202RetryWithAsyncAndLocationHeader", token, client.pl)
	return
}

// LROsClientPost200WithPayloadPoller provides polling facilities until the operation reaches a terminal state.
type LROsClientPost200WithPayloadPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsClientPost200WithPayloadPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROsClientPost200WithPayloadPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROsClientPost200WithPayloadPoller) Result(ctx context.Context) (resp LROsClientPost200WithPayloadResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROsClientPost200WithPayloadPoller) PollUntilDone(ctx context.Context, freq time.Duration) (LROsClientPost200WithPayloadResponse, error) {
	result := LROsClientPost200WithPayloadResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.SKU)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROsClientPost200WithPayloadPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROsClientPost200WithPayloadPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROsClientPost200WithPayloadPoller) Resume(token string, client *LROsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROsClient.Post200WithPayload", token, client.pl)
	return
}

// LROsClientPost202ListPoller provides polling facilities until the operation reaches a terminal state.
type LROsClientPost202ListPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsClientPost202ListPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROsClientPost202ListPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROsClientPost202ListPoller) Result(ctx context.Context) (resp LROsClientPost202ListResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROsClientPost202ListPoller) PollUntilDone(ctx context.Context, freq time.Duration) (LROsClientPost202ListResponse, error) {
	result := LROsClientPost202ListResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.ProductArray)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROsClientPost202ListPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROsClientPost202ListPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROsClientPost202ListPoller) Resume(token string, client *LROsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROsClient.Post202List", token, client.pl)
	return
}

// LROsClientPost202NoRetry204Poller provides polling facilities until the operation reaches a terminal state.
type LROsClientPost202NoRetry204Poller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsClientPost202NoRetry204Poller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROsClientPost202NoRetry204Poller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROsClientPost202NoRetry204Poller) Result(ctx context.Context) (resp LROsClientPost202NoRetry204Response, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROsClientPost202NoRetry204Poller) PollUntilDone(ctx context.Context, freq time.Duration) (LROsClientPost202NoRetry204Response, error) {
	result := LROsClientPost202NoRetry204Response{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Product)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROsClientPost202NoRetry204Poller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROsClientPost202NoRetry204Poller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROsClientPost202NoRetry204Poller) Resume(token string, client *LROsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROsClient.Post202NoRetry204", token, client.pl)
	return
}

// LROsClientPost202Retry200Poller provides polling facilities until the operation reaches a terminal state.
type LROsClientPost202Retry200Poller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsClientPost202Retry200Poller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROsClientPost202Retry200Poller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROsClientPost202Retry200Poller) Result(ctx context.Context) (resp LROsClientPost202Retry200Response, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROsClientPost202Retry200Poller) PollUntilDone(ctx context.Context, freq time.Duration) (LROsClientPost202Retry200Response, error) {
	result := LROsClientPost202Retry200Response{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROsClientPost202Retry200Poller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROsClientPost202Retry200Poller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROsClientPost202Retry200Poller) Resume(token string, client *LROsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROsClient.Post202Retry200", token, client.pl)
	return
}

// LROsClientPostAsyncNoRetrySucceededPoller provides polling facilities until the operation reaches a terminal state.
type LROsClientPostAsyncNoRetrySucceededPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsClientPostAsyncNoRetrySucceededPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROsClientPostAsyncNoRetrySucceededPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROsClientPostAsyncNoRetrySucceededPoller) Result(ctx context.Context) (resp LROsClientPostAsyncNoRetrySucceededResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROsClientPostAsyncNoRetrySucceededPoller) PollUntilDone(ctx context.Context, freq time.Duration) (LROsClientPostAsyncNoRetrySucceededResponse, error) {
	result := LROsClientPostAsyncNoRetrySucceededResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Product)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROsClientPostAsyncNoRetrySucceededPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROsClientPostAsyncNoRetrySucceededPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROsClientPostAsyncNoRetrySucceededPoller) Resume(token string, client *LROsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROsClient.PostAsyncNoRetrySucceeded", token, client.pl)
	return
}

// LROsClientPostAsyncRetryFailedPoller provides polling facilities until the operation reaches a terminal state.
type LROsClientPostAsyncRetryFailedPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsClientPostAsyncRetryFailedPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROsClientPostAsyncRetryFailedPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROsClientPostAsyncRetryFailedPoller) Result(ctx context.Context) (resp LROsClientPostAsyncRetryFailedResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROsClientPostAsyncRetryFailedPoller) PollUntilDone(ctx context.Context, freq time.Duration) (LROsClientPostAsyncRetryFailedResponse, error) {
	result := LROsClientPostAsyncRetryFailedResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROsClientPostAsyncRetryFailedPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROsClientPostAsyncRetryFailedPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROsClientPostAsyncRetryFailedPoller) Resume(token string, client *LROsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROsClient.PostAsyncRetryFailed", token, client.pl)
	return
}

// LROsClientPostAsyncRetrySucceededPoller provides polling facilities until the operation reaches a terminal state.
type LROsClientPostAsyncRetrySucceededPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsClientPostAsyncRetrySucceededPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROsClientPostAsyncRetrySucceededPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROsClientPostAsyncRetrySucceededPoller) Result(ctx context.Context) (resp LROsClientPostAsyncRetrySucceededResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROsClientPostAsyncRetrySucceededPoller) PollUntilDone(ctx context.Context, freq time.Duration) (LROsClientPostAsyncRetrySucceededResponse, error) {
	result := LROsClientPostAsyncRetrySucceededResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Product)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROsClientPostAsyncRetrySucceededPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROsClientPostAsyncRetrySucceededPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROsClientPostAsyncRetrySucceededPoller) Resume(token string, client *LROsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROsClient.PostAsyncRetrySucceeded", token, client.pl)
	return
}

// LROsClientPostAsyncRetrycanceledPoller provides polling facilities until the operation reaches a terminal state.
type LROsClientPostAsyncRetrycanceledPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsClientPostAsyncRetrycanceledPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROsClientPostAsyncRetrycanceledPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROsClientPostAsyncRetrycanceledPoller) Result(ctx context.Context) (resp LROsClientPostAsyncRetrycanceledResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROsClientPostAsyncRetrycanceledPoller) PollUntilDone(ctx context.Context, freq time.Duration) (LROsClientPostAsyncRetrycanceledResponse, error) {
	result := LROsClientPostAsyncRetrycanceledResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROsClientPostAsyncRetrycanceledPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROsClientPostAsyncRetrycanceledPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROsClientPostAsyncRetrycanceledPoller) Resume(token string, client *LROsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROsClient.PostAsyncRetrycanceled", token, client.pl)
	return
}

// LROsClientPostDoubleHeadersFinalAzureHeaderGetDefaultPoller provides polling facilities until the operation reaches a terminal state.
type LROsClientPostDoubleHeadersFinalAzureHeaderGetDefaultPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsClientPostDoubleHeadersFinalAzureHeaderGetDefaultPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROsClientPostDoubleHeadersFinalAzureHeaderGetDefaultPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROsClientPostDoubleHeadersFinalAzureHeaderGetDefaultPoller) Result(ctx context.Context) (resp LROsClientPostDoubleHeadersFinalAzureHeaderGetDefaultResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROsClientPostDoubleHeadersFinalAzureHeaderGetDefaultPoller) PollUntilDone(ctx context.Context, freq time.Duration) (LROsClientPostDoubleHeadersFinalAzureHeaderGetDefaultResponse, error) {
	result := LROsClientPostDoubleHeadersFinalAzureHeaderGetDefaultResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Product)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROsClientPostDoubleHeadersFinalAzureHeaderGetDefaultPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROsClientPostDoubleHeadersFinalAzureHeaderGetDefaultPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROsClientPostDoubleHeadersFinalAzureHeaderGetDefaultPoller) Resume(token string, client *LROsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROsClient.PostDoubleHeadersFinalAzureHeaderGetDefault", token, client.pl)
	return
}

// LROsClientPostDoubleHeadersFinalAzureHeaderGetPoller provides polling facilities until the operation reaches a terminal state.
type LROsClientPostDoubleHeadersFinalAzureHeaderGetPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsClientPostDoubleHeadersFinalAzureHeaderGetPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROsClientPostDoubleHeadersFinalAzureHeaderGetPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROsClientPostDoubleHeadersFinalAzureHeaderGetPoller) Result(ctx context.Context) (resp LROsClientPostDoubleHeadersFinalAzureHeaderGetResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROsClientPostDoubleHeadersFinalAzureHeaderGetPoller) PollUntilDone(ctx context.Context, freq time.Duration) (LROsClientPostDoubleHeadersFinalAzureHeaderGetResponse, error) {
	result := LROsClientPostDoubleHeadersFinalAzureHeaderGetResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Product)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROsClientPostDoubleHeadersFinalAzureHeaderGetPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROsClientPostDoubleHeadersFinalAzureHeaderGetPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROsClientPostDoubleHeadersFinalAzureHeaderGetPoller) Resume(token string, client *LROsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROsClient.PostDoubleHeadersFinalAzureHeaderGet", token, client.pl)
	return
}

// LROsClientPostDoubleHeadersFinalLocationGetPoller provides polling facilities until the operation reaches a terminal state.
type LROsClientPostDoubleHeadersFinalLocationGetPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsClientPostDoubleHeadersFinalLocationGetPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROsClientPostDoubleHeadersFinalLocationGetPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROsClientPostDoubleHeadersFinalLocationGetPoller) Result(ctx context.Context) (resp LROsClientPostDoubleHeadersFinalLocationGetResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROsClientPostDoubleHeadersFinalLocationGetPoller) PollUntilDone(ctx context.Context, freq time.Duration) (LROsClientPostDoubleHeadersFinalLocationGetResponse, error) {
	result := LROsClientPostDoubleHeadersFinalLocationGetResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Product)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROsClientPostDoubleHeadersFinalLocationGetPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROsClientPostDoubleHeadersFinalLocationGetPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROsClientPostDoubleHeadersFinalLocationGetPoller) Resume(token string, client *LROsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROsClient.PostDoubleHeadersFinalLocationGet", token, client.pl)
	return
}

// LROsClientPut200Acceptedcanceled200Poller provides polling facilities until the operation reaches a terminal state.
type LROsClientPut200Acceptedcanceled200Poller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsClientPut200Acceptedcanceled200Poller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROsClientPut200Acceptedcanceled200Poller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROsClientPut200Acceptedcanceled200Poller) Result(ctx context.Context) (resp LROsClientPut200Acceptedcanceled200Response, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROsClientPut200Acceptedcanceled200Poller) PollUntilDone(ctx context.Context, freq time.Duration) (LROsClientPut200Acceptedcanceled200Response, error) {
	result := LROsClientPut200Acceptedcanceled200Response{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Product)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROsClientPut200Acceptedcanceled200Poller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROsClientPut200Acceptedcanceled200Poller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROsClientPut200Acceptedcanceled200Poller) Resume(token string, client *LROsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROsClient.Put200Acceptedcanceled200", token, client.pl)
	return
}

// LROsClientPut200SucceededNoStatePoller provides polling facilities until the operation reaches a terminal state.
type LROsClientPut200SucceededNoStatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsClientPut200SucceededNoStatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROsClientPut200SucceededNoStatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROsClientPut200SucceededNoStatePoller) Result(ctx context.Context) (resp LROsClientPut200SucceededNoStateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROsClientPut200SucceededNoStatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (LROsClientPut200SucceededNoStateResponse, error) {
	result := LROsClientPut200SucceededNoStateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Product)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROsClientPut200SucceededNoStatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROsClientPut200SucceededNoStatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROsClientPut200SucceededNoStatePoller) Resume(token string, client *LROsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROsClient.Put200SucceededNoState", token, client.pl)
	return
}

// LROsClientPut200SucceededPoller provides polling facilities until the operation reaches a terminal state.
type LROsClientPut200SucceededPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsClientPut200SucceededPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROsClientPut200SucceededPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROsClientPut200SucceededPoller) Result(ctx context.Context) (resp LROsClientPut200SucceededResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROsClientPut200SucceededPoller) PollUntilDone(ctx context.Context, freq time.Duration) (LROsClientPut200SucceededResponse, error) {
	result := LROsClientPut200SucceededResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Product)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROsClientPut200SucceededPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROsClientPut200SucceededPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROsClientPut200SucceededPoller) Resume(token string, client *LROsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROsClient.Put200Succeeded", token, client.pl)
	return
}

// LROsClientPut200UpdatingSucceeded204Poller provides polling facilities until the operation reaches a terminal state.
type LROsClientPut200UpdatingSucceeded204Poller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsClientPut200UpdatingSucceeded204Poller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROsClientPut200UpdatingSucceeded204Poller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROsClientPut200UpdatingSucceeded204Poller) Result(ctx context.Context) (resp LROsClientPut200UpdatingSucceeded204Response, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROsClientPut200UpdatingSucceeded204Poller) PollUntilDone(ctx context.Context, freq time.Duration) (LROsClientPut200UpdatingSucceeded204Response, error) {
	result := LROsClientPut200UpdatingSucceeded204Response{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Product)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROsClientPut200UpdatingSucceeded204Poller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROsClientPut200UpdatingSucceeded204Poller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROsClientPut200UpdatingSucceeded204Poller) Resume(token string, client *LROsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROsClient.Put200UpdatingSucceeded204", token, client.pl)
	return
}

// LROsClientPut201CreatingFailed200Poller provides polling facilities until the operation reaches a terminal state.
type LROsClientPut201CreatingFailed200Poller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsClientPut201CreatingFailed200Poller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROsClientPut201CreatingFailed200Poller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROsClientPut201CreatingFailed200Poller) Result(ctx context.Context) (resp LROsClientPut201CreatingFailed200Response, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROsClientPut201CreatingFailed200Poller) PollUntilDone(ctx context.Context, freq time.Duration) (LROsClientPut201CreatingFailed200Response, error) {
	result := LROsClientPut201CreatingFailed200Response{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Product)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROsClientPut201CreatingFailed200Poller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROsClientPut201CreatingFailed200Poller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROsClientPut201CreatingFailed200Poller) Resume(token string, client *LROsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROsClient.Put201CreatingFailed200", token, client.pl)
	return
}

// LROsClientPut201CreatingSucceeded200Poller provides polling facilities until the operation reaches a terminal state.
type LROsClientPut201CreatingSucceeded200Poller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsClientPut201CreatingSucceeded200Poller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROsClientPut201CreatingSucceeded200Poller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROsClientPut201CreatingSucceeded200Poller) Result(ctx context.Context) (resp LROsClientPut201CreatingSucceeded200Response, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROsClientPut201CreatingSucceeded200Poller) PollUntilDone(ctx context.Context, freq time.Duration) (LROsClientPut201CreatingSucceeded200Response, error) {
	result := LROsClientPut201CreatingSucceeded200Response{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Product)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROsClientPut201CreatingSucceeded200Poller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROsClientPut201CreatingSucceeded200Poller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROsClientPut201CreatingSucceeded200Poller) Resume(token string, client *LROsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROsClient.Put201CreatingSucceeded200", token, client.pl)
	return
}

// LROsClientPut201SucceededPoller provides polling facilities until the operation reaches a terminal state.
type LROsClientPut201SucceededPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsClientPut201SucceededPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROsClientPut201SucceededPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROsClientPut201SucceededPoller) Result(ctx context.Context) (resp LROsClientPut201SucceededResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROsClientPut201SucceededPoller) PollUntilDone(ctx context.Context, freq time.Duration) (LROsClientPut201SucceededResponse, error) {
	result := LROsClientPut201SucceededResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Product)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROsClientPut201SucceededPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROsClientPut201SucceededPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROsClientPut201SucceededPoller) Resume(token string, client *LROsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROsClient.Put201Succeeded", token, client.pl)
	return
}

// LROsClientPut202Retry200Poller provides polling facilities until the operation reaches a terminal state.
type LROsClientPut202Retry200Poller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsClientPut202Retry200Poller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROsClientPut202Retry200Poller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROsClientPut202Retry200Poller) Result(ctx context.Context) (resp LROsClientPut202Retry200Response, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROsClientPut202Retry200Poller) PollUntilDone(ctx context.Context, freq time.Duration) (LROsClientPut202Retry200Response, error) {
	result := LROsClientPut202Retry200Response{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Product)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROsClientPut202Retry200Poller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROsClientPut202Retry200Poller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROsClientPut202Retry200Poller) Resume(token string, client *LROsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROsClient.Put202Retry200", token, client.pl)
	return
}

// LROsClientPutAsyncNoHeaderInRetryPoller provides polling facilities until the operation reaches a terminal state.
type LROsClientPutAsyncNoHeaderInRetryPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsClientPutAsyncNoHeaderInRetryPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROsClientPutAsyncNoHeaderInRetryPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROsClientPutAsyncNoHeaderInRetryPoller) Result(ctx context.Context) (resp LROsClientPutAsyncNoHeaderInRetryResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROsClientPutAsyncNoHeaderInRetryPoller) PollUntilDone(ctx context.Context, freq time.Duration) (LROsClientPutAsyncNoHeaderInRetryResponse, error) {
	result := LROsClientPutAsyncNoHeaderInRetryResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Product)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROsClientPutAsyncNoHeaderInRetryPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROsClientPutAsyncNoHeaderInRetryPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROsClientPutAsyncNoHeaderInRetryPoller) Resume(token string, client *LROsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROsClient.PutAsyncNoHeaderInRetry", token, client.pl)
	return
}

// LROsClientPutAsyncNoRetrySucceededPoller provides polling facilities until the operation reaches a terminal state.
type LROsClientPutAsyncNoRetrySucceededPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsClientPutAsyncNoRetrySucceededPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROsClientPutAsyncNoRetrySucceededPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROsClientPutAsyncNoRetrySucceededPoller) Result(ctx context.Context) (resp LROsClientPutAsyncNoRetrySucceededResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROsClientPutAsyncNoRetrySucceededPoller) PollUntilDone(ctx context.Context, freq time.Duration) (LROsClientPutAsyncNoRetrySucceededResponse, error) {
	result := LROsClientPutAsyncNoRetrySucceededResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Product)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROsClientPutAsyncNoRetrySucceededPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROsClientPutAsyncNoRetrySucceededPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROsClientPutAsyncNoRetrySucceededPoller) Resume(token string, client *LROsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROsClient.PutAsyncNoRetrySucceeded", token, client.pl)
	return
}

// LROsClientPutAsyncNoRetrycanceledPoller provides polling facilities until the operation reaches a terminal state.
type LROsClientPutAsyncNoRetrycanceledPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsClientPutAsyncNoRetrycanceledPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROsClientPutAsyncNoRetrycanceledPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROsClientPutAsyncNoRetrycanceledPoller) Result(ctx context.Context) (resp LROsClientPutAsyncNoRetrycanceledResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROsClientPutAsyncNoRetrycanceledPoller) PollUntilDone(ctx context.Context, freq time.Duration) (LROsClientPutAsyncNoRetrycanceledResponse, error) {
	result := LROsClientPutAsyncNoRetrycanceledResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Product)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROsClientPutAsyncNoRetrycanceledPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROsClientPutAsyncNoRetrycanceledPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROsClientPutAsyncNoRetrycanceledPoller) Resume(token string, client *LROsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROsClient.PutAsyncNoRetrycanceled", token, client.pl)
	return
}

// LROsClientPutAsyncNonResourcePoller provides polling facilities until the operation reaches a terminal state.
type LROsClientPutAsyncNonResourcePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsClientPutAsyncNonResourcePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROsClientPutAsyncNonResourcePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROsClientPutAsyncNonResourcePoller) Result(ctx context.Context) (resp LROsClientPutAsyncNonResourceResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROsClientPutAsyncNonResourcePoller) PollUntilDone(ctx context.Context, freq time.Duration) (LROsClientPutAsyncNonResourceResponse, error) {
	result := LROsClientPutAsyncNonResourceResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.SKU)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROsClientPutAsyncNonResourcePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROsClientPutAsyncNonResourcePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROsClientPutAsyncNonResourcePoller) Resume(token string, client *LROsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROsClient.PutAsyncNonResource", token, client.pl)
	return
}

// LROsClientPutAsyncRetryFailedPoller provides polling facilities until the operation reaches a terminal state.
type LROsClientPutAsyncRetryFailedPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsClientPutAsyncRetryFailedPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROsClientPutAsyncRetryFailedPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROsClientPutAsyncRetryFailedPoller) Result(ctx context.Context) (resp LROsClientPutAsyncRetryFailedResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROsClientPutAsyncRetryFailedPoller) PollUntilDone(ctx context.Context, freq time.Duration) (LROsClientPutAsyncRetryFailedResponse, error) {
	result := LROsClientPutAsyncRetryFailedResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Product)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROsClientPutAsyncRetryFailedPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROsClientPutAsyncRetryFailedPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROsClientPutAsyncRetryFailedPoller) Resume(token string, client *LROsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROsClient.PutAsyncRetryFailed", token, client.pl)
	return
}

// LROsClientPutAsyncRetrySucceededPoller provides polling facilities until the operation reaches a terminal state.
type LROsClientPutAsyncRetrySucceededPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsClientPutAsyncRetrySucceededPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROsClientPutAsyncRetrySucceededPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROsClientPutAsyncRetrySucceededPoller) Result(ctx context.Context) (resp LROsClientPutAsyncRetrySucceededResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROsClientPutAsyncRetrySucceededPoller) PollUntilDone(ctx context.Context, freq time.Duration) (LROsClientPutAsyncRetrySucceededResponse, error) {
	result := LROsClientPutAsyncRetrySucceededResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Product)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROsClientPutAsyncRetrySucceededPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROsClientPutAsyncRetrySucceededPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROsClientPutAsyncRetrySucceededPoller) Resume(token string, client *LROsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROsClient.PutAsyncRetrySucceeded", token, client.pl)
	return
}

// LROsClientPutAsyncSubResourcePoller provides polling facilities until the operation reaches a terminal state.
type LROsClientPutAsyncSubResourcePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsClientPutAsyncSubResourcePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROsClientPutAsyncSubResourcePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROsClientPutAsyncSubResourcePoller) Result(ctx context.Context) (resp LROsClientPutAsyncSubResourceResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROsClientPutAsyncSubResourcePoller) PollUntilDone(ctx context.Context, freq time.Duration) (LROsClientPutAsyncSubResourceResponse, error) {
	result := LROsClientPutAsyncSubResourceResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.SubProduct)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROsClientPutAsyncSubResourcePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROsClientPutAsyncSubResourcePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROsClientPutAsyncSubResourcePoller) Resume(token string, client *LROsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROsClient.PutAsyncSubResource", token, client.pl)
	return
}

// LROsClientPutNoHeaderInRetryPoller provides polling facilities until the operation reaches a terminal state.
type LROsClientPutNoHeaderInRetryPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsClientPutNoHeaderInRetryPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROsClientPutNoHeaderInRetryPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROsClientPutNoHeaderInRetryPoller) Result(ctx context.Context) (resp LROsClientPutNoHeaderInRetryResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROsClientPutNoHeaderInRetryPoller) PollUntilDone(ctx context.Context, freq time.Duration) (LROsClientPutNoHeaderInRetryResponse, error) {
	result := LROsClientPutNoHeaderInRetryResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Product)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROsClientPutNoHeaderInRetryPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROsClientPutNoHeaderInRetryPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROsClientPutNoHeaderInRetryPoller) Resume(token string, client *LROsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROsClient.PutNoHeaderInRetry", token, client.pl)
	return
}

// LROsClientPutNonResourcePoller provides polling facilities until the operation reaches a terminal state.
type LROsClientPutNonResourcePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsClientPutNonResourcePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROsClientPutNonResourcePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROsClientPutNonResourcePoller) Result(ctx context.Context) (resp LROsClientPutNonResourceResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROsClientPutNonResourcePoller) PollUntilDone(ctx context.Context, freq time.Duration) (LROsClientPutNonResourceResponse, error) {
	result := LROsClientPutNonResourceResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.SKU)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROsClientPutNonResourcePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROsClientPutNonResourcePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROsClientPutNonResourcePoller) Resume(token string, client *LROsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROsClient.PutNonResource", token, client.pl)
	return
}

// LROsClientPutSubResourcePoller provides polling facilities until the operation reaches a terminal state.
type LROsClientPutSubResourcePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsClientPutSubResourcePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROsClientPutSubResourcePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROsClientPutSubResourcePoller) Result(ctx context.Context) (resp LROsClientPutSubResourceResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROsClientPutSubResourcePoller) PollUntilDone(ctx context.Context, freq time.Duration) (LROsClientPutSubResourceResponse, error) {
	result := LROsClientPutSubResourceResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.SubProduct)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROsClientPutSubResourcePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROsClientPutSubResourcePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROsClientPutSubResourcePoller) Resume(token string, client *LROsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROsClient.PutSubResource", token, client.pl)
	return
}

// LROsCustomHeaderClientPost202Retry200Poller provides polling facilities until the operation reaches a terminal state.
type LROsCustomHeaderClientPost202Retry200Poller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsCustomHeaderClientPost202Retry200Poller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROsCustomHeaderClientPost202Retry200Poller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROsCustomHeaderClientPost202Retry200Poller) Result(ctx context.Context) (resp LROsCustomHeaderClientPost202Retry200Response, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROsCustomHeaderClientPost202Retry200Poller) PollUntilDone(ctx context.Context, freq time.Duration) (LROsCustomHeaderClientPost202Retry200Response, error) {
	result := LROsCustomHeaderClientPost202Retry200Response{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROsCustomHeaderClientPost202Retry200Poller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROsCustomHeaderClientPost202Retry200Poller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROsCustomHeaderClientPost202Retry200Poller) Resume(token string, client *LROsCustomHeaderClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROsCustomHeaderClient.Post202Retry200", token, client.pl)
	return
}

// LROsCustomHeaderClientPostAsyncRetrySucceededPoller provides polling facilities until the operation reaches a terminal state.
type LROsCustomHeaderClientPostAsyncRetrySucceededPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsCustomHeaderClientPostAsyncRetrySucceededPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROsCustomHeaderClientPostAsyncRetrySucceededPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROsCustomHeaderClientPostAsyncRetrySucceededPoller) Result(ctx context.Context) (resp LROsCustomHeaderClientPostAsyncRetrySucceededResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROsCustomHeaderClientPostAsyncRetrySucceededPoller) PollUntilDone(ctx context.Context, freq time.Duration) (LROsCustomHeaderClientPostAsyncRetrySucceededResponse, error) {
	result := LROsCustomHeaderClientPostAsyncRetrySucceededResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROsCustomHeaderClientPostAsyncRetrySucceededPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROsCustomHeaderClientPostAsyncRetrySucceededPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROsCustomHeaderClientPostAsyncRetrySucceededPoller) Resume(token string, client *LROsCustomHeaderClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROsCustomHeaderClient.PostAsyncRetrySucceeded", token, client.pl)
	return
}

// LROsCustomHeaderClientPut201CreatingSucceeded200Poller provides polling facilities until the operation reaches a terminal state.
type LROsCustomHeaderClientPut201CreatingSucceeded200Poller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsCustomHeaderClientPut201CreatingSucceeded200Poller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROsCustomHeaderClientPut201CreatingSucceeded200Poller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROsCustomHeaderClientPut201CreatingSucceeded200Poller) Result(ctx context.Context) (resp LROsCustomHeaderClientPut201CreatingSucceeded200Response, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROsCustomHeaderClientPut201CreatingSucceeded200Poller) PollUntilDone(ctx context.Context, freq time.Duration) (LROsCustomHeaderClientPut201CreatingSucceeded200Response, error) {
	result := LROsCustomHeaderClientPut201CreatingSucceeded200Response{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Product)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROsCustomHeaderClientPut201CreatingSucceeded200Poller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROsCustomHeaderClientPut201CreatingSucceeded200Poller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROsCustomHeaderClientPut201CreatingSucceeded200Poller) Resume(token string, client *LROsCustomHeaderClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROsCustomHeaderClient.Put201CreatingSucceeded200", token, client.pl)
	return
}

// LROsCustomHeaderClientPutAsyncRetrySucceededPoller provides polling facilities until the operation reaches a terminal state.
type LROsCustomHeaderClientPutAsyncRetrySucceededPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LROsCustomHeaderClientPutAsyncRetrySucceededPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LROsCustomHeaderClientPutAsyncRetrySucceededPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LROsCustomHeaderClientPutAsyncRetrySucceededPoller) Result(ctx context.Context) (resp LROsCustomHeaderClientPutAsyncRetrySucceededResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *LROsCustomHeaderClientPutAsyncRetrySucceededPoller) PollUntilDone(ctx context.Context, freq time.Duration) (LROsCustomHeaderClientPutAsyncRetrySucceededResponse, error) {
	result := LROsCustomHeaderClientPutAsyncRetrySucceededResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Product)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LROsCustomHeaderClientPutAsyncRetrySucceededPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LROsCustomHeaderClientPutAsyncRetrySucceededPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LROsCustomHeaderClientPutAsyncRetrySucceededPoller) Resume(token string, client *LROsCustomHeaderClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LROsCustomHeaderClient.PutAsyncRetrySucceeded", token, client.pl)
	return
}
