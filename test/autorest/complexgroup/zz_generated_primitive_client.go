//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package complexgroup

import (
	"context"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
)

// PrimitiveClient contains the methods for the Primitive group.
// Don't use this type directly, use NewPrimitiveClient() instead.
type PrimitiveClient struct {
	pl runtime.Pipeline
}

// NewPrimitiveClient creates a new instance of PrimitiveClient with the specified values.
// options - pass nil to accept the default values.
func NewPrimitiveClient(options *azcore.ClientOptions) *PrimitiveClient {
	cp := azcore.ClientOptions{}
	if options != nil {
		cp = *options
	}
	client := &PrimitiveClient{
		pl: runtime.NewPipeline(module, version, nil, nil, &cp),
	}
	return client
}

// GetBool - Get complex types with bool properties
// If the operation fails it returns the *Error error type.
// options - PrimitiveGetBoolOptions contains the optional parameters for the PrimitiveClient.GetBool method.
func (client *PrimitiveClient) GetBool(ctx context.Context, options *PrimitiveGetBoolOptions) (PrimitiveGetBoolResponse, error) {
	req, err := client.getBoolCreateRequest(ctx, options)
	if err != nil {
		return PrimitiveGetBoolResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PrimitiveGetBoolResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PrimitiveGetBoolResponse{}, client.getBoolHandleError(resp)
	}
	return client.getBoolHandleResponse(resp)
}

// getBoolCreateRequest creates the GetBool request.
func (client *PrimitiveClient) getBoolCreateRequest(ctx context.Context, options *PrimitiveGetBoolOptions) (*policy.Request, error) {
	urlPath := "/complex/primitive/bool"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getBoolHandleResponse handles the GetBool response.
func (client *PrimitiveClient) getBoolHandleResponse(resp *http.Response) (PrimitiveGetBoolResponse, error) {
	result := PrimitiveGetBoolResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.BooleanWrapper); err != nil {
		return PrimitiveGetBoolResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getBoolHandleError handles the GetBool error response.
func (client *PrimitiveClient) getBoolHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetByte - Get complex types with byte properties
// If the operation fails it returns the *Error error type.
// options - PrimitiveGetByteOptions contains the optional parameters for the PrimitiveClient.GetByte method.
func (client *PrimitiveClient) GetByte(ctx context.Context, options *PrimitiveGetByteOptions) (PrimitiveGetByteResponse, error) {
	req, err := client.getByteCreateRequest(ctx, options)
	if err != nil {
		return PrimitiveGetByteResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PrimitiveGetByteResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PrimitiveGetByteResponse{}, client.getByteHandleError(resp)
	}
	return client.getByteHandleResponse(resp)
}

// getByteCreateRequest creates the GetByte request.
func (client *PrimitiveClient) getByteCreateRequest(ctx context.Context, options *PrimitiveGetByteOptions) (*policy.Request, error) {
	urlPath := "/complex/primitive/byte"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getByteHandleResponse handles the GetByte response.
func (client *PrimitiveClient) getByteHandleResponse(resp *http.Response) (PrimitiveGetByteResponse, error) {
	result := PrimitiveGetByteResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ByteWrapper); err != nil {
		return PrimitiveGetByteResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getByteHandleError handles the GetByte error response.
func (client *PrimitiveClient) getByteHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetDate - Get complex types with date properties
// If the operation fails it returns the *Error error type.
// options - PrimitiveGetDateOptions contains the optional parameters for the PrimitiveClient.GetDate method.
func (client *PrimitiveClient) GetDate(ctx context.Context, options *PrimitiveGetDateOptions) (PrimitiveGetDateResponse, error) {
	req, err := client.getDateCreateRequest(ctx, options)
	if err != nil {
		return PrimitiveGetDateResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PrimitiveGetDateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PrimitiveGetDateResponse{}, client.getDateHandleError(resp)
	}
	return client.getDateHandleResponse(resp)
}

// getDateCreateRequest creates the GetDate request.
func (client *PrimitiveClient) getDateCreateRequest(ctx context.Context, options *PrimitiveGetDateOptions) (*policy.Request, error) {
	urlPath := "/complex/primitive/date"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getDateHandleResponse handles the GetDate response.
func (client *PrimitiveClient) getDateHandleResponse(resp *http.Response) (PrimitiveGetDateResponse, error) {
	result := PrimitiveGetDateResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.DateWrapper); err != nil {
		return PrimitiveGetDateResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getDateHandleError handles the GetDate error response.
func (client *PrimitiveClient) getDateHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetDateTime - Get complex types with datetime properties
// If the operation fails it returns the *Error error type.
// options - PrimitiveGetDateTimeOptions contains the optional parameters for the PrimitiveClient.GetDateTime method.
func (client *PrimitiveClient) GetDateTime(ctx context.Context, options *PrimitiveGetDateTimeOptions) (PrimitiveGetDateTimeResponse, error) {
	req, err := client.getDateTimeCreateRequest(ctx, options)
	if err != nil {
		return PrimitiveGetDateTimeResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PrimitiveGetDateTimeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PrimitiveGetDateTimeResponse{}, client.getDateTimeHandleError(resp)
	}
	return client.getDateTimeHandleResponse(resp)
}

// getDateTimeCreateRequest creates the GetDateTime request.
func (client *PrimitiveClient) getDateTimeCreateRequest(ctx context.Context, options *PrimitiveGetDateTimeOptions) (*policy.Request, error) {
	urlPath := "/complex/primitive/datetime"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getDateTimeHandleResponse handles the GetDateTime response.
func (client *PrimitiveClient) getDateTimeHandleResponse(resp *http.Response) (PrimitiveGetDateTimeResponse, error) {
	result := PrimitiveGetDateTimeResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.DatetimeWrapper); err != nil {
		return PrimitiveGetDateTimeResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getDateTimeHandleError handles the GetDateTime error response.
func (client *PrimitiveClient) getDateTimeHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetDateTimeRFC1123 - Get complex types with datetimeRfc1123 properties
// If the operation fails it returns the *Error error type.
// options - PrimitiveGetDateTimeRFC1123Options contains the optional parameters for the PrimitiveClient.GetDateTimeRFC1123
// method.
func (client *PrimitiveClient) GetDateTimeRFC1123(ctx context.Context, options *PrimitiveGetDateTimeRFC1123Options) (PrimitiveGetDateTimeRFC1123Response, error) {
	req, err := client.getDateTimeRFC1123CreateRequest(ctx, options)
	if err != nil {
		return PrimitiveGetDateTimeRFC1123Response{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PrimitiveGetDateTimeRFC1123Response{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PrimitiveGetDateTimeRFC1123Response{}, client.getDateTimeRFC1123HandleError(resp)
	}
	return client.getDateTimeRFC1123HandleResponse(resp)
}

// getDateTimeRFC1123CreateRequest creates the GetDateTimeRFC1123 request.
func (client *PrimitiveClient) getDateTimeRFC1123CreateRequest(ctx context.Context, options *PrimitiveGetDateTimeRFC1123Options) (*policy.Request, error) {
	urlPath := "/complex/primitive/datetimerfc1123"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getDateTimeRFC1123HandleResponse handles the GetDateTimeRFC1123 response.
func (client *PrimitiveClient) getDateTimeRFC1123HandleResponse(resp *http.Response) (PrimitiveGetDateTimeRFC1123Response, error) {
	result := PrimitiveGetDateTimeRFC1123Response{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Datetimerfc1123Wrapper); err != nil {
		return PrimitiveGetDateTimeRFC1123Response{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getDateTimeRFC1123HandleError handles the GetDateTimeRFC1123 error response.
func (client *PrimitiveClient) getDateTimeRFC1123HandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetDouble - Get complex types with double properties
// If the operation fails it returns the *Error error type.
// options - PrimitiveGetDoubleOptions contains the optional parameters for the PrimitiveClient.GetDouble method.
func (client *PrimitiveClient) GetDouble(ctx context.Context, options *PrimitiveGetDoubleOptions) (PrimitiveGetDoubleResponse, error) {
	req, err := client.getDoubleCreateRequest(ctx, options)
	if err != nil {
		return PrimitiveGetDoubleResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PrimitiveGetDoubleResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PrimitiveGetDoubleResponse{}, client.getDoubleHandleError(resp)
	}
	return client.getDoubleHandleResponse(resp)
}

// getDoubleCreateRequest creates the GetDouble request.
func (client *PrimitiveClient) getDoubleCreateRequest(ctx context.Context, options *PrimitiveGetDoubleOptions) (*policy.Request, error) {
	urlPath := "/complex/primitive/double"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getDoubleHandleResponse handles the GetDouble response.
func (client *PrimitiveClient) getDoubleHandleResponse(resp *http.Response) (PrimitiveGetDoubleResponse, error) {
	result := PrimitiveGetDoubleResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.DoubleWrapper); err != nil {
		return PrimitiveGetDoubleResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getDoubleHandleError handles the GetDouble error response.
func (client *PrimitiveClient) getDoubleHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetDuration - Get complex types with duration properties
// If the operation fails it returns the *Error error type.
// options - PrimitiveGetDurationOptions contains the optional parameters for the PrimitiveClient.GetDuration method.
func (client *PrimitiveClient) GetDuration(ctx context.Context, options *PrimitiveGetDurationOptions) (PrimitiveGetDurationResponse, error) {
	req, err := client.getDurationCreateRequest(ctx, options)
	if err != nil {
		return PrimitiveGetDurationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PrimitiveGetDurationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PrimitiveGetDurationResponse{}, client.getDurationHandleError(resp)
	}
	return client.getDurationHandleResponse(resp)
}

// getDurationCreateRequest creates the GetDuration request.
func (client *PrimitiveClient) getDurationCreateRequest(ctx context.Context, options *PrimitiveGetDurationOptions) (*policy.Request, error) {
	urlPath := "/complex/primitive/duration"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getDurationHandleResponse handles the GetDuration response.
func (client *PrimitiveClient) getDurationHandleResponse(resp *http.Response) (PrimitiveGetDurationResponse, error) {
	result := PrimitiveGetDurationResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.DurationWrapper); err != nil {
		return PrimitiveGetDurationResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getDurationHandleError handles the GetDuration error response.
func (client *PrimitiveClient) getDurationHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetFloat - Get complex types with float properties
// If the operation fails it returns the *Error error type.
// options - PrimitiveGetFloatOptions contains the optional parameters for the PrimitiveClient.GetFloat method.
func (client *PrimitiveClient) GetFloat(ctx context.Context, options *PrimitiveGetFloatOptions) (PrimitiveGetFloatResponse, error) {
	req, err := client.getFloatCreateRequest(ctx, options)
	if err != nil {
		return PrimitiveGetFloatResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PrimitiveGetFloatResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PrimitiveGetFloatResponse{}, client.getFloatHandleError(resp)
	}
	return client.getFloatHandleResponse(resp)
}

// getFloatCreateRequest creates the GetFloat request.
func (client *PrimitiveClient) getFloatCreateRequest(ctx context.Context, options *PrimitiveGetFloatOptions) (*policy.Request, error) {
	urlPath := "/complex/primitive/float"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getFloatHandleResponse handles the GetFloat response.
func (client *PrimitiveClient) getFloatHandleResponse(resp *http.Response) (PrimitiveGetFloatResponse, error) {
	result := PrimitiveGetFloatResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.FloatWrapper); err != nil {
		return PrimitiveGetFloatResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getFloatHandleError handles the GetFloat error response.
func (client *PrimitiveClient) getFloatHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetInt - Get complex types with integer properties
// If the operation fails it returns the *Error error type.
// options - PrimitiveGetIntOptions contains the optional parameters for the PrimitiveClient.GetInt method.
func (client *PrimitiveClient) GetInt(ctx context.Context, options *PrimitiveGetIntOptions) (PrimitiveGetIntResponse, error) {
	req, err := client.getIntCreateRequest(ctx, options)
	if err != nil {
		return PrimitiveGetIntResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PrimitiveGetIntResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PrimitiveGetIntResponse{}, client.getIntHandleError(resp)
	}
	return client.getIntHandleResponse(resp)
}

// getIntCreateRequest creates the GetInt request.
func (client *PrimitiveClient) getIntCreateRequest(ctx context.Context, options *PrimitiveGetIntOptions) (*policy.Request, error) {
	urlPath := "/complex/primitive/integer"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getIntHandleResponse handles the GetInt response.
func (client *PrimitiveClient) getIntHandleResponse(resp *http.Response) (PrimitiveGetIntResponse, error) {
	result := PrimitiveGetIntResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.IntWrapper); err != nil {
		return PrimitiveGetIntResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getIntHandleError handles the GetInt error response.
func (client *PrimitiveClient) getIntHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetLong - Get complex types with long properties
// If the operation fails it returns the *Error error type.
// options - PrimitiveGetLongOptions contains the optional parameters for the PrimitiveClient.GetLong method.
func (client *PrimitiveClient) GetLong(ctx context.Context, options *PrimitiveGetLongOptions) (PrimitiveGetLongResponse, error) {
	req, err := client.getLongCreateRequest(ctx, options)
	if err != nil {
		return PrimitiveGetLongResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PrimitiveGetLongResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PrimitiveGetLongResponse{}, client.getLongHandleError(resp)
	}
	return client.getLongHandleResponse(resp)
}

// getLongCreateRequest creates the GetLong request.
func (client *PrimitiveClient) getLongCreateRequest(ctx context.Context, options *PrimitiveGetLongOptions) (*policy.Request, error) {
	urlPath := "/complex/primitive/long"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getLongHandleResponse handles the GetLong response.
func (client *PrimitiveClient) getLongHandleResponse(resp *http.Response) (PrimitiveGetLongResponse, error) {
	result := PrimitiveGetLongResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.LongWrapper); err != nil {
		return PrimitiveGetLongResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getLongHandleError handles the GetLong error response.
func (client *PrimitiveClient) getLongHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetString - Get complex types with string properties
// If the operation fails it returns the *Error error type.
// options - PrimitiveGetStringOptions contains the optional parameters for the PrimitiveClient.GetString method.
func (client *PrimitiveClient) GetString(ctx context.Context, options *PrimitiveGetStringOptions) (PrimitiveGetStringResponse, error) {
	req, err := client.getStringCreateRequest(ctx, options)
	if err != nil {
		return PrimitiveGetStringResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PrimitiveGetStringResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PrimitiveGetStringResponse{}, client.getStringHandleError(resp)
	}
	return client.getStringHandleResponse(resp)
}

// getStringCreateRequest creates the GetString request.
func (client *PrimitiveClient) getStringCreateRequest(ctx context.Context, options *PrimitiveGetStringOptions) (*policy.Request, error) {
	urlPath := "/complex/primitive/string"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getStringHandleResponse handles the GetString response.
func (client *PrimitiveClient) getStringHandleResponse(resp *http.Response) (PrimitiveGetStringResponse, error) {
	result := PrimitiveGetStringResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.StringWrapper); err != nil {
		return PrimitiveGetStringResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getStringHandleError handles the GetString error response.
func (client *PrimitiveClient) getStringHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// PutBool - Put complex types with bool properties
// If the operation fails it returns the *Error error type.
// complexBody - Please put true and false
// options - PrimitivePutBoolOptions contains the optional parameters for the PrimitiveClient.PutBool method.
func (client *PrimitiveClient) PutBool(ctx context.Context, complexBody BooleanWrapper, options *PrimitivePutBoolOptions) (PrimitivePutBoolResponse, error) {
	req, err := client.putBoolCreateRequest(ctx, complexBody, options)
	if err != nil {
		return PrimitivePutBoolResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PrimitivePutBoolResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PrimitivePutBoolResponse{}, client.putBoolHandleError(resp)
	}
	return PrimitivePutBoolResponse{RawResponse: resp}, nil
}

// putBoolCreateRequest creates the PutBool request.
func (client *PrimitiveClient) putBoolCreateRequest(ctx context.Context, complexBody BooleanWrapper, options *PrimitivePutBoolOptions) (*policy.Request, error) {
	urlPath := "/complex/primitive/bool"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, complexBody)
}

// putBoolHandleError handles the PutBool error response.
func (client *PrimitiveClient) putBoolHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// PutByte - Put complex types with byte properties
// If the operation fails it returns the *Error error type.
// complexBody - Please put non-ascii byte string hex(FF FE FD FC 00 FA F9 F8 F7 F6)
// options - PrimitivePutByteOptions contains the optional parameters for the PrimitiveClient.PutByte method.
func (client *PrimitiveClient) PutByte(ctx context.Context, complexBody ByteWrapper, options *PrimitivePutByteOptions) (PrimitivePutByteResponse, error) {
	req, err := client.putByteCreateRequest(ctx, complexBody, options)
	if err != nil {
		return PrimitivePutByteResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PrimitivePutByteResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PrimitivePutByteResponse{}, client.putByteHandleError(resp)
	}
	return PrimitivePutByteResponse{RawResponse: resp}, nil
}

// putByteCreateRequest creates the PutByte request.
func (client *PrimitiveClient) putByteCreateRequest(ctx context.Context, complexBody ByteWrapper, options *PrimitivePutByteOptions) (*policy.Request, error) {
	urlPath := "/complex/primitive/byte"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, complexBody)
}

// putByteHandleError handles the PutByte error response.
func (client *PrimitiveClient) putByteHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// PutDate - Put complex types with date properties
// If the operation fails it returns the *Error error type.
// complexBody - Please put '0001-01-01' and '2016-02-29'
// options - PrimitivePutDateOptions contains the optional parameters for the PrimitiveClient.PutDate method.
func (client *PrimitiveClient) PutDate(ctx context.Context, complexBody DateWrapper, options *PrimitivePutDateOptions) (PrimitivePutDateResponse, error) {
	req, err := client.putDateCreateRequest(ctx, complexBody, options)
	if err != nil {
		return PrimitivePutDateResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PrimitivePutDateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PrimitivePutDateResponse{}, client.putDateHandleError(resp)
	}
	return PrimitivePutDateResponse{RawResponse: resp}, nil
}

// putDateCreateRequest creates the PutDate request.
func (client *PrimitiveClient) putDateCreateRequest(ctx context.Context, complexBody DateWrapper, options *PrimitivePutDateOptions) (*policy.Request, error) {
	urlPath := "/complex/primitive/date"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, complexBody)
}

// putDateHandleError handles the PutDate error response.
func (client *PrimitiveClient) putDateHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// PutDateTime - Put complex types with datetime properties
// If the operation fails it returns the *Error error type.
// complexBody - Please put '0001-01-01T12:00:00-04:00' and '2015-05-18T11:38:00-08:00'
// options - PrimitivePutDateTimeOptions contains the optional parameters for the PrimitiveClient.PutDateTime method.
func (client *PrimitiveClient) PutDateTime(ctx context.Context, complexBody DatetimeWrapper, options *PrimitivePutDateTimeOptions) (PrimitivePutDateTimeResponse, error) {
	req, err := client.putDateTimeCreateRequest(ctx, complexBody, options)
	if err != nil {
		return PrimitivePutDateTimeResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PrimitivePutDateTimeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PrimitivePutDateTimeResponse{}, client.putDateTimeHandleError(resp)
	}
	return PrimitivePutDateTimeResponse{RawResponse: resp}, nil
}

// putDateTimeCreateRequest creates the PutDateTime request.
func (client *PrimitiveClient) putDateTimeCreateRequest(ctx context.Context, complexBody DatetimeWrapper, options *PrimitivePutDateTimeOptions) (*policy.Request, error) {
	urlPath := "/complex/primitive/datetime"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, complexBody)
}

// putDateTimeHandleError handles the PutDateTime error response.
func (client *PrimitiveClient) putDateTimeHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// PutDateTimeRFC1123 - Put complex types with datetimeRfc1123 properties
// If the operation fails it returns the *Error error type.
// complexBody - Please put 'Mon, 01 Jan 0001 12:00:00 GMT' and 'Mon, 18 May 2015 11:38:00 GMT'
// options - PrimitivePutDateTimeRFC1123Options contains the optional parameters for the PrimitiveClient.PutDateTimeRFC1123
// method.
func (client *PrimitiveClient) PutDateTimeRFC1123(ctx context.Context, complexBody Datetimerfc1123Wrapper, options *PrimitivePutDateTimeRFC1123Options) (PrimitivePutDateTimeRFC1123Response, error) {
	req, err := client.putDateTimeRFC1123CreateRequest(ctx, complexBody, options)
	if err != nil {
		return PrimitivePutDateTimeRFC1123Response{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PrimitivePutDateTimeRFC1123Response{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PrimitivePutDateTimeRFC1123Response{}, client.putDateTimeRFC1123HandleError(resp)
	}
	return PrimitivePutDateTimeRFC1123Response{RawResponse: resp}, nil
}

// putDateTimeRFC1123CreateRequest creates the PutDateTimeRFC1123 request.
func (client *PrimitiveClient) putDateTimeRFC1123CreateRequest(ctx context.Context, complexBody Datetimerfc1123Wrapper, options *PrimitivePutDateTimeRFC1123Options) (*policy.Request, error) {
	urlPath := "/complex/primitive/datetimerfc1123"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, complexBody)
}

// putDateTimeRFC1123HandleError handles the PutDateTimeRFC1123 error response.
func (client *PrimitiveClient) putDateTimeRFC1123HandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// PutDouble - Put complex types with double properties
// If the operation fails it returns the *Error error type.
// complexBody - Please put 3e-100 and -0.000000000000000000000000000000000000000000000000000000005
// options - PrimitivePutDoubleOptions contains the optional parameters for the PrimitiveClient.PutDouble method.
func (client *PrimitiveClient) PutDouble(ctx context.Context, complexBody DoubleWrapper, options *PrimitivePutDoubleOptions) (PrimitivePutDoubleResponse, error) {
	req, err := client.putDoubleCreateRequest(ctx, complexBody, options)
	if err != nil {
		return PrimitivePutDoubleResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PrimitivePutDoubleResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PrimitivePutDoubleResponse{}, client.putDoubleHandleError(resp)
	}
	return PrimitivePutDoubleResponse{RawResponse: resp}, nil
}

// putDoubleCreateRequest creates the PutDouble request.
func (client *PrimitiveClient) putDoubleCreateRequest(ctx context.Context, complexBody DoubleWrapper, options *PrimitivePutDoubleOptions) (*policy.Request, error) {
	urlPath := "/complex/primitive/double"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, complexBody)
}

// putDoubleHandleError handles the PutDouble error response.
func (client *PrimitiveClient) putDoubleHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// PutDuration - Put complex types with duration properties
// If the operation fails it returns the *Error error type.
// complexBody - Please put 'P123DT22H14M12.011S'
// options - PrimitivePutDurationOptions contains the optional parameters for the PrimitiveClient.PutDuration method.
func (client *PrimitiveClient) PutDuration(ctx context.Context, complexBody DurationWrapper, options *PrimitivePutDurationOptions) (PrimitivePutDurationResponse, error) {
	req, err := client.putDurationCreateRequest(ctx, complexBody, options)
	if err != nil {
		return PrimitivePutDurationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PrimitivePutDurationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PrimitivePutDurationResponse{}, client.putDurationHandleError(resp)
	}
	return PrimitivePutDurationResponse{RawResponse: resp}, nil
}

// putDurationCreateRequest creates the PutDuration request.
func (client *PrimitiveClient) putDurationCreateRequest(ctx context.Context, complexBody DurationWrapper, options *PrimitivePutDurationOptions) (*policy.Request, error) {
	urlPath := "/complex/primitive/duration"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, complexBody)
}

// putDurationHandleError handles the PutDuration error response.
func (client *PrimitiveClient) putDurationHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// PutFloat - Put complex types with float properties
// If the operation fails it returns the *Error error type.
// complexBody - Please put 1.05 and -0.003
// options - PrimitivePutFloatOptions contains the optional parameters for the PrimitiveClient.PutFloat method.
func (client *PrimitiveClient) PutFloat(ctx context.Context, complexBody FloatWrapper, options *PrimitivePutFloatOptions) (PrimitivePutFloatResponse, error) {
	req, err := client.putFloatCreateRequest(ctx, complexBody, options)
	if err != nil {
		return PrimitivePutFloatResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PrimitivePutFloatResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PrimitivePutFloatResponse{}, client.putFloatHandleError(resp)
	}
	return PrimitivePutFloatResponse{RawResponse: resp}, nil
}

// putFloatCreateRequest creates the PutFloat request.
func (client *PrimitiveClient) putFloatCreateRequest(ctx context.Context, complexBody FloatWrapper, options *PrimitivePutFloatOptions) (*policy.Request, error) {
	urlPath := "/complex/primitive/float"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, complexBody)
}

// putFloatHandleError handles the PutFloat error response.
func (client *PrimitiveClient) putFloatHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// PutInt - Put complex types with integer properties
// If the operation fails it returns the *Error error type.
// complexBody - Please put -1 and 2
// options - PrimitivePutIntOptions contains the optional parameters for the PrimitiveClient.PutInt method.
func (client *PrimitiveClient) PutInt(ctx context.Context, complexBody IntWrapper, options *PrimitivePutIntOptions) (PrimitivePutIntResponse, error) {
	req, err := client.putIntCreateRequest(ctx, complexBody, options)
	if err != nil {
		return PrimitivePutIntResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PrimitivePutIntResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PrimitivePutIntResponse{}, client.putIntHandleError(resp)
	}
	return PrimitivePutIntResponse{RawResponse: resp}, nil
}

// putIntCreateRequest creates the PutInt request.
func (client *PrimitiveClient) putIntCreateRequest(ctx context.Context, complexBody IntWrapper, options *PrimitivePutIntOptions) (*policy.Request, error) {
	urlPath := "/complex/primitive/integer"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, complexBody)
}

// putIntHandleError handles the PutInt error response.
func (client *PrimitiveClient) putIntHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// PutLong - Put complex types with long properties
// If the operation fails it returns the *Error error type.
// complexBody - Please put 1099511627775 and -999511627788
// options - PrimitivePutLongOptions contains the optional parameters for the PrimitiveClient.PutLong method.
func (client *PrimitiveClient) PutLong(ctx context.Context, complexBody LongWrapper, options *PrimitivePutLongOptions) (PrimitivePutLongResponse, error) {
	req, err := client.putLongCreateRequest(ctx, complexBody, options)
	if err != nil {
		return PrimitivePutLongResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PrimitivePutLongResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PrimitivePutLongResponse{}, client.putLongHandleError(resp)
	}
	return PrimitivePutLongResponse{RawResponse: resp}, nil
}

// putLongCreateRequest creates the PutLong request.
func (client *PrimitiveClient) putLongCreateRequest(ctx context.Context, complexBody LongWrapper, options *PrimitivePutLongOptions) (*policy.Request, error) {
	urlPath := "/complex/primitive/long"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, complexBody)
}

// putLongHandleError handles the PutLong error response.
func (client *PrimitiveClient) putLongHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// PutString - Put complex types with string properties
// If the operation fails it returns the *Error error type.
// complexBody - Please put 'goodrequest', '', and null
// options - PrimitivePutStringOptions contains the optional parameters for the PrimitiveClient.PutString method.
func (client *PrimitiveClient) PutString(ctx context.Context, complexBody StringWrapper, options *PrimitivePutStringOptions) (PrimitivePutStringResponse, error) {
	req, err := client.putStringCreateRequest(ctx, complexBody, options)
	if err != nil {
		return PrimitivePutStringResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PrimitivePutStringResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PrimitivePutStringResponse{}, client.putStringHandleError(resp)
	}
	return PrimitivePutStringResponse{RawResponse: resp}, nil
}

// putStringCreateRequest creates the PutString request.
func (client *PrimitiveClient) putStringCreateRequest(ctx context.Context, complexBody StringWrapper, options *PrimitivePutStringOptions) (*policy.Request, error) {
	urlPath := "/complex/primitive/string"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, complexBody)
}

// putStringHandleError handles the PutString error response.
func (client *PrimitiveClient) putStringHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}
