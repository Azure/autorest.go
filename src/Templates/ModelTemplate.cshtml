@using AutoRest.Go
@using AutoRest.Core.Model
@using AutoRest.Go.Model
@using AutoRest.Go.Templates
@using AutoRest.Core.Utilities

@inherits AutoRest.Core.Template<AutoRest.Go.Model.CompositeTypeGo>

@if (Model.HasInterface)
{
@WrapComment("// ", $"{Model.GetInterfaceName()} {Model.Documentation.ToSentence()}")
    <text>
type @(Model.GetInterfaceName()) interface {
    @foreach (var dt in Model.DerivedTypes)
    {
        @:As@(dt.Name) () (*@(dt.Name), bool)
        if (dt is CompositeTypeGo type && type.HasInterface)
        {
            @:As@(dt.GetInterfaceName()) () (@(dt.GetInterfaceName()), bool)
        }
    }
    As@(Model.Name) () (*@(Model.Name), bool)
}

@EmptyLine
@WrapComment("// ", $"{Model.Name} {Model.Documentation.ToSentence()}")
type @(Model.Name) struct {
    @(Model.AddHTTPResponse())
    @(Model.Fields())
}

@EmptyLine
func unmarshal@(Model.GetInterfaceName())(body []byte) (@(Model.GetInterfaceName()), error){
    var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
	    return nil, err
	}
    @EmptyLine
    switch m["@(Model.RootType.PolymorphicDiscriminator)"] {
    @foreach (var dt in Model.DerivedTypes)
    {
    <text>
    case string(@(CodeNamerGo.Instance.GetEnumMemberName((dt as CompositeTypeGo).DiscriminatorEnumValue))):
        var @(dt.Name.FixedValue.ToShortName()) @(dt.Name)
        err := json.Unmarshal(body, &@(dt.Name.FixedValue.ToShortName()))
        return @(dt.Name.FixedValue.ToShortName()), err
    </text>
    }
    default:
        var @(Model.Name.FixedValue.ToShortName()) @(Model.Name)
        err := json.Unmarshal(body, &@(Model.Name.FixedValue.ToShortName()))
        return @(Model.Name.FixedValue.ToShortName()), err
    }
}

func unmarshal@(Model.GetInterfaceName())Array(body []byte) ([]@(Model.GetInterfaceName()), error){
    var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
        return nil, err
	}
    @EmptyLine
    @(Model.Name.FixedValue.ToShortName())Array := make([]@(Model.GetInterfaceName()), len(rawMessages))
    @EmptyLine
    for index, rawMessage := range rawMessages {
        @(Model.Name.FixedValue.ToShortName()), err := unmarshal@(Model.GetInterfaceName())(*rawMessage)
	    if err != nil {
		    return nil, err
	    }
        @(Model.Name.FixedValue.ToShortName())Array[index] = @(Model.Name.FixedValue.ToShortName())
    }
    return @(Model.Name.FixedValue.ToShortName())Array, nil
}
</text>
}
else
{
@WrapComment("// ", $"{Model.Name} {Model.Documentation.ToSentence()}")
    <text>
type @(Model.Name) struct {
    @(Model.AddHTTPResponse())
    @(Model.Fields())
}
</text>
}

@if (Model.BaseIsPolymorphic || Model.IsPolymorphic)
{
<text>
@EmptyLine
// MarshalJSON is the custom marshaler for @(Model.Name).
func (@(Model.Name.FixedValue.ToShortName()) @(Model.Name))MarshalJSON() ([]byte, error){
    @(Model.Name.FixedValue.ToShortName()).@(Model.PolymorphicProperty) = @(CodeNamerGo.Instance.GetEnumMemberName(Model.DiscriminatorEnumValue))
    type Alias @(Model.Name)
    return json.Marshal(&struct {
        Alias
    }{
        Alias: (Alias)(@(Model.Name.FixedValue.ToShortName())),
    })
}

    @foreach (var st in Model.SiblingTypes)
    {
    <text>
@EmptyLine
// As@(st.Name) is the @(Model.RootType.GetInterfaceName()) implementation for @(Model.Name).
func (@(Model.Name.FixedValue.ToShortName()) @(Model.Name)) As@(st.Name)() (*@(st.Name), bool) {
        @if (st.Equals(Model))
        {
    @:return &@(Model.Name.FixedValue.ToShortName()), true
        }
        else
        {
    @:return nil, false
        }
        }

    @if (st is CompositeTypeGo type && type.HasInterface)
    {
        @EmptyLine
        @:// As@(st.GetInterfaceName()) is the @(Model.RootType.GetInterfaceName()) implementation for @(Model.Name).
        @:func(@(Model.Name.FixedValue.ToShortName()) @(Model.Name)) As@(st.GetInterfaceName())()(@(st.GetInterfaceName()), bool) {
        if (st.Equals(Model) || Model.DerivesFrom(st))
        {
            @:return &@(Model.Name.FixedValue.ToShortName()), true
        }
        else
        {
            @:return nil, false
        }
        @:}
        @EmptyLine
    }
    </text>
    }
</text>
}

@if (Model.HasPolymorphicFields)
{
<text>
// UnmarshalJSON is the custom unmarshaler for @(Model.Name) struct.
func (@(Model.Name.FixedValue.ToShortName()) *@(Model.Name)) UnmarshalJSON(body []byte) error {
    @if (Model.IsWrapperType)
    {
        if (Model.BaseType is SequenceType)
        {
    @:@(((SequenceTypeGo) Model.BaseType).ElementType.Name.FixedValue.ToShortName()), err := unmarshal@((Model.BaseType as SequenceTypeGo).ElementType.GetInterfaceName())Array(body)
        }
        else
        {
    @:@(Model.BaseType.Name.FixedValue.ToShortName()), err := unmarshal@(Model.BaseType.GetInterfaceName())(body)
        }
    <text>
	if err != nil {
		return err
	}
    </text>
        if (Model.BaseType is SequenceType type)
        {
            @:@(Model.Name.FixedValue.ToShortName()).Value = &@type.ElementType.Name.FixedValue.ToShortName()
        }
        else
        {
    @:@(Model.Name.FixedValue.ToShortName()).Value = @(Model.BaseType.Name.FixedValue.ToShortName())
        }
    }
    else
    {
    <text>
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}

    var v *json.RawMessage
        @foreach (var p in Model.AllProperties)
        {
        <text>
    @EmptyLine
    v = m["@(p.SerializedName)"]
    if v != nil {
            @if (p.ModelType is CompositeType && ((CompositeTypeGo) p.ModelType).IsPolymorphic)
            {
        @:@(CodeNamerGo.Instance.GetVariableName(p.SerializedName)), err := unmarshal@(p.ModelType.GetInterfaceName())(*m["@(p.SerializedName)"])
            }
            else if ((p.ModelType as SequenceType)?.ElementType is CompositeType && ((CompositeType) ((SequenceType) p.ModelType).ElementType).IsPolymorphic)
            {
        @:@(CodeNamerGo.Instance.GetVariableName(p.SerializedName)), err := unmarshal@(((SequenceTypeGo) p.ModelType).ElementType.GetInterfaceName())Array(*m["@(p.SerializedName)"])
            }
            else
            {
            <text>
        var @(CodeNamerGo.Instance.GetVariableName(p.SerializedName)) @(p.ModelType.Name)
        err = json.Unmarshal(*m["@(p.SerializedName)"], &@(CodeNamerGo.Instance.GetVariableName(p.SerializedName)))
            </text>
            }
        if err != nil {
            return err
        }
            @if ((p.ModelType is CompositeType && ((CompositeTypeGo) p.ModelType).IsPolymorphic) || (p.ModelType is EnumType))
            {
        @:@(Model.Name.FixedValue.ToShortName()).@(p.Name) = @(CodeNamerGo.Instance.GetVariableName(p.SerializedName))
            }
            else
            {
        @:@(Model.Name.FixedValue.ToShortName()).@(p.Name) = &@(CodeNamerGo.Instance.GetVariableName(p.SerializedName))
            }
    }
        </text>
        }
    </text>
    }
    @EmptyLine
    return nil
}
</text>
}

@if (!string.IsNullOrEmpty(Model.NextLink) && Model.PreparerNeeded)
{
<text>
@EmptyLine
// @(Model.PreparerMethodName) prepares a request to retrieve the next set of results. It returns
// nil if no more results exist.
func (client @(Model.Name)) @(Model.PreparerMethodName)() (*http.Request, error) {
    if client.@(Model.NextLink) == nil || len(to.String(client.@(Model.NextLink))) <= 0 {
        return nil, nil
    }
    return autorest.Prepare(&http.Request{},
        autorest.AsJSON(),
        autorest.AsGet(),
        autorest.WithBaseURL(to.String(client.@(Model.NextLink))));
}
</text>
}

@if (Model is FutureTypeGo)
{
    var ftg = Model as FutureTypeGo;
<text>
// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future @Model.Name) Result(client @ftg.ClientTypeName) (@ftg.ResultTypeName, error) {
    done, err := future.Done(client)
    if err != nil {
        return @ftg.ResultTypeName{}, err
    }
    if !done {
        return @ftg.ResultTypeName{}, autorest.NewError("@(Model.CodeModel.Namespace).@Model.Name", "Result", "asynchronous operation has not completed")
    }
    if future.PollingMethod() == azure.PollingLocation {
        return client.@(ftg.ResponderMethodName)(future.Response())
    }
    resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
        autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    if err != nil {
        return @ftg.ResultTypeName{}, err
    }
    return client.@(ftg.ResponderMethodName)(resp)
}
</text>
}
