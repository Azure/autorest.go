@using AutoRest.Core.Model
@using AutoRest.Core.Utilities
@using AutoRest.Go
@using AutoRest.Go.Model
@using AutoRest.Go.Templates
@using System.Linq
@inherits AutoRest.Core.Template<AutoRest.Go.Model.CompositeTypeGo>
@{
    var shortName = Model.Name.ToString().ToShortName();
    var desc = $"{Model.Name} ...";
    if (!string.IsNullOrEmpty(Model.Documentation))
    {
        desc = $"{Model.Name} - {Model.Documentation}";
    }
}
@if (Model.HasInterface())
{
    @WrapComment("// ", $"{Model.GetInterfaceName()} {Model.Documentation.ToSentence()}")
    <text>
        type @(Model.GetInterfaceName()) interface {
        @foreach (var dt in Model.DerivedTypes)
        {
            @:As@(dt.Name) () (*@(dt.Name), bool)
            if (dt.HasInterface())
            {
                @:As@(dt.GetInterfaceName()) () (@(dt.GetInterfaceName()), bool)
            }
        }
        As@(Model.Name) () (*@(Model.Name), bool)
        }

        @EmptyLine
        @WrapComment("// ", $"{Model.Name} {Model.Documentation.ToSentence()}")
        type @(Model.Name) struct {
        @(Model.AddHTTPResponse())
        @(Model.Fields(forMarshaller: false))
        }
        </text>
}
else
{
    <text>
        @EmptyLine
        @WrapComment("// ", desc)
        type @Model.Name struct {
        @if (Model.IsResponseType)
        {
            @:rawResponse *http.Response
        }
        @(Model.Fields(false))
        }
    </text>
}

@if (Model.BaseIsPolymorphic || Model.IsPolymorphic)
{
     foreach (var st in Model.SiblingTypes)
     {
         <text>
             @EmptyLine
             // As@(st.Name) is the @(Model.RootType.GetInterfaceName()) implementation for @(Model.Name).
             func (@(Model.Name.FixedValue.ToShortName()) @(Model.Name)) As@(st.Name)() (*@(st.Name), bool) {
             @if (st.Equals(Model))
             {
                 @:return &@(Model.Name.FixedValue.ToShortName()), true
             }
             else
             {
                 @:return nil, false
             }
             }
             @if (st.HasInterface())
             {
                 @EmptyLine
                 @:// As@(st.GetInterfaceName()) is the @(Model.RootType.GetInterfaceName()) implementation for @(Model.Name).
                 @:func(@(Model.Name.FixedValue.ToShortName()) @(Model.Name)) As@(st.GetInterfaceName())()(@(st.GetInterfaceName()), bool) {
                 if (st.Equals(Model) || Model.DerivesFrom(st))
                 {
                     @:return &@(Model.Name.FixedValue.ToShortName()), true
                 }
                 else
                 {
                     @:return nil, false
                 }
                 @:}
                 @EmptyLine
             }
         </text>
     }
}


@if (Model.CodeModel.ShouldGenerateXmlSerialization)
{
    @(Include(new MarshallingXml(), Model))
}
else
{
    @(Include(new MarshallingJson(), Model))
}

@EmptyLine
@if (Model.IsResponseType)
{
    var statusCodeFn = "StatusCode";
    var statusFn = "Status";
    if (Model.Properties.Any(p => p.Name == statusCodeFn))
    {
        statusCodeFn = $"HTTP{statusCodeFn}";
    }
    if (Model.Properties.Any(p => p.Name == statusFn))
    {
        statusFn = $"HTTP{statusFn}";
    }
    <text>
        // Response returns the raw HTTP response object.
        func (@shortName @Model.Name) Response() *http.Response {
        return @(shortName).rawResponse
        }

        // @statusCodeFn returns the HTTP status code of the response, e.g. 200.
        func (@shortName @Model.Name) @(statusCodeFn)() int {
        return @(shortName).rawResponse.StatusCode
        }

        // @statusFn returns the HTTP status message of the response, e.g. "200 OK".
        func (@shortName @Model.Name) @(statusFn)() string {
        return @(shortName).rawResponse.Status
        }
    </text>
    if (Model.IsStreamType())
    {
        <text>
            // Body returns the raw HTTP response object's Body.
            func (@shortName @Model.Name) Body() io.ReadCloser {
            return @(shortName).rawResponse.Body
            }
        </text>
    }
}
@EmptyLine
@foreach (var headerResp in Model.ResponseHeaders())
{
    var retSig = "string";
    var retExpr = $"{shortName}.rawResponse.Header.Get(\"{headerResp.Type.SerializedName}\")";
    if (headerResp.Type.ModelType.IsDateTimeType())
    {
        retSig = "time.Time";
    }
    else if (headerResp.Type.ModelType is EnumTypeGo)
    {
        retSig = headerResp.Type.ModelTypeName;
        retExpr = $"{headerResp.Type.ModelType.Name}({retExpr})";
    }
    else if (headerResp.Type.ModelType.IsETagType())
    {
        retSig = CodeNamerGo.Instance.ETagTypeName;
        retExpr = $"{CodeNamerGo.Instance.ETagTypeName}({retExpr})";
    }
    else if (headerResp.Type.ModelType.IsPrimaryType(KnownPrimaryType.Int) || headerResp.Type.ModelType.IsPrimaryType(KnownPrimaryType.Long))
    {
        retSig = headerResp.Type.ModelTypeName;
    }
    else if (headerResp.Type.ModelType.IsPrimaryType(KnownPrimaryType.ByteArray))
    {
        retSig = "[]byte";
    }
    <text>
        // @headerResp.Name returns the value for header @(headerResp.Type.SerializedName).
        func (@shortName @Model.Name) @(headerResp.Name)() @retSig {
    </text>
    if (headerResp.Type.ModelType.IsDateTimeType())
    {
        var formatAs = "rfc3339Format";
        if (headerResp.Type.ModelType.IsPrimaryType(KnownPrimaryType.DateTimeRfc1123))
        {
            formatAs = "time.RFC1123";
        }
        <text>
            s := @retExpr
            if s == "" {
            return time.Time{}
            }
            t, err := time.Parse(@formatAs, s)
            if err != nil {
            panic(err)
            }
            return t
        </text>
    }
    else if (headerResp.Type.ModelType.IsPrimaryType(KnownPrimaryType.Int) || headerResp.Type.ModelType.IsPrimaryType(KnownPrimaryType.Long))
    {
        var bitSize = headerResp.Type.ModelType.IsPrimaryType(KnownPrimaryType.Int) ? "32" : "64";
        <text>
            s := @retExpr
            if s == "" {
            return -1
            }
            i, err := strconv.ParseInt(s, 10, @bitSize)
            if err != nil {
            panic(err)
            }
            return @(headerResp.Type.ModelType.IsPrimaryType(KnownPrimaryType.Int) ? "int32(i)" : "i")
        </text>
    }
    else if (headerResp.Type.ModelType.IsPrimaryType(KnownPrimaryType.ByteArray))
    {
        <text>
            s := @retExpr
            if s == "" {
            return nil
            }
            b, err := base64.StdEncoding.DecodeString(s)
            if err != nil {
            panic(err)
            }
            return b
        </text>
    }
    else
    {
        @:return @retExpr
    }
    @:}
}
@if (Model.ResponseIncludesMetadata)
{
    <text>
        // NewMetadata returns user-defined key/value pairs.
        func(@shortName @Model.Name) NewMetadata() Metadata {
        md := Metadata{}
        for k, v := range @(shortName).rawResponse.Header {
        if len(k) > mdPrefixLen {
        if prefix := k[0:mdPrefixLen]; strings.EqualFold(prefix, mdPrefix) {
        md[strings.ToLower(k[mdPrefixLen:])] = v[0]
        }
        }
        }
        return md
        }
    </text>
}

@if (Model.IsDateTimeCustomHandlingRequired)
{
    var internalName = Model.Name.ToCamelCase();
    var rec = Model.Name.ToString().ToShortName();
    var local = $"{rec}2";
    <text>
// MarshalXML implements the xml.Marshaler interface for @Model.Name.
    func (@rec @Model.Name) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
        if reflect.TypeOf((*@Model.Name)(nil)).Elem().Size() != reflect.TypeOf((*@internalName)(nil)).Elem().Size() {
            panic("size mismatch between @Model.Name and @internalName")
        }
        @local := (*@internalName)(unsafe.Pointer(&@rec))
        return e.EncodeElement(*@local, start)
    }

// UnmarshalXML implements the xml.Unmarshaler interface for @Model.Name.
    func (@rec *@Model.Name) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
        if reflect.TypeOf((*@Model.Name)(nil)).Elem().Size() != reflect.TypeOf((*@internalName)(nil)).Elem().Size() {
            panic("size mismatch between @Model.Name and @internalName")
        }
        @local := (*@internalName)(unsafe.Pointer(@rec))
        return d.DecodeElement(@local, &start)
    }
    </text>
}
