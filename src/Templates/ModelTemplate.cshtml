@using AutoRest.Core.Model
@using AutoRest.Core.Utilities
@using AutoRest.Go
@using AutoRest.Go.Model
@using AutoRest.Go.Templates
@using System.Linq
@inherits AutoRest.Core.Template<AutoRest.Go.Model.CompositeTypeGo>
@{
    var shortName = Model.Name.ToString().ToShortName();
    var desc = $"{Model.Name} ...";
    if (!string.IsNullOrEmpty(Model.Documentation))
    {
        desc = $"{Model.Name} - {Model.Documentation}";
    }
}
@if (Model.HasInterface())
{
    @WrapComment("// ", $"{Model.GetInterfaceName()} {Model.Documentation.ToSentence()}")
    <text>
        type @(Model.GetInterfaceName()) interface {
        @foreach (var dt in Model.DerivedTypes)
        {
            @:As@(dt.Name) () (*@(dt.Name), bool)
            if (dt.HasInterface())
            {
                @:As@(dt.GetInterfaceName()) () (@(dt.GetInterfaceName()), bool)
            }
        }
        As@(Model.Name) () (*@(Model.Name), bool)
        }

        @EmptyLine
        @WrapComment("// ", $"{Model.Name} {Model.Documentation.ToSentence()}")
        type @(Model.Name) struct {
        @(Model.AddHTTPResponse())
        @(Model.Fields(forMarshaller: false))
        }

        @EmptyLine
        func unmarshal@(Model.GetInterfaceName())(body []byte) (@(Model.GetInterfaceName()), error){
        var m map[string]interface{}
        err := json.Unmarshal(body, &m)
        if err != nil {
        return nil, err
        }
        @EmptyLine
        switch m["@(Model.RootType.PolymorphicDiscriminator)"] {
        @foreach (var dt in Model.DerivedTypes)
        {
            <text>
            case string(@(CodeNamerGo.Instance.GetEnumMemberName((dt as CompositeTypeGo).DiscriminatorEnumValue))):
            var @(dt.Name.FixedValue.ToShortName()) @(dt.Name)
            err := json.Unmarshal(body, &@(dt.Name.FixedValue.ToShortName()))
            return @(dt.Name.FixedValue.ToShortName()), err
            </text>
        }
        default:
        var @(Model.Name.FixedValue.ToShortName()) @(Model.Name)
        err := json.Unmarshal(body, &@(Model.Name.FixedValue.ToShortName()))
        return @(Model.Name.FixedValue.ToShortName()), err
        }
        }

        func unmarshal@(Model.GetInterfaceName())Array(body []byte) ([]@(Model.GetInterfaceName()), error){
        var rawMessages []*json.RawMessage
        err := json.Unmarshal(body, &rawMessages)
        if err != nil {
        return nil, err
        }
        @EmptyLine
        @(Model.Name.FixedValue.ToShortName())Array := make([]@(Model.GetInterfaceName()), len(rawMessages))
        @EmptyLine
        for index, rawMessage := range rawMessages {
        @(Model.Name.FixedValue.ToShortName()), err := unmarshal@(Model.GetInterfaceName())(*rawMessage)
        if err != nil {
        return nil, err
        }
        @(Model.Name.FixedValue.ToShortName())Array[index] = @(Model.Name.FixedValue.ToShortName())
        }
        return @(Model.Name.FixedValue.ToShortName())Array, nil
        }
        </text>
}
else
{
    <text>
        @EmptyLine
        @WrapComment("// ", desc)
        type @Model.Name struct {
        @if (Model.IsResponseType)
        {
            @:rawResponse *http.Response
        }
        @(Model.Fields(false))
        }
    </text>
}

@if (Model.BaseIsPolymorphic && Model.IsPolymorphic)
{
    <text>
        @EmptyLine
        // MarshalJSON is the custom marshaler for @(Model.Name).
        func (@(Model.Name.FixedValue.ToShortName()) @(Model.Name))MarshalJSON() ([]byte, error){
        @(Model.Name.FixedValue.ToShortName()).@(Model.PolymorphicProperty) = @(Model.DiscriminatorEnumValue)
        type Alias @(Model.Name)
        return json.Marshal(&struct {
        Alias
        }{
        Alias: (Alias)(@(Model.Name.FixedValue.ToShortName())),
        })
        }

        @foreach (var st in Model.SiblingTypes)
        {
            <text>
            @EmptyLine
            // As@(st.Name) is the @(Model.RootType.GetInterfaceName()) implementation for @(Model.Name).
            func (@(Model.Name.FixedValue.ToShortName()) @(Model.Name)) As@(st.Name)() (*@(st.Name), bool) {
            @if (st.Equals(Model))
            {
                @:return &@(Model.Name.FixedValue.ToShortName()), true
            }
            else
            {
                @:return nil, false
            }
                }
            @if (st.HasInterface())
            {
                    @EmptyLine
                    @:// As@(st.GetInterfaceName()) is the @(Model.RootType.GetInterfaceName()) implementation for @(Model.Name).
                    @:func(@(Model.Name.FixedValue.ToShortName()) @(Model.Name)) As@(st.GetInterfaceName())()(@(st.GetInterfaceName()), bool) {
                    if (st.Equals(Model) || Model.DerivesFrom(st))
                    {
                        @:return &@(Model.Name.FixedValue.ToShortName()), true
                    }
                    else
                    {
                        @:return nil, false
                    }
                    @:}
                    @EmptyLine
             }
    </text>
}
        </text>
}

@if (Model.HasPolymorphicFields && Model.HasFlattenedFields)
{
    <text>
        // UnmarshalJSON is the custom unmarshaler for @(Model.Name) struct.
        func (@(Model.Name.FixedValue.ToShortName()) *@(Model.Name)) UnmarshalJSON(body []byte) error {
        @if (Model.IsWrapperType)
        {
            if (Model.BaseType is SequenceTypeGo sequenceType)
            {
                @:@(sequenceType.ElementType.Name.FixedValue.ToShortName()), err := unmarshal@(sequenceType.ElementType.GetInterfaceName())Array(body)
            }
            else
            {
                @:@(Model.BaseType.Name.FixedValue.ToShortName()), err := unmarshal@(Model.BaseType.GetInterfaceName())(body)
            }
            <text>
                if err != nil {
                return err
                }
            </text>
            if (Model.BaseType is SequenceType type)
            {
                @:@(Model.Name.FixedValue.ToShortName()).Value = &@type.ElementType.Name.FixedValue.ToShortName()
            }
            else
            {
                @:@(Model.Name.FixedValue.ToShortName()).Value = @(Model.BaseType.Name.FixedValue.ToShortName())
            }
         }
        else
        {
    <text>
        var m map[string]*json.RawMessage
        err := json.Unmarshal(body, &m)
        if err != nil {
        return err
        }

        var v *json.RawMessage
        @foreach (var p in Model.AllProperties)
        {
            <text>
            @EmptyLine
            v = m["@(p.SerializedName)"]
                if v != nil {
            @if (p.ModelType.HasInterface())
            {
                    @:@(CodeNamerGo.Instance.GetVariableName(p.SerializedName)), err := unmarshal@(p.ModelType.GetInterfaceName())(*m["@(p.SerializedName)"])
            }
            else if (p.ModelType is SequenceTypeGo sequenceType && sequenceType.ElementType.HasInterface())
            {
                @:@(CodeNamerGo.Instance.GetVariableName(p.SerializedName)), err := unmarshal@(sequenceType.ElementType.GetInterfaceName())Array(*m["@(p.SerializedName)"])
            }
            else if (p.ModelType is CompositeType && ((CompositeTypeGo) p.ModelType).IsPolymorphic)
            {
                @:@(CodeNamerGo.Instance.GetVariableName(p.SerializedName)), err := unmarshal@(p.ModelType.Name)(*m["@(p.SerializedName)"])
            }
            else
            {
                <text>
                    var @(CodeNamerGo.Instance.GetVariableName(p.SerializedName)) @(p.ModelType.Name)
                    err = json.Unmarshal(*m["@(p.SerializedName)"], &@(CodeNamerGo.Instance.GetVariableName(p.SerializedName)))
                </text>
            }
            if err != nil {
            return err
            }
            @if (p.ModelType.HasInterface() || p.ModelType is EnumType)
            {
                @:@(Model.Name.FixedValue.ToShortName()).@(p.Name) = @(CodeNamerGo.Instance.GetVariableName(p.SerializedName))
            }
            else
            {
                @:@(Model.Name.FixedValue.ToShortName()).@(p.Name) = &@(CodeNamerGo.Instance.GetVariableName(p.SerializedName))
            }
            }
            </text>
        }
        </text>
        }
        @EmptyLine
        return nil
        }
        </text>
}
@EmptyLine
@if (Model.IsResponseType)
{
    var statusCodeFn = "StatusCode";
    var statusFn = "Status";
    if (Model.Properties.Any(p => p.Name == statusCodeFn))
    {
        statusCodeFn = $"HTTP{statusCodeFn}";
    }
    if (Model.Properties.Any(p => p.Name == statusFn))
    {
        statusFn = $"HTTP{statusFn}";
    }
    <text>
        // Response returns the raw HTTP response object.
        func (@shortName @Model.Name) Response() *http.Response {
        return @(shortName).rawResponse
        }

        // @statusCodeFn returns the HTTP status code of the response, e.g. 200.
        func (@shortName @Model.Name) @(statusCodeFn)() int {
        return @(shortName).rawResponse.StatusCode
        }

        // @statusFn returns the HTTP status message of the response, e.g. "200 OK".
        func (@shortName @Model.Name) @(statusFn)() string {
        return @(shortName).rawResponse.Status
        }
    </text>
    if (Model.IsStreamType())
    {
        <text>
            // Body returns the raw HTTP response object's Body.
            func (@shortName @Model.Name) Body() io.ReadCloser {
            return @(shortName).rawResponse.Body
            }
        </text>
    }
}
@EmptyLine
@foreach (var headerResp in Model.ResponseHeaders())
{
    var retSig = "string";
    var retExpr = $"{shortName}.rawResponse.Header.Get(\"{headerResp.Type.SerializedName}\")";
    if (headerResp.Type.ModelType.IsDateTimeType())
    {
        retSig = "time.Time";
    }
    else if (headerResp.Type.ModelType is EnumTypeGo)
    {
        retSig = headerResp.Type.ModelTypeName;
        retExpr = $"{headerResp.Type.ModelType.Name}({retExpr})";
    }
    else if (headerResp.Type.ModelType.IsETagType())
    {
        retSig = CodeNamerGo.Instance.ETagTypeName;
        retExpr = $"{CodeNamerGo.Instance.ETagTypeName}({retExpr})";
    }
    else if (headerResp.Type.ModelType.IsPrimaryType(KnownPrimaryType.Int) || headerResp.Type.ModelType.IsPrimaryType(KnownPrimaryType.Long))
    {
        retSig = headerResp.Type.ModelTypeName;
    }
    else if (headerResp.Type.ModelType.IsPrimaryType(KnownPrimaryType.ByteArray))
    {
        retSig = "[]byte";
    }
    <text>
        // @headerResp.Name returns the value for header @(headerResp.Type.SerializedName).
        func (@shortName @Model.Name) @(headerResp.Name)() @retSig {
    </text>
    if (headerResp.Type.ModelType.IsDateTimeType())
    {
        var formatAs = "rfc3339Format";
        if (headerResp.Type.ModelType.IsPrimaryType(KnownPrimaryType.DateTimeRfc1123))
        {
            formatAs = "time.RFC1123";
        }
        <text>
            s := @retExpr
            if s == "" {
            return time.Time{}
            }
            t, err := time.Parse(@formatAs, s)
            if err != nil {
            panic(err)
            }
            return t
        </text>
    }
    else if (headerResp.Type.ModelType.IsPrimaryType(KnownPrimaryType.Int) || headerResp.Type.ModelType.IsPrimaryType(KnownPrimaryType.Long))
    {
        var bitSize = headerResp.Type.ModelType.IsPrimaryType(KnownPrimaryType.Int) ? "32" : "64";
        <text>
            s := @retExpr
            if s == "" {
            return -1
            }
            i, err := strconv.ParseInt(s, 10, @bitSize)
            if err != nil {
            panic(err)
            }
            return @(headerResp.Type.ModelType.IsPrimaryType(KnownPrimaryType.Int) ? "int32(i)" : "i")
        </text>
    }
    else if (headerResp.Type.ModelType.IsPrimaryType(KnownPrimaryType.ByteArray))
    {
        <text>
            s := @retExpr
            if s == "" {
            return nil
            }
            b, err := base64.StdEncoding.DecodeString(s)
            if err != nil {
            panic(err)
            }
            return b
        </text>
    }
    else
    {
        @:return @retExpr
    }
    @:}
}
@if (Model.ResponseIncludesMetadata)
{
    <text>
        // NewMetadata returns user-defined key/value pairs.
        func(@shortName @Model.Name) NewMetadata() Metadata {
        md := Metadata{}
        for k, v := range @(shortName).rawResponse.Header {
        if len(k) > mdPrefixLen {
        if prefix := k[0:mdPrefixLen]; strings.EqualFold(prefix, mdPrefix) {
        md[strings.ToLower(k[mdPrefixLen:])] = v[0]
        }
        }
        }
        return md
        }
    </text>
}
