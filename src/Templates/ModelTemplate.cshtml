@using AutoRest.Core.Model
@using AutoRest.Core.Utilities
@using AutoRest.Go
@using AutoRest.Go.Model
@using AutoRest.Go.Templates
@using System.Linq

@inherits AutoRest.Core.Template<AutoRest.Go.Model.CompositeTypeGo>
@{
    var shortName = Model.Name.ToString().ToShortName();
    var desc = $"{Model.Name} ...";
    if (!string.IsNullOrEmpty(Model.Documentation))
    {
        desc = $"{Model.Name} - {Model.Documentation}";
    }
}

@if (Model.IsPolymorphic)
{
<text>
type @(Model.Name) interface {
    @foreach (var dt in Model.DerivedTypes)
    {
    @:As@(dt.Name) () (*@(dt.Name), bool)
    }
}

@EmptyLine
func unmarshal@(Model.Name)(body []byte) (@(Model.Name), error){
    var m map[string]interface{}
    err := json.Unmarshal(body, &m)
    if err != nil {
        return nil, err
    }
@EmptyLine
    switch m["@(Model.PolymorphicDiscriminator)"] {
    @foreach (var dt in Model.DerivedTypes)
    {
    <text>
    case string(@((dt as CompositeTypeGo).DiscriminatorEnumValue)):
        var @(dt.Name.FixedValue.ToShortName()) @(dt.Name)
        err := json.Unmarshal(body, &@(dt.Name.FixedValue.ToShortName()))
        return @(dt.Name.FixedValue.ToShortName()), err
    </text>
    }
    default:
        return nil, errors.New("Unsupported type")
    }
}

func unmarshal@(Model.Name)Array(body []byte) ([]@(Model.Name), error){
    var rawMessages []*json.RawMessage
    err := json.Unmarshal(body, &rawMessages)
    if err != nil {
        return nil, err
    }
@EmptyLine
    @(Model.Name.FixedValue.ToShortName())Array := make([]@(Model.Name), len(rawMessages))
@EmptyLine
    for index, rawMessage := range rawMessages {
        @(Model.Name.FixedValue.ToShortName()), err := unmarshal@(Model.Name)(*rawMessage)
        if err != nil {
            return nil, err
        }
        @(Model.Name.FixedValue.ToShortName())Array[index] = @(Model.Name.FixedValue.ToShortName())
    }
    return @(Model.Name.FixedValue.ToShortName())Array, nil
}
</text>
}
else
{
<text>
@WrapComment("// ", desc)
type @Model.Name struct {
    @if (Model.IsResponseType)
    {
    @:rawResponse *http.Response
    }
@(Model.Fields(false))
}
</text>
}

@if (Model.BaseIsPolymorphic && !Model.IsPolymorphic)
{
<text>
@EmptyLine
// MarshalJSON is the custom marshaler for @(Model.Name).
func (@(Model.Name.FixedValue.ToShortName()) @(Model.Name))MarshalJSON() ([]byte, error){
    @(Model.Name.FixedValue.ToShortName()).@(Model.PolymorphicProperty) = @(Model.DiscriminatorEnumValue)
    type Alias @(Model.Name)
    return json.Marshal(&struct {
        Alias
    }{
        Alias: (Alias)(@(Model.Name.FixedValue.ToShortName())),
    })
}

    @foreach (var st in Model.SiblingTypes)
    {
    <text>
@EmptyLine
// As@(st.Name) is the @(Model.BaseModelType.Name) implementation for @(Model.Name).
func (@(Model.Name.FixedValue.ToShortName()) @(Model.Name)) As@(st.Name)() (*@(st.Name), bool) {
        @if (st.Equals(Model))
        {
    @:return &@(Model.Name.FixedValue.ToShortName()), true
        }
        else
        {
    @:return nil, false
        }
}
    </text>
    }
</text>
}

@if (Model.HasPolymorphicFields && !Model.IsPolymorphic)
{
<text>
// UnmarshalJSON is the custom unmarshaler for @(Model.Name) struct.
func (@(Model.Name.FixedValue.ToShortName()) *@(Model.Name)) UnmarshalJSON(body []byte) error {
    @if (Model.IsWrapperType)
    {
    <text>
    @(Model.BaseType.Name.FixedValue.ToShortName()), err := unmarshal@(Model.BaseType.Name)(body)
    if err != nil {
        return err
    }
    @(Model.Name.FixedValue.ToShortName()).Value = @(Model.BaseType.Name.FixedValue.ToShortName())
    </text>
    }
    else
    {
    <text>
    var m map[string]*json.RawMessage
    err := json.Unmarshal(body, &m)
    if err != nil {
        return err
    }

    var v *json.RawMessage
        @foreach (var p in Model.AllProperties)
        {
        <text>
            @EmptyLine
    v = m["@(p.SerializedName)"]
    if v != nil {
            @if (p.ModelType is CompositeType && (p.ModelType as CompositeTypeGo).IsPolymorphic)
            {
        @:@(CodeNamerGo.Instance.GetVariableName(p.SerializedName)), err := unmarshal@(p.ModelType.Name)(*m["@(p.SerializedName)"])
            }
            else if (p.ModelType is SequenceType && (p.ModelType as SequenceTypeGo).ElementType is CompositeType && ((p.ModelType as SequenceTypeGo).ElementType as CompositeType).IsPolymorphic)
            {
        @:@(CodeNamerGo.Instance.GetVariableName(p.SerializedName)), err := unmarshal@((p.ModelType as SequenceTypeGo).ElementType.Name)Array(*m["@(p.SerializedName)"])
            }
            else
            {
            <text>
        var @(CodeNamerGo.Instance.GetVariableName(p.SerializedName)) @(p.ModelType.Name)
        err = json.Unmarshal(*m["@(p.SerializedName)"], &@(CodeNamerGo.Instance.GetVariableName(p.SerializedName)))
            </text>
            }
        if err != nil {
            return err
        }
            @if ((p.ModelType is CompositeType && (p.ModelType as CompositeTypeGo).IsPolymorphic) || (p.ModelType is EnumType))
            {
        @:@(Model.Name.FixedValue.ToShortName()).@(p.Name) = @(CodeNamerGo.Instance.GetVariableName(p.SerializedName))
            }
            else
            {
        @:@(Model.Name.FixedValue.ToShortName()).@(p.Name) = &@(CodeNamerGo.Instance.GetVariableName(p.SerializedName))
            }
    }
        </text>
        }
    </text>
    }
@EmptyLine
    return nil
}
</text>
}

@EmptyLine
@if (Model.IsResponseType)
{
    var statusCodeFn = "StatusCode";
    var statusFn = "Status";
    if (Model.Properties.Where(p => p.Name == statusCodeFn).Any())
    {
        statusCodeFn = $"HTTP{statusCodeFn}";
    }
    if (Model.Properties.Where(p => p.Name == statusFn).Any())
    {
        statusFn = $"HTTP{statusFn}";
    }
<text>
// Response returns the raw HTTP response object.
func (@shortName @Model.Name) Response() *http.Response {
    return @(shortName).rawResponse
}

// @statusCodeFn returns the HTTP status code of the response, e.g. 200.
func (@shortName @Model.Name) @(statusCodeFn)() int {
    return @(shortName).rawResponse.StatusCode
}

// @statusFn returns the HTTP status message of the response, e.g. "200 OK".
func (@shortName @Model.Name) @(statusFn)() string {
    return @(shortName).rawResponse.Status
}
</text>
    if (Model.IsStreamType())
    {
    <text>

// Body returns the raw HTTP response object's Body.
func (@shortName @Model.Name) Body() io.ReadCloser {
    return @(shortName).rawResponse.Body
}
    </text>
    }
}
@EmptyLine
@foreach (var headerResp in Model.ResponseHeaders())
{
    var retSig = "string";
    var retExpr = $"{shortName}.rawResponse.Header.Get(\"{headerResp.Type.SerializedName}\")";
    if (headerResp.Type.ModelType.IsDateTimeType())
    {
        retSig = "time.Time";
    }
    else if (headerResp.Type.ModelType is EnumTypeGo)
    {
        retSig = headerResp.Type.ModelTypeName;
        retExpr = $"{headerResp.Type.ModelType.Name}({retExpr})";
    }
    else if (headerResp.Type.ModelType.IsETagType())
    {
        retSig = CodeNamerGo.Instance.ETagTypeName;
        retExpr = $"{CodeNamerGo.Instance.ETagTypeName}({retExpr})";
    }
    else if (headerResp.Type.ModelType.IsPrimaryType(KnownPrimaryType.Int) || headerResp.Type.ModelType.IsPrimaryType(KnownPrimaryType.Long))
    {
        retSig = headerResp.Type.ModelTypeName;
    }
    else if (headerResp.Type.ModelType.IsPrimaryType(KnownPrimaryType.ByteArray))
    {
        retSig = "[]byte";
    }
<text>
// @headerResp.Name returns the value for header @(headerResp.Type.SerializedName).
func (@shortName @Model.Name) @(headerResp.Name)() @retSig {
</text>
    if (headerResp.Type.ModelType.IsDateTimeType())
    {
        var formatAs = "rfc3339Format";
        if (headerResp.Type.ModelType.IsPrimaryType(KnownPrimaryType.DateTimeRfc1123))
        {
            formatAs = "time.RFC1123";
        }
        <text>
    s := @retExpr
    if s == "" {
        return time.Time{}
    }
    t, err := time.Parse(@formatAs, s)
    if err != nil {
        panic(err)
    }
    return t
        </text>
    }
    else if (headerResp.Type.ModelType.IsPrimaryType(KnownPrimaryType.Int) || headerResp.Type.ModelType.IsPrimaryType(KnownPrimaryType.Long))
    {
        var bitSize = headerResp.Type.ModelType.IsPrimaryType(KnownPrimaryType.Int) ? "32" : "64";
    <text>
    s := @retExpr
    if s == "" {
        return -1
    }
    i, err := strconv.ParseInt(s, 10, @bitSize)
    if err != nil {
        panic(err)
    }
    return @(headerResp.Type.ModelType.IsPrimaryType(KnownPrimaryType.Int) ? "int32(i)" : "i")
    </text>
    }
    else if (headerResp.Type.ModelType.IsPrimaryType(KnownPrimaryType.ByteArray))
    {
    <text>
    s := @retExpr
    if s == "" {
        return nil
    }
    b, err := base64.StdEncoding.DecodeString(s)
    if err != nil {
        panic(err)
    }
    return b
    </text>
    }
    else
    {
    @:return @retExpr
    }
@:}
}

@if (Model.ResponseIncludesMetadata)
{
<text>
// NewMetadata returns user-defined key/value pairs.
func(@shortName @Model.Name) NewMetadata() Metadata {
    md := Metadata{}
    for k, v := range @(shortName).rawResponse.Header {
        if len(k) > mdPrefixLen {
            if prefix := k[0:mdPrefixLen]; strings.EqualFold(prefix, mdPrefix) {
                md[strings.ToLower(k[mdPrefixLen:])] = v[0]
            }
        }
    }
    return md
}
</text>
}
