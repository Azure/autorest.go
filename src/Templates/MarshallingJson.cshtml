@using AutoRest.Core.Model
@using AutoRest.Core.Utilities
@using AutoRest.Go
@using AutoRest.Go.Model
@using AutoRest.Go.Templates
@using System.Collections.Generic
@using System.Linq
@inherits AutoRest.Core.Template<AutoRest.Go.Model.CompositeTypeGo>
@EmptyLine

@if (Model.HasInterface())
{
    <text>
        func unmarshal@(Model.GetInterfaceName())(body []byte) (@(Model.GetInterfaceName()), error){
        var m map[string]interface{}
        err := json.Unmarshal(body, &m)
        if err != nil {
        return nil, err
        }
        @EmptyLine
        switch m["@(Model.RootType.PolymorphicDiscriminator)"] {
        @foreach (var dt in Model.DerivedTypes)
        {
            <text>
                case string(@CodeNamerGo.Instance.GetEnumMemberName(((CompositeTypeGo) dt).DiscriminatorEnumValue)):
                var @(dt.Name.FixedValue.ToShortName()) @(dt.Name)
                err := json.Unmarshal(body, &@(dt.Name.FixedValue.ToShortName()))
                return @(dt.Name.FixedValue.ToShortName()), err
            </text>
        }
        default:
        var @(Model.Name.FixedValue.ToShortName()) @(Model.Name)
        err := json.Unmarshal(body, &@(Model.Name.FixedValue.ToShortName()))
        return @(Model.Name.FixedValue.ToShortName()), err
        }
        }

        func unmarshal@(Model.GetInterfaceName())Array(body []byte) ([]@(Model.GetInterfaceName()), error){
        var rawMessages []*json.RawMessage
        err := json.Unmarshal(body, &rawMessages)
        if err != nil {
        return nil, err
        }
        @EmptyLine
        @(Model.Name.FixedValue.ToShortName())Array := make([]@(Model.GetInterfaceName()), len(rawMessages))
        @EmptyLine
        for index, rawMessage := range rawMessages {
        @(Model.Name.FixedValue.ToShortName()), err := unmarshal@(Model.GetInterfaceName())(*rawMessage)
        if err != nil {
        return nil, err
        }
        @(Model.Name.FixedValue.ToShortName())Array[index] = @(Model.Name.FixedValue.ToShortName())
        }
        return @(Model.Name.FixedValue.ToShortName())Array, nil
        }
    </text>
}

@if (Model.BaseIsPolymorphic || Model.IsPolymorphic)
{
    <text>
        @EmptyLine
        // MarshalJSON is the custom marshaler for @(Model.Name).
        func (@(Model.Name.FixedValue.ToShortName()) @(Model.Name))MarshalJSON() ([]byte, error){
        @(Model.Name.FixedValue.ToShortName()).@(Model.PolymorphicProperty) = @(Model.DiscriminatorEnumValue)
        type Alias @(Model.Name)
        return json.Marshal(&struct {
        Alias
        }{
        Alias: (Alias)(@(Model.Name.FixedValue.ToShortName())),
        })
        }
    </text>
}

@if (Model.HasPolymorphicFields || Model.HasFlattenedFields)
{
    <text>
        // UnmarshalJSON is the custom unmarshaler for @(Model.Name) struct.
        func (@(Model.Name.FixedValue.ToShortName()) *@(Model.Name)) UnmarshalJSON(body []byte) error {
        @if (Model.IsWrapperType)
        {
            if (Model.BaseType is SequenceTypeGo sequenceType)
            {
                @:@(sequenceType.ElementType.Name.FixedValue.ToShortName()), err := unmarshal@(sequenceType.ElementType.GetInterfaceName())Array(body)
            }
            else
            {
                @:@(Model.BaseType.Name.FixedValue.ToShortName()), err := unmarshal@(Model.BaseType.GetInterfaceName())(body)
            }
            <text>
            if err != nil {
            return err
            }
    </text>
    if (Model.BaseType is SequenceType type)
    {
        @:@(Model.Name.FixedValue.ToShortName()).Value = &@type.ElementType.Name.FixedValue.ToShortName()
    }
    else
    {
        @:@(Model.Name.FixedValue.ToShortName()).Value = @(Model.BaseType.Name.FixedValue.ToShortName())
    }
}
else
{
    <text>
        var m map[string]*json.RawMessage
        err := json.Unmarshal(body, &m)
        if err != nil {
        return err
        }

        var v *json.RawMessage
        @foreach (var p in Model.AllProperties)
        {
            <text>
            @EmptyLine
            v = m["@(p.SerializedName)"]
            if v != nil {
            @if (p.ModelType.HasInterface())
            {
                @:@(CodeNamerGo.Instance.GetVariableName(p.SerializedName)), err := unmarshal@(p.ModelType.GetInterfaceName())(*m["@(p.SerializedName)"])
            }
            else if (p.ModelType is SequenceTypeGo sequenceType && sequenceType.ElementType.HasInterface())
            {
                @:@(CodeNamerGo.Instance.GetVariableName(p.SerializedName)), err := unmarshal@(sequenceType.ElementType.GetInterfaceName())Array(*m["@(p.SerializedName)"])
            }
            else if (p.ModelType is CompositeType && ((CompositeTypeGo)p.ModelType).IsPolymorphic)
            {
                @:@(CodeNamerGo.Instance.GetVariableName(p.SerializedName)), err := unmarshal@(p.ModelType.Name)(*m["@(p.SerializedName)"])
            }
            else
            {
                <text>
                var @(CodeNamerGo.Instance.GetVariableName(p.SerializedName)) @(p.ModelType.Name)
                err = json.Unmarshal(*m["@(p.SerializedName)"], &@(CodeNamerGo.Instance.GetVariableName(p.SerializedName)))
    </text>
}
            if err != nil {
            return err
            }
            @if (p.ModelType.HasInterface() || p.ModelType is EnumType)
            {
                @:@(Model.Name.FixedValue.ToShortName()).@(p.Name) = @(CodeNamerGo.Instance.GetVariableName(p.SerializedName))
            }
            else
            {
                @:@(Model.Name.FixedValue.ToShortName()).@(p.Name) = &@(CodeNamerGo.Instance.GetVariableName(p.SerializedName))
            }
            }
            </text>
        }
        </text>
    }
        @EmptyLine
        return nil
        }
        </text>
    }