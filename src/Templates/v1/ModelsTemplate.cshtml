@using AutoRest.Core.Utilities
@using AutoRest.Go
@using AutoRest.Go.Decorators.v1
@using AutoRest.Go.Model
@using AutoRest.Go.Templates.v1
@using System;
@using System.Collections.Generic;
@using System.Linq;

@inherits AutoRest.Core.Template<AutoRest.Go.Model.CodeModelGo>
@{
    // Ensure all enumerated type values have the simplest possible unique names
    // -- The code assumes that all public type names are unique within the client and that the values
    //    of an enumerated type are unique within that type. To safely promote the enumerated value name
    //    to the top-level, it must not conflict with other existing types. If it does, prepending the
    //    value name with the (assumed to be unique) enumerated type name will make it unique.

    // First, collect all type names (since these cannot change)
    var topLevelNames = new HashSet<string>();
    foreach (var mt in Model.ModelTypes)
    {
        topLevelNames.Add(mt.Name);
    }

    // Then, note each enumerated type with one or more conflicting values and collect the values from
    // those enumerated types without conflicts.  do this on a sorted list to ensure consistent naming
    var conflicts = new HashSet<EnumTypeGo>();
    foreach (var em in Model.EnumTypes.Cast<EnumTypeGo>().OrderBy(etg => etg.Name.Value))
    {
        if (em.Values.Where(v => topLevelNames.Contains(v.Name) || CodeNamerGo.Instance.UserDefinedNames.Contains(v.Name)).Any())
        {
            conflicts.Add(em);
        }
        else
        {
            topLevelNames.UnionWith(em.Values.Select(ev => ev.Name));
        }
    }

    var enums = Model.EnumTypes.Cast<EnumTypeGo>().ToList();
    enums.Sort(delegate(EnumTypeGo lhs, EnumTypeGo rhs) { return lhs.Name.FixedValue.CompareTo(rhs.Name); });

    var modelTypes = Model.ModelTypes.Cast<CompositeTypeGo>().ToList();
    modelTypes.Sort(delegate (CompositeTypeGo x, CompositeTypeGo y) { return x.Name.Value.CompareTo(y.Name.Value); });
}
package @Model.Namespace
@EmptyLine
@Header("// ")

@EmptyLine

@if (!Model.ModelImports.IsNullOrEmpty())
{
@:import (
foreach (var import in Model.ModelImports)
{
    @:@(import)
}
@:)    
@EmptyLine
}

@foreach (var e in enums) {
@:@(Include(new EnumTemplate(), new EnumTypeGoDecorator(e, !conflicts.Contains(e))))
@EmptyLine
@:
}

@foreach (var mt in modelTypes) {
@:@(Include(new ModelTemplate(), mt))
@EmptyLine
@:
}
